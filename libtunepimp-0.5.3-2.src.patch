--- origsrc/libtunepimp-0.5.3/configure.in	2008-06-16 01:07:55.078125000 -0500
+++ src/libtunepimp-0.5.3/configure.in	2008-06-16 01:08:07.312500000 -0500
@@ -30,6 +30,12 @@
 AM_CONDITIONAL(DARWIN, test x$os = xdarwin)
 AM_CONDITIONAL(FREEBSD, test x$os = xfreebsd)
 
+case "$host_os" in
+  cygwin*|os2*)  SOEXT=".dll" ;;
+  *)             SOEXT=".so"  ;;
+esac
+AC_SUBST(SOEXT)
+
 dnl Checks for programs.
 AC_PREREQ(2.52)
 AC_PROG_CC
--- origsrc/libtunepimp-0.5.3/examples/Makefile.am	2006-11-18 04:52:35.000000000 -0600
+++ src/libtunepimp-0.5.3/examples/Makefile.am	2008-06-16 01:08:07.312500000 -0500
@@ -25,4 +25,4 @@
 bin_PROGRAMS = puid
 
 puid_SOURCES = puid.c
-puid_LDADD = $(top_builddir)/lib/libtunepimp.la 
+puid_LDADD = $(top_builddir)/lib/libtunepimp.la -lmusicbrainz
--- origsrc/libtunepimp-0.5.3/lib/Makefile.am	2006-11-28 14:34:02.000000000 -0600
+++ src/libtunepimp-0.5.3/lib/Makefile.am	2008-06-16 01:08:07.312500000 -0500
@@ -24,7 +24,7 @@
 
 SUBDIRS = utf8 threads
 
-INCLUDES = -I$(top_srcdir)/include/tunepimp-0.5 -Ithreads/posix
+INCLUDES = -I$(top_srcdir)/include/tunepimp-0.5 -I$(srcdir)/threads/posix
 lib_LTLIBRARIES = libtunepimp.la
 
 libtunepimp_la_SOURCES = tunepimp.cpp filecache.cpp analyzer.cpp dirsearch.cpp metadata.cpp astrcmp.c track.cpp write.cpp c_wrapper.cpp watchdog.cpp plugins.cpp readmeta.cpp fileio.cpp protocol.cpp
@@ -56,7 +56,7 @@
 #  4:0:0 - TunePimp implementation for alpha releases of version 0.5.0
 #  5:0:0 - TunePimp implementation for version 0.5.0
 #  5:1:0 - TunePimp implementation for version 0.5.1
-libtunepimp_la_LDFLAGS = -version-info 5:3:0
+libtunepimp_la_LDFLAGS = -version-info 5:3:0 -no-undefined
 libtunepimp_la_LIBADD = threads/posix/libtpthread.la utf8/libutf8.la $(LIBLTDL) -lm
 
 noinst_LTLIBRARIES = libpluginsupport.la
--- origsrc/libtunepimp-0.5.3/libltdl/Makefile.am	2006-06-19 13:36:49.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/Makefile.am	2008-06-16 01:19:54.046875000 -0500
@@ -1,32 +1,164 @@
-## Process this file with automake to produce Makefile.in
+## Makefile.am -- Process this file with automake to produce Makefile.in
+##
+##   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
+##   Written by Gary V. Vaughan, 2003
+##
+##   NOTE: The canonical source of this file is maintained with the
+##   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+##
+## GNU Libltdl is free software; you can redistribute it and/or
+## modify it under the terms of the GNU Lesser General Public
+## License as published by the Free Software Foundation; either
+## version 2 of the License, or (at your option) any later version.
+##
+## As a special exception to the GNU Lesser General Public License,
+## if you distribute this file as part of a program or library that
+## is built using GNU libtool, you may include this file under the
+## same distribution terms that you use for the rest of that program.
+##
+## GNU Libltdl is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU Lesser General Public License for more details.
+##
+## You should have received a copy of the GNU LesserGeneral Public
+## License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+## copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+## or obtained by writing to the Free Software Foundation, Inc.,
+## 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#####
+
+ACLOCAL_AMFLAGS = -I m4
+AUTOMAKE_OPTIONS = foreign
+AM_CPPFLAGS =
+AM_LDFLAGS =
+BUILT_SOURCES =
+include_HEADERS =
+noinst_LTLIBRARIES =
+lib_LTLIBRARIES =
+EXTRA_LTLIBRARIES =
+EXTRA_DIST =
+CLEANFILES =
+MOSTLYCLEANFILES =
+
+# -I$(srcdir) is needed for user that built libltdl with a sub-Automake
+# (not as a sub-package!) using 'nostdinc':
+AM_CPPFLAGS	       += -DLT_CONFIG_H='<$(LT_CONFIG_H)>' \
+			  -DLTDL -I. -I$(srcdir) -Ilibltdl \
+			  -I$(srcdir)/libltdl -I$(srcdir)/libltdl
+AM_LDFLAGS	       += -no-undefined
+LTDL_VERSION_INFO	= -version-info 8:1:1
 
-AUTOMAKE_OPTIONS = no-dependencies foreign
+noinst_LTLIBRARIES	+= $(LT_DLLOADERS)
 
 if INSTALL_LTDL
-include_HEADERS = ltdl.h
-lib_LTLIBRARIES = libltdl.la
-else
-noinst_HEADERS = ltdl.h
+ltdlincludedir		= $(includedir)/libltdl
+ltdlinclude_HEADERS	= libltdl/lt_system.h \
+			  libltdl/lt_error.h \
+			  libltdl/lt_dlloader.h
+include_HEADERS	       += ltdl.h
+lib_LTLIBRARIES	       += libltdl.la
 endif
 
 if CONVENIENCE_LTDL
-noinst_LTLIBRARIES = libltdlc.la
+noinst_LTLIBRARIES     += libltdlc.la
 endif
 
-## Make sure these will be cleaned even when they're not built by
-## default.
-CLEANFILES = libltdl.la libltdlc.la
-
-libltdl_la_SOURCES = ltdl.c
-libltdl_la_LDFLAGS = -no-undefined -version-info 4:4:1
-libltdl_la_LIBADD = $(LIBADD_DL)
-
-libltdlc_la_SOURCES = ltdl.c
-libltdlc_la_LIBADD = $(LIBADD_DL)
-
-## Because we do not have automatic dependency tracking:
-ltdl.lo: ltdl.h config.h
-
-$(libltdl_la_OBJECTS) $(libltdlc_la_OBJECTS): libtool
-libtool: $(LIBTOOL_DEPS)
-	$(SHELL) ./config.status --recheck
+libltdl_la_SOURCES = libltdl/lt__alloc.h \
+			  libltdl/lt__dirent.h \
+			  libltdl/lt__glibc.h \
+			  libltdl/lt__private.h \
+			  libltdl/lt__strl.h \
+			  libltdl/lt_dlloader.h \
+			  libltdl/lt_error.h \
+	                  libltdl/lt_system.h \
+			  libltdl/slist.h \
+			  loaders/preopen.c \
+			  lt__alloc.c \
+			  lt_dlloader.c \
+			  lt_error.c \
+			  ltdl.c \
+			  ltdl.h \
+			  slist.c
+
+EXTRA_DIST	       += lt__dirent.c \
+			  lt__strl.c
+
+libltdl_la_CPPFLAGS	= -DLTDLOPEN=$(LTDLOPEN) $(AM_CPPFLAGS)
+libltdl_la_LDFLAGS	= $(AM_LDFLAGS) $(LTDL_VERSION_INFO) $(LT_DLPREOPEN)
+libltdl_la_LIBADD	= $(LTLIBOBJS)
+libltdl_la_DEPENDENCIES	= $(LT_DLLOADERS) $(LTLIBOBJS)
+
+libltdlc_la_SOURCES	= $(libltdl_la_SOURCES)
+libltdlc_la_CPPFLAGS	= -DLTDLOPEN=$(LTDLOPEN)c $(AM_CPPFLAGS)
+libltdlc_la_LDFLAGS	= $(AM_LDFLAGS) $(LT_DLPREOPEN)
+libltdlc_la_LIBADD	= $(libltdl_la_LIBADD)
+libltdlc_la_DEPENDENCIES= $(libltdl_la_DEPENDENCIES)
+
+## The loaders are preopened by libltdl, itself always built from
+## pic-objects (either as a shared library, or a convenience library),
+## so the loaders themselves must be made from pic-objects too.  We
+## use convenience libraries for that purpose:
+EXTRA_LTLIBRARIES	       += dlopen.la \
+				  dld_link.la \
+				  dyld.la \
+				  load_add_on.la \
+				  loadlibrary.la \
+				  shl_load.la
+
+dlopen_la_SOURCES	= loaders/dlopen.c
+dlopen_la_LDFLAGS	= -module -avoid-version
+dlopen_la_LIBADD 	= $(LIBADD_DLOPEN)
+
+dld_link_la_SOURCES	= loaders/dld_link.c
+dld_link_la_LDFLAGS	= -module -avoid-version
+dld_link_la_LIBADD	= -ldld
+
+dyld_la_SOURCES		= loaders/dyld.c
+dyld_la_LDFLAGS		= -module -avoid-version
+
+load_add_on_la_SOURCES	= loaders/load_add_on.c
+load_add_on_la_LDFLAGS	= -module -avoid-version
+
+loadlibrary_la_SOURCES	= loaders/loadlibrary.c
+loadlibrary_la_LDFLAGS	= -module -avoid-version
+
+shl_load_la_SOURCES	= loaders/shl_load.c
+shl_load_la_LDFLAGS	= -module -avoid-version
+shl_load_la_LIBADD	= $(LIBADD_SHL_LOAD)
+
+## Make sure these will be cleaned even when they're not built by default:
+CLEANFILES		       += libltdl.la \
+				  libltdlc.la \
+				  libdlloader.la
+
+## Automake-1.9.6 doesn't clean subdir AC_LIBOBJ compiled objects
+## automatically:
+CLEANFILES	       += $(LIBOBJS) $(LTLIBOBJS)
+
+EXTRA_DIST	       += COPYING.LIB \
+			  configure.ac \
+			  Makefile.am \
+			  aclocal.m4 \
+			  Makefile.in \
+			  configure \
+			  config-h.in \
+			  README
+
+## --------------------------- ##
+## Gnulib Makefile.am snippets ##
+## --------------------------- ##
+
+BUILT_SOURCES	+= $(ARGZ_H)
+EXTRA_DIST	+= argz_.h \
+		   argz.c
+
+# We need the following in order to create an <argz.h> when the system
+# doesn't have one that works with the given compiler.
+all-local $(lib_OBJECTS): $(ARGZ_H)
+argz.h: argz_.h
+	$(mkinstalldirs) . 
+	cp $(srcdir)/argz_.h $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += argz.h \
+		    argz.h-t
--- origsrc/libtunepimp-0.5.3/libltdl/README	2006-06-19 13:36:48.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/README	2008-06-16 01:19:53.671875000 -0500
@@ -8,3 +8,30 @@
 * GNU DLD (emulates dynamic linking for static libraries)
 * dyld (darwin/Mac OS X)
 * libtool's dlpreopen
+-- 
+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   This file is part of GNU Libtool.
+
+GNU Libtool is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License, or (at your option) any later version.
+
+As a special exception to the GNU General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libtool is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Libtool; see the file COPYING.  If not, a copy
+can be downloaded from  http://www.gnu.org/licenses/gpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
--- origsrc/libtunepimp-0.5.3/libltdl/argz.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/argz.c	2008-06-16 01:19:56.546875000 -0500
@@ -0,0 +1,254 @@
+/* argz.c -- argz implementation for non-glibc systems
+
+   Copyright (C) 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if defined(LTDL) && defined LT_CONFIG_H
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <argz.h>
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <string.h>
+
+#define EOS_CHAR '\0'
+
+error_t
+argz_append (char **pargz, size_t *pargz_len, const char *buf, size_t buf_len)
+{
+  size_t argz_len;
+  char  *argz;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert ((*pargz && *pargz_len) || (!*pargz && !*pargz_len));
+
+  /* If nothing needs to be appended, no more work is required.  */
+  if (buf_len == 0)
+    return 0;
+
+  /* Ensure there is enough room to append BUF_LEN.  */
+  argz_len = *pargz_len + buf_len;
+  argz = (char *) realloc (*pargz, argz_len);
+  if (!argz)
+    return ENOMEM;
+
+  /* Copy characters from BUF after terminating '\0' in ARGZ.  */
+  memcpy (argz + *pargz_len, buf, buf_len);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+
+
+/* Add a string to the argz vector.  */
+error_t
+argz_add (char **pargz, size_t *pargz_len, const char *str)
+{
+  return argz_append (pargz, pargz_len, str, strlen (str) + 1);
+}
+
+
+error_t
+argz_create_sep (const char *str, int delim, char **pargz, size_t *pargz_len)
+{
+  size_t argz_len;
+  char *argz = 0;
+
+  assert (str);
+  assert (pargz);
+  assert (pargz_len);
+
+  /* Make a copy of STR, but replacing each occurrence of
+     DELIM with '\0'.  */
+  argz_len = 1+ strlen (str);
+  if (argz_len)
+    {
+      const char *p;
+      char *q;
+
+      argz = (char *) malloc (argz_len);
+      if (!argz)
+	return ENOMEM;
+
+      for (p = str, q = argz; *p != EOS_CHAR; ++p)
+	{
+	  if (*p == delim)
+	    {
+	      /* Ignore leading delimiters, and fold consecutive
+		 delimiters in STR into a single '\0' in ARGZ.  */
+	      if ((q > argz) && (q[-1] != EOS_CHAR))
+		*q++ = EOS_CHAR;
+	      else
+		--argz_len;
+	    }
+	  else
+	    *q++ = *p;
+	}
+      /* Copy terminating EOS_CHAR.  */
+      *q = *p;
+    }
+
+  /* If ARGZ_LEN has shrunk to nothing, release ARGZ's memory.  */
+  if (!argz_len)
+    argz = (free (argz), (char *) 0);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+
+
+error_t
+argz_insert (char **pargz, size_t *pargz_len, char *before, const char *entry)
+{
+  assert (pargz);
+  assert (pargz_len);
+  assert (entry && *entry);
+
+  /* No BEFORE address indicates ENTRY should be inserted after the
+     current last element.  */
+  if (!before)
+    return argz_append (pargz, pargz_len, entry, 1+ strlen (entry));
+
+  /* This probably indicates a programmer error, but to preserve
+     semantics, scan back to the start of an entry if BEFORE points
+     into the middle of it.  */
+  while ((before > *pargz) && (before[-1] != EOS_CHAR))
+    --before;
+
+  {
+    size_t entry_len	= 1+ strlen (entry);
+    size_t argz_len	= *pargz_len + entry_len;
+    size_t offset	= before - *pargz;
+    char   *argz	= (char *) realloc (*pargz, argz_len);
+
+    if (!argz)
+      return ENOMEM;
+
+    /* Make BEFORE point to the equivalent offset in ARGZ that it
+       used to have in *PARGZ incase realloc() moved the block.  */
+    before = argz + offset;
+
+    /* Move the ARGZ entries starting at BEFORE up into the new
+       space at the end -- making room to copy ENTRY into the
+       resulting gap.  */
+    memmove (before + entry_len, before, *pargz_len - offset);
+    memcpy  (before, entry, entry_len);
+
+    /* Assign new values.  */
+    *pargz = argz;
+    *pargz_len = argz_len;
+  }
+
+  return 0;
+}
+
+
+char *
+argz_next (char *argz, size_t argz_len, const char *entry)
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (entry)
+    {
+      /* Either ARGZ/ARGZ_LEN is empty, or ENTRY points into an address
+	 within the ARGZ vector.  */
+      assert ((!argz && !argz_len)
+	      || ((argz <= entry) && (entry < (argz + argz_len))));
+
+      /* Move to the char immediately after the terminating
+	 '\0' of ENTRY.  */
+      entry = 1+ strchr (entry, EOS_CHAR);
+
+      /* Return either the new ENTRY, or else NULL if ARGZ is
+	 exhausted.  */
+      return (entry >= argz + argz_len) ? 0 : (char *) entry;
+    }
+  else
+    {
+      /* This should probably be flagged as a programmer error,
+	 since starting an argz_next loop with the iterator set
+	 to ARGZ is safer.  To preserve semantics, handle the NULL
+	 case by returning the start of ARGZ (if any).  */
+      if (argz_len > 0)
+	return argz;
+      else
+	return 0;
+    }
+}
+
+
+void
+argz_stringify (char *argz, size_t argz_len, int sep)
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (sep)
+    {
+      --argz_len;		/* don't stringify the terminating EOS */
+      while (--argz_len > 0)
+	{
+	  if (argz[argz_len] == EOS_CHAR)
+	    argz[argz_len] = sep;
+	}
+    }
+}
+
+
+/* Count number of elements (null bytes) in argz vector.  */
+
+size_t
+argz_count (const char *argz, size_t argz_len)
+{
+  size_t count = 0;
+
+  assert ((argz && argz_len) || (!argz && !argz_len));
+  
+  while (argz_len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len + 1;
+      argz_len -= part_len + 1;
+      count++;
+    }
+  
+  return count;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/argz_.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/argz_.h	2008-06-16 01:19:56.203125000 -0500
@@ -0,0 +1,71 @@
+/* lt__argz.h -- internal argz interface for non-glibc systems
+
+   Copyright (C) 2004, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__ARGZ_H)
+#define LT__ARGZ_H 1
+
+#include <stdlib.h>
+#define __need_error_t
+#include <errno.h>
+#include <sys/types.h>
+
+#if defined(LTDL)
+#  include "lt__glibc.h"
+#  include "lt_system.h"
+#else
+#  define LT_SCOPE
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+LT_SCOPE error_t argz_append	(char **pargz, size_t *pargz_len,
+				 const char *buf, size_t buf_len);
+LT_SCOPE error_t argz_add       (char **pargz, size_t *pargz_len,
+                                 const char *str);
+LT_SCOPE error_t argz_create_sep(const char *str, int delim,
+				 char **pargz, size_t *pargz_len);
+LT_SCOPE error_t argz_insert	(char **pargz, size_t *pargz_len,
+				 char *before, const char *entry);
+LT_SCOPE char *	 argz_next	(char *argz, size_t argz_len,
+				 const char *entry);
+LT_SCOPE void	 argz_stringify	(char *argz, size_t argz_len, int sep);
+LT_SCOPE size_t  argz_count     (const char *argz, size_t argz_len);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#if !defined(LTDL)
+#  undef LT_SCOPE
+#endif
+
+#endif /*!defined(LT__ARGZ_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/config-h.in	2006-06-19 13:36:49.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/config-h.in	2008-06-16 01:19:55.484375000 -0500
@@ -1,8 +1,14 @@
 /* config-h.in.  Generated from configure.ac by autoheader.  */
 
+/* Define to 1 if you have the `argz_add' function. */
+#undef HAVE_ARGZ_ADD
+
 /* Define to 1 if you have the `argz_append' function. */
 #undef HAVE_ARGZ_APPEND
 
+/* Define to 1 if you have the `argz_count' function. */
+#undef HAVE_ARGZ_COUNT
+
 /* Define to 1 if you have the `argz_create_sep' function. */
 #undef HAVE_ARGZ_CREATE_SEP
 
@@ -18,20 +24,10 @@
 /* Define to 1 if you have the `argz_stringify' function. */
 #undef HAVE_ARGZ_STRINGIFY
 
-/* Define to 1 if you have the <assert.h> header file. */
-#undef HAVE_ASSERT_H
-
-/* Define to 1 if you have the `bcopy' function. */
-#undef HAVE_BCOPY
-
 /* Define to 1 if you have the `closedir' function. */
 #undef HAVE_CLOSEDIR
 
-/* Define to 1 if you have the <ctype.h> header file. */
-#undef HAVE_CTYPE_H
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
-   */
+/* Define to 1 if you have the <dirent.h> header file. */
 #undef HAVE_DIRENT_H
 
 /* Define if you have the GNU dld library. */
@@ -52,39 +48,24 @@
 /* Define if you have the _dyld_func_lookup function. */
 #undef HAVE_DYLD
 
-/* Define to 1 if you have the <errno.h> header file. */
-#undef HAVE_ERRNO_H
-
 /* Define to 1 if the system has the type `error_t'. */
 #undef HAVE_ERROR_T
 
-/* Define to 1 if you have the `index' function. */
-#undef HAVE_INDEX
-
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
 /* Define if you have the libdl library or equivalent. */
 #undef HAVE_LIBDL
 
+/* Define if libdlloader will be built on this platform */
+#undef HAVE_LIBDLLOADER
+
 /* Define to 1 if you have the <mach-o/dyld.h> header file. */
 #undef HAVE_MACH_O_DYLD_H
 
-/* Define to 1 if you have the <malloc.h> header file. */
-#undef HAVE_MALLOC_H
-
-/* Define to 1 if you have the `memcpy' function. */
-#undef HAVE_MEMCPY
-
-/* Define to 1 if you have the `memmove' function. */
-#undef HAVE_MEMMOVE
-
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
-#undef HAVE_NDIR_H
-
 /* Define to 1 if you have the `opendir' function. */
 #undef HAVE_OPENDIR
 
@@ -94,47 +75,30 @@
 /* Define to 1 if you have the `readdir' function. */
 #undef HAVE_READDIR
 
-/* Define to 1 if you have the `rindex' function. */
-#undef HAVE_RINDEX
-
 /* Define if you have the shl_load function. */
 #undef HAVE_SHL_LOAD
 
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
-/* Define to 1 if you have the <stdio.h> header file. */
-#undef HAVE_STDIO_H
-
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
-/* Define to 1 if you have the `strchr' function. */
-#undef HAVE_STRCHR
-
-/* Define to 1 if you have the `strcmp' function. */
-#undef HAVE_STRCMP
-
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
-/* Define to 1 if you have the `strrchr' function. */
-#undef HAVE_STRRCHR
+/* Define to 1 if you have the `strlcat' function. */
+#undef HAVE_STRLCAT
 
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_DIR_H
+/* Define to 1 if you have the `strlcpy' function. */
+#undef HAVE_STRLCPY
 
 /* Define to 1 if you have the <sys/dl.h> header file. */
 #undef HAVE_SYS_DL_H
 
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_NDIR_H
-
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
@@ -144,26 +108,35 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* This value is set to 1 to indicate that the system argz facility works */
+#undef HAVE_WORKING_ARGZ
+
 /* Define if the OS needs help to load dependent libraries for dlopen(). */
 #undef LTDL_DLOPEN_DEPLIBS
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
-#undef LTDL_OBJDIR
+/* Define if dlopen(NULL) is able to resolve symbols from the main program. */
+#undef LTDL_DLOPEN_SELF_WORKS
 
-/* Define to the name of the environment variable that determines the dynamic
-   library search path. */
-#undef LTDL_SHLIBPATH_VAR
+/* Define to the system default library search path. */
+#undef LT_DLSEARCH_PATH
 
-/* Define to the extension used for shared libraries, say, ".so". */
-#undef LTDL_SHLIB_EXT
+/* Define to the extension used for runtime loadable modules, say, ".so". */
+#undef LT_MODULE_EXT
 
-/* Define to the system default library search path. */
-#undef LTDL_SYSSEARCHPATH
+/* Define to the name of the environment variable that determines the run-time
+   module search path. */
+#undef LT_MODULE_PATH_VAR
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
 
 /* Define if dlsym() requires a leading underscore in symbol names. */
 #undef NEED_USCORE
 
+/* Name of package */
+#undef PACKAGE
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
@@ -182,14 +155,11 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
+/* Version number of package */
+#undef VERSION
+
+/* Define so that glibc/gnulib argp.h does not typedef error_t. */
+#undef __error_t_defined
 
 /* Define to a type to use for `error_t' if it is not otherwise available. */
 #undef error_t
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#undef inline
-#endif
--- origsrc/libtunepimp-0.5.3/libltdl/configure.ac	2006-06-19 13:36:49.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/configure.ac	2008-06-16 01:19:54.406250000 -0500
@@ -1,75 +1,71 @@
-## Process this file with autoconf to create configure. -*- autoconf -*-
-# Copyright 2001  Free Software Foundation, Inc.
+# Process this file with autoconf to create configure. -*- autoconf -*-
 #
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
+#    Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+#    Written by Gary V. Vaughan, 2004
 #
-# This program is distributed in the hope that it will be useful,
+#    NOTE: The canonical source of this file is maintained with the
+#    GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+#
+# GNU Libltdl is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later version.
+#
+# As a special exception to the GNU Lesser General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libltdl is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# GNU Lesser General Public License for more details.
 #
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-# 02110-1301  USA
-
+# You should have received a copy of the GNU LesserGeneral Public
+# License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+# copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+####
+
+# This configure.ac is not used at all by the libtool bootstrap, but
+# is copied to the ltdl subdirectory if you libtoolize --ltdl your own
+# project.  Adding LT_WITH_LTDL to your project configure.ac will then
+# configure this directory if your user doesn't want to use the installed
+# libltdl.
 
-dnl FIXME: Is this really new enough?
-AC_PREREQ(2.50)
+AC_PREREQ(2.59)dnl We use AS_HELP_STRING
 
 
 ## ------------------------ ##
 ## Autoconf initialisation. ##
 ## ------------------------ ##
-AC_INIT([libltdl], [1.2], [bug-libtool@gnu.org])
+AC_INIT([libltdl], [2.2.2], [bug-libtool@gnu.org])
+AC_CONFIG_HEADERS([config.h:config-h.in])
 AC_CONFIG_SRCDIR([ltdl.c])
-
-
-## ------------------------------- ##
-## Libltdl specific configuration. ##
-## ------------------------------- ##
-
-AC_CONFIG_AUX_DIR([.])
-
-if test -z "$enable_ltdl_install$enable_ltdl_convenience"; then
-  if test -f ${srcdir}/ltmain.sh; then
-    # if libltdl is libtoolized, it is assumed to be stand-alone and
-    # installed unless the command line overrides it (tested above)
-    enable_ltdl_install=yes
-  else
-    AC_MSG_WARN([*** The top-level configure must select either])
-    AC_MSG_WARN([*** [A""C_LIBLTDL_INSTALLABLE] or [A""C_LIBLTDL_CONVENIENCE].])
-    AC_MSG_ERROR([*** Maybe you want to --enable-ltdl-install?])
-  fi
-fi
+AC_CONFIG_AUX_DIR([config])
+AC_CONFIG_MACRO_DIR([m4])
+LT_CONFIG_LTDL_DIR([.]) # I am me!
 
 
 ## ------------------------ ##
 ## Automake Initialisation. ##
 ## ------------------------ ##
-AM_INIT_AUTOMAKE(AC_PACKAGE_TARNAME, AC_PACKAGE_VERSION, -)
-AM_CONFIG_HEADER([config.h:config-h.in])
 
+AM_INIT_AUTOMAKE([gnits])
 
-## ------------------ ##
-## C compiler checks. ##
-## ------------------ ##
-AC_PROG_CC
-AC_C_CONST
-AC_C_INLINE
+
+## ------------------------------- ##
+## Libtool specific configuration. ##
+## ------------------------------- ##
+pkgdatadir='${datadir}'"/${PACKAGE}"
 
 
 ## ----------------------- ##
 ## Libtool initialisation. ##
 ## ----------------------- ##
-AC_LIBTOOL_WIN32_DLL
-AC_PROG_LIBTOOL
-AC_SUBST([LIBTOOL_DEPS])
-
-AC_LIB_LTDL
+LT_INIT([dlopen win32-dll])
+_LTDL_SETUP
 
 
 ## -------- ##
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/COPYING.LIB	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/COPYING.LIB	2008-06-16 01:19:03.968750000 -0500
@@ -0,0 +1,515 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it
+does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+
+Also add information on how to contact you by electronic and paper
+mail.
+
+You should also get your employer (if you work as a programmer) or
+your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/Makefile.am	2008-06-16 01:19:04.796875000 -0500
@@ -0,0 +1,164 @@
+## Makefile.am -- Process this file with automake to produce Makefile.in
+##
+##   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
+##   Written by Gary V. Vaughan, 2003
+##
+##   NOTE: The canonical source of this file is maintained with the
+##   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+##
+## GNU Libltdl is free software; you can redistribute it and/or
+## modify it under the terms of the GNU Lesser General Public
+## License as published by the Free Software Foundation; either
+## version 2 of the License, or (at your option) any later version.
+##
+## As a special exception to the GNU Lesser General Public License,
+## if you distribute this file as part of a program or library that
+## is built using GNU libtool, you may include this file under the
+## same distribution terms that you use for the rest of that program.
+##
+## GNU Libltdl is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU Lesser General Public License for more details.
+##
+## You should have received a copy of the GNU LesserGeneral Public
+## License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+## copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+## or obtained by writing to the Free Software Foundation, Inc.,
+## 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#####
+
+ACLOCAL_AMFLAGS = -I m4
+AUTOMAKE_OPTIONS = foreign
+AM_CPPFLAGS =
+AM_LDFLAGS =
+BUILT_SOURCES =
+include_HEADERS =
+noinst_LTLIBRARIES =
+lib_LTLIBRARIES =
+EXTRA_LTLIBRARIES =
+EXTRA_DIST =
+CLEANFILES =
+MOSTLYCLEANFILES =
+
+# -I$(srcdir) is needed for user that built libltdl with a sub-Automake
+# (not as a sub-package!) using 'nostdinc':
+AM_CPPFLAGS	       += -DLT_CONFIG_H='<$(LT_CONFIG_H)>' \
+			  -DLTDL -I. -I$(srcdir) -Ilibltdl \
+			  -I$(srcdir)/libltdl -I$(srcdir)/libltdl
+AM_LDFLAGS	       += -no-undefined
+LTDL_VERSION_INFO	= -version-info 8:1:1
+
+noinst_LTLIBRARIES	+= $(LT_DLLOADERS)
+
+if INSTALL_LTDL
+ltdlincludedir		= $(includedir)/libltdl
+ltdlinclude_HEADERS	= libltdl/lt_system.h \
+			  libltdl/lt_error.h \
+			  libltdl/lt_dlloader.h
+include_HEADERS	       += ltdl.h
+lib_LTLIBRARIES	       += libltdl.la
+endif
+
+if CONVENIENCE_LTDL
+noinst_LTLIBRARIES     += libltdlc.la
+endif
+
+libltdl_la_SOURCES = libltdl/lt__alloc.h \
+			  libltdl/lt__dirent.h \
+			  libltdl/lt__glibc.h \
+			  libltdl/lt__private.h \
+			  libltdl/lt__strl.h \
+			  libltdl/lt_dlloader.h \
+			  libltdl/lt_error.h \
+	                  libltdl/lt_system.h \
+			  libltdl/slist.h \
+			  loaders/preopen.c \
+			  lt__alloc.c \
+			  lt_dlloader.c \
+			  lt_error.c \
+			  ltdl.c \
+			  ltdl.h \
+			  slist.c
+
+EXTRA_DIST	       += lt__dirent.c \
+			  lt__strl.c
+
+libltdl_la_CPPFLAGS	= -DLTDLOPEN=$(LTDLOPEN) $(AM_CPPFLAGS)
+libltdl_la_LDFLAGS	= $(AM_LDFLAGS) $(LTDL_VERSION_INFO) $(LT_DLPREOPEN)
+libltdl_la_LIBADD	= $(LTLIBOBJS)
+libltdl_la_DEPENDENCIES	= $(LT_DLLOADERS) $(LTLIBOBJS)
+
+libltdlc_la_SOURCES	= $(libltdl_la_SOURCES)
+libltdlc_la_CPPFLAGS	= -DLTDLOPEN=$(LTDLOPEN)c $(AM_CPPFLAGS)
+libltdlc_la_LDFLAGS	= $(AM_LDFLAGS) $(LT_DLPREOPEN)
+libltdlc_la_LIBADD	= $(libltdl_la_LIBADD)
+libltdlc_la_DEPENDENCIES= $(libltdl_la_DEPENDENCIES)
+
+## The loaders are preopened by libltdl, itself always built from
+## pic-objects (either as a shared library, or a convenience library),
+## so the loaders themselves must be made from pic-objects too.  We
+## use convenience libraries for that purpose:
+EXTRA_LTLIBRARIES	       += dlopen.la \
+				  dld_link.la \
+				  dyld.la \
+				  load_add_on.la \
+				  loadlibrary.la \
+				  shl_load.la
+
+dlopen_la_SOURCES	= loaders/dlopen.c
+dlopen_la_LDFLAGS	= -module -avoid-version
+dlopen_la_LIBADD 	= $(LIBADD_DLOPEN)
+
+dld_link_la_SOURCES	= loaders/dld_link.c
+dld_link_la_LDFLAGS	= -module -avoid-version
+dld_link_la_LIBADD	= -ldld
+
+dyld_la_SOURCES		= loaders/dyld.c
+dyld_la_LDFLAGS		= -module -avoid-version
+
+load_add_on_la_SOURCES	= loaders/load_add_on.c
+load_add_on_la_LDFLAGS	= -module -avoid-version
+
+loadlibrary_la_SOURCES	= loaders/loadlibrary.c
+loadlibrary_la_LDFLAGS	= -module -avoid-version
+
+shl_load_la_SOURCES	= loaders/shl_load.c
+shl_load_la_LDFLAGS	= -module -avoid-version
+shl_load_la_LIBADD	= $(LIBADD_SHL_LOAD)
+
+## Make sure these will be cleaned even when they're not built by default:
+CLEANFILES		       += libltdl.la \
+				  libltdlc.la \
+				  libdlloader.la
+
+## Automake-1.9.6 doesn't clean subdir AC_LIBOBJ compiled objects
+## automatically:
+CLEANFILES	       += $(LIBOBJS) $(LTLIBOBJS)
+
+EXTRA_DIST	       += COPYING.LIB \
+			  configure.ac \
+			  Makefile.am \
+			  aclocal.m4 \
+			  Makefile.in \
+			  configure \
+			  config-h.in \
+			  README
+
+## --------------------------- ##
+## Gnulib Makefile.am snippets ##
+## --------------------------- ##
+
+BUILT_SOURCES	+= $(ARGZ_H)
+EXTRA_DIST	+= argz_.h \
+		   argz.c
+
+# We need the following in order to create an <argz.h> when the system
+# doesn't have one that works with the given compiler.
+all-local $(lib_OBJECTS): $(ARGZ_H)
+argz.h: argz_.h
+	$(mkinstalldirs) . 
+	cp $(srcdir)/argz_.h $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += argz.h \
+		    argz.h-t
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/README	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/README	2008-06-16 01:19:04.343750000 -0500
@@ -0,0 +1,37 @@
+This is GNU libltdl, a system independent dlopen wrapper for GNU libtool.
+
+It supports the following dlopen interfaces:
+* dlopen (Solaris, Linux and various BSD flavors)
+* shl_load (HP-UX)
+* LoadLibrary (Win16 and Win32)
+* load_add_on (BeOS)
+* GNU DLD (emulates dynamic linking for static libraries)
+* dyld (darwin/Mac OS X)
+* libtool's dlpreopen
+-- 
+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   This file is part of GNU Libtool.
+
+GNU Libtool is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of
+the License, or (at your option) any later version.
+
+As a special exception to the GNU General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libtool is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Libtool; see the file COPYING.  If not, a copy
+can be downloaded from  http://www.gnu.org/licenses/gpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/argz.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/argz.c	2008-06-16 01:19:07.640625000 -0500
@@ -0,0 +1,254 @@
+/* argz.c -- argz implementation for non-glibc systems
+
+   Copyright (C) 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if defined(LTDL) && defined LT_CONFIG_H
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <argz.h>
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <string.h>
+
+#define EOS_CHAR '\0'
+
+error_t
+argz_append (char **pargz, size_t *pargz_len, const char *buf, size_t buf_len)
+{
+  size_t argz_len;
+  char  *argz;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert ((*pargz && *pargz_len) || (!*pargz && !*pargz_len));
+
+  /* If nothing needs to be appended, no more work is required.  */
+  if (buf_len == 0)
+    return 0;
+
+  /* Ensure there is enough room to append BUF_LEN.  */
+  argz_len = *pargz_len + buf_len;
+  argz = (char *) realloc (*pargz, argz_len);
+  if (!argz)
+    return ENOMEM;
+
+  /* Copy characters from BUF after terminating '\0' in ARGZ.  */
+  memcpy (argz + *pargz_len, buf, buf_len);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+
+
+/* Add a string to the argz vector.  */
+error_t
+argz_add (char **pargz, size_t *pargz_len, const char *str)
+{
+  return argz_append (pargz, pargz_len, str, strlen (str) + 1);
+}
+
+
+error_t
+argz_create_sep (const char *str, int delim, char **pargz, size_t *pargz_len)
+{
+  size_t argz_len;
+  char *argz = 0;
+
+  assert (str);
+  assert (pargz);
+  assert (pargz_len);
+
+  /* Make a copy of STR, but replacing each occurrence of
+     DELIM with '\0'.  */
+  argz_len = 1+ strlen (str);
+  if (argz_len)
+    {
+      const char *p;
+      char *q;
+
+      argz = (char *) malloc (argz_len);
+      if (!argz)
+	return ENOMEM;
+
+      for (p = str, q = argz; *p != EOS_CHAR; ++p)
+	{
+	  if (*p == delim)
+	    {
+	      /* Ignore leading delimiters, and fold consecutive
+		 delimiters in STR into a single '\0' in ARGZ.  */
+	      if ((q > argz) && (q[-1] != EOS_CHAR))
+		*q++ = EOS_CHAR;
+	      else
+		--argz_len;
+	    }
+	  else
+	    *q++ = *p;
+	}
+      /* Copy terminating EOS_CHAR.  */
+      *q = *p;
+    }
+
+  /* If ARGZ_LEN has shrunk to nothing, release ARGZ's memory.  */
+  if (!argz_len)
+    argz = (free (argz), (char *) 0);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+
+
+error_t
+argz_insert (char **pargz, size_t *pargz_len, char *before, const char *entry)
+{
+  assert (pargz);
+  assert (pargz_len);
+  assert (entry && *entry);
+
+  /* No BEFORE address indicates ENTRY should be inserted after the
+     current last element.  */
+  if (!before)
+    return argz_append (pargz, pargz_len, entry, 1+ strlen (entry));
+
+  /* This probably indicates a programmer error, but to preserve
+     semantics, scan back to the start of an entry if BEFORE points
+     into the middle of it.  */
+  while ((before > *pargz) && (before[-1] != EOS_CHAR))
+    --before;
+
+  {
+    size_t entry_len	= 1+ strlen (entry);
+    size_t argz_len	= *pargz_len + entry_len;
+    size_t offset	= before - *pargz;
+    char   *argz	= (char *) realloc (*pargz, argz_len);
+
+    if (!argz)
+      return ENOMEM;
+
+    /* Make BEFORE point to the equivalent offset in ARGZ that it
+       used to have in *PARGZ incase realloc() moved the block.  */
+    before = argz + offset;
+
+    /* Move the ARGZ entries starting at BEFORE up into the new
+       space at the end -- making room to copy ENTRY into the
+       resulting gap.  */
+    memmove (before + entry_len, before, *pargz_len - offset);
+    memcpy  (before, entry, entry_len);
+
+    /* Assign new values.  */
+    *pargz = argz;
+    *pargz_len = argz_len;
+  }
+
+  return 0;
+}
+
+
+char *
+argz_next (char *argz, size_t argz_len, const char *entry)
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (entry)
+    {
+      /* Either ARGZ/ARGZ_LEN is empty, or ENTRY points into an address
+	 within the ARGZ vector.  */
+      assert ((!argz && !argz_len)
+	      || ((argz <= entry) && (entry < (argz + argz_len))));
+
+      /* Move to the char immediately after the terminating
+	 '\0' of ENTRY.  */
+      entry = 1+ strchr (entry, EOS_CHAR);
+
+      /* Return either the new ENTRY, or else NULL if ARGZ is
+	 exhausted.  */
+      return (entry >= argz + argz_len) ? 0 : (char *) entry;
+    }
+  else
+    {
+      /* This should probably be flagged as a programmer error,
+	 since starting an argz_next loop with the iterator set
+	 to ARGZ is safer.  To preserve semantics, handle the NULL
+	 case by returning the start of ARGZ (if any).  */
+      if (argz_len > 0)
+	return argz;
+      else
+	return 0;
+    }
+}
+
+
+void
+argz_stringify (char *argz, size_t argz_len, int sep)
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (sep)
+    {
+      --argz_len;		/* don't stringify the terminating EOS */
+      while (--argz_len > 0)
+	{
+	  if (argz[argz_len] == EOS_CHAR)
+	    argz[argz_len] = sep;
+	}
+    }
+}
+
+
+/* Count number of elements (null bytes) in argz vector.  */
+
+size_t
+argz_count (const char *argz, size_t argz_len)
+{
+  size_t count = 0;
+
+  assert ((argz && argz_len) || (!argz && !argz_len));
+  
+  while (argz_len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len + 1;
+      argz_len -= part_len + 1;
+      count++;
+    }
+  
+  return count;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/argz_.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/argz_.h	2008-06-16 01:19:07.281250000 -0500
@@ -0,0 +1,71 @@
+/* lt__argz.h -- internal argz interface for non-glibc systems
+
+   Copyright (C) 2004, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__ARGZ_H)
+#define LT__ARGZ_H 1
+
+#include <stdlib.h>
+#define __need_error_t
+#include <errno.h>
+#include <sys/types.h>
+
+#if defined(LTDL)
+#  include "lt__glibc.h"
+#  include "lt_system.h"
+#else
+#  define LT_SCOPE
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+LT_SCOPE error_t argz_append	(char **pargz, size_t *pargz_len,
+				 const char *buf, size_t buf_len);
+LT_SCOPE error_t argz_add       (char **pargz, size_t *pargz_len,
+                                 const char *str);
+LT_SCOPE error_t argz_create_sep(const char *str, int delim,
+				 char **pargz, size_t *pargz_len);
+LT_SCOPE error_t argz_insert	(char **pargz, size_t *pargz_len,
+				 char *before, const char *entry);
+LT_SCOPE char *	 argz_next	(char *argz, size_t argz_len,
+				 const char *entry);
+LT_SCOPE void	 argz_stringify	(char *argz, size_t argz_len, int sep);
+LT_SCOPE size_t  argz_count     (const char *argz, size_t argz_len);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#if !defined(LTDL)
+#  undef LT_SCOPE
+#endif
+
+#endif /*!defined(LT__ARGZ_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/config-h.in	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/config-h.in	2008-06-16 01:19:06.437500000 -0500
@@ -0,0 +1,165 @@
+/* config-h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the `argz_add' function. */
+#undef HAVE_ARGZ_ADD
+
+/* Define to 1 if you have the `argz_append' function. */
+#undef HAVE_ARGZ_APPEND
+
+/* Define to 1 if you have the `argz_count' function. */
+#undef HAVE_ARGZ_COUNT
+
+/* Define to 1 if you have the `argz_create_sep' function. */
+#undef HAVE_ARGZ_CREATE_SEP
+
+/* Define to 1 if you have the <argz.h> header file. */
+#undef HAVE_ARGZ_H
+
+/* Define to 1 if you have the `argz_insert' function. */
+#undef HAVE_ARGZ_INSERT
+
+/* Define to 1 if you have the `argz_next' function. */
+#undef HAVE_ARGZ_NEXT
+
+/* Define to 1 if you have the `argz_stringify' function. */
+#undef HAVE_ARGZ_STRINGIFY
+
+/* Define to 1 if you have the `closedir' function. */
+#undef HAVE_CLOSEDIR
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#undef HAVE_DIRENT_H
+
+/* Define if you have the GNU dld library. */
+#undef HAVE_DLD
+
+/* Define to 1 if you have the <dld.h> header file. */
+#undef HAVE_DLD_H
+
+/* Define to 1 if you have the `dlerror' function. */
+#undef HAVE_DLERROR
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <dl.h> header file. */
+#undef HAVE_DL_H
+
+/* Define if you have the _dyld_func_lookup function. */
+#undef HAVE_DYLD
+
+/* Define to 1 if the system has the type `error_t'. */
+#undef HAVE_ERROR_T
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define if you have the libdl library or equivalent. */
+#undef HAVE_LIBDL
+
+/* Define if libdlloader will be built on this platform */
+#undef HAVE_LIBDLLOADER
+
+/* Define to 1 if you have the <mach-o/dyld.h> header file. */
+#undef HAVE_MACH_O_DYLD_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `opendir' function. */
+#undef HAVE_OPENDIR
+
+/* Define if libtool can extract symbol lists from object files. */
+#undef HAVE_PRELOADED_SYMBOLS
+
+/* Define to 1 if you have the `readdir' function. */
+#undef HAVE_READDIR
+
+/* Define if you have the shl_load function. */
+#undef HAVE_SHL_LOAD
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strlcat' function. */
+#undef HAVE_STRLCAT
+
+/* Define to 1 if you have the `strlcpy' function. */
+#undef HAVE_STRLCPY
+
+/* Define to 1 if you have the <sys/dl.h> header file. */
+#undef HAVE_SYS_DL_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* This value is set to 1 to indicate that the system argz facility works */
+#undef HAVE_WORKING_ARGZ
+
+/* Define if the OS needs help to load dependent libraries for dlopen(). */
+#undef LTDL_DLOPEN_DEPLIBS
+
+/* Define if dlopen(NULL) is able to resolve symbols from the main program. */
+#undef LTDL_DLOPEN_SELF_WORKS
+
+/* Define to the system default library search path. */
+#undef LT_DLSEARCH_PATH
+
+/* Define to the extension used for runtime loadable modules, say, ".so". */
+#undef LT_MODULE_EXT
+
+/* Define to the name of the environment variable that determines the run-time
+   module search path. */
+#undef LT_MODULE_PATH_VAR
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define if dlsym() requires a leading underscore in symbol names. */
+#undef NEED_USCORE
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define so that glibc/gnulib argp.h does not typedef error_t. */
+#undef __error_t_defined
+
+/* Define to a type to use for `error_t' if it is not otherwise available. */
+#undef error_t
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/configure.ac	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/configure.ac	2008-06-16 01:19:05.203125000 -0500
@@ -0,0 +1,75 @@
+# Process this file with autoconf to create configure. -*- autoconf -*-
+#
+#    Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+#    Written by Gary V. Vaughan, 2004
+#
+#    NOTE: The canonical source of this file is maintained with the
+#    GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+#
+# GNU Libltdl is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later version.
+#
+# As a special exception to the GNU Lesser General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libltdl is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU LesserGeneral Public
+# License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+# copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+####
+
+# This configure.ac is not used at all by the libtool bootstrap, but
+# is copied to the ltdl subdirectory if you libtoolize --ltdl your own
+# project.  Adding LT_WITH_LTDL to your project configure.ac will then
+# configure this directory if your user doesn't want to use the installed
+# libltdl.
+
+AC_PREREQ(2.59)dnl We use AS_HELP_STRING
+
+
+## ------------------------ ##
+## Autoconf initialisation. ##
+## ------------------------ ##
+AC_INIT([libltdl], [2.2.2], [bug-libtool@gnu.org])
+AC_CONFIG_HEADERS([config.h:config-h.in])
+AC_CONFIG_SRCDIR([ltdl.c])
+AC_CONFIG_AUX_DIR([config])
+AC_CONFIG_MACRO_DIR([m4])
+LT_CONFIG_LTDL_DIR([.]) # I am me!
+
+
+## ------------------------ ##
+## Automake Initialisation. ##
+## ------------------------ ##
+
+AM_INIT_AUTOMAKE([gnits])
+
+
+## ------------------------------- ##
+## Libtool specific configuration. ##
+## ------------------------------- ##
+pkgdatadir='${datadir}'"/${PACKAGE}"
+
+
+## ----------------------- ##
+## Libtool initialisation. ##
+## ----------------------- ##
+LT_INIT([dlopen win32-dll])
+_LTDL_SETUP
+
+
+## -------- ##
+## Outputs. ##
+## -------- ##
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__alloc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__alloc.h	2008-06-16 01:19:11.609375000 -0500
@@ -0,0 +1,58 @@
+/* lt__alloc.h -- internal memory management interface
+
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__ALLOC_H)
+#define LT__ALLOC_H 1
+
+#include "lt_system.h"
+
+LT_BEGIN_C_DECLS
+
+#define MALLOC(tp, n)		(tp*) lt__malloc((n) * sizeof(tp))
+#define REALLOC(tp, mem, n)	(tp*) lt__realloc((mem), (n) * sizeof(tp))
+#define FREE(mem)					LT_STMT_START {	\
+	if (mem) { free ((void *)mem); mem = NULL; }	} LT_STMT_END
+#define MEMREASSIGN(p, q)				LT_STMT_START {	\
+	if ((p) != (q)) { if (p) free (p); (p) = (q); (q) = 0; }	\
+								} LT_STMT_END
+
+/* If set, this function is called when memory allocation has failed.  */
+LT_SCOPE void (*lt__alloc_die) (void);
+
+LT_SCOPE void *lt__malloc (size_t n);
+LT_SCOPE void *lt__zalloc (size_t n);
+LT_SCOPE void *lt__realloc (void *mem, size_t n);
+LT_SCOPE void *lt__memdup (void const *mem, size_t n);
+
+LT_SCOPE char *lt__strdup (const char *string);
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT__ALLOC_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__dirent.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__dirent.h	2008-06-16 01:19:12.031250000 -0500
@@ -0,0 +1,87 @@
+/* lt__dirent.h -- internal directory entry scanning interface
+
+   Copyright (C) 2001, 2004, 2006 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2001
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__DIRENT_H)
+#define LT__DIRENT_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include "lt_system.h"
+
+#ifdef HAVE_DIRENT_H
+/* We have a fully operational dirent subsystem.  */
+#  include <dirent.h>
+#  define D_NAMLEN(dirent) (strlen((dirent)->d_name))
+
+#elif defined __WINDOWS__
+/* Use some wrapper code to emulate dirent on windows..  */
+#  define WINDOWS_DIRENT_EMULATION 1
+
+#  include <windows.h>
+
+#  define D_NAMLEN(dirent)	(strlen((dirent)->d_name))
+#  define dirent		lt__dirent
+#  define DIR			lt__DIR
+#  define opendir		lt__opendir
+#  define readdir		lt__readdir
+#  define closedir		lt__closedir
+
+LT_BEGIN_C_DECLS
+
+struct dirent
+{
+  char d_name[LT_FILENAME_MAX];
+  int  d_namlen;
+};
+
+typedef struct
+{
+  HANDLE hSearch;
+  WIN32_FIND_DATA Win32FindData;
+  BOOL firsttime;
+  struct dirent file_info;
+} DIR;
+
+
+LT_SCOPE DIR *		opendir		(const char *path);
+LT_SCOPE struct dirent *readdir		(DIR *entry);
+LT_SCOPE void		closedir	(DIR *entry);
+
+LT_END_C_DECLS
+
+#else /* !defined(__WINDOWS__)*/
+ERROR - cannot find dirent
+#endif /*!defined(__WINDOWS__)*/
+
+#endif /*!defined(LT__DIRENT_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__glibc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__glibc.h	2008-06-16 01:19:12.531250000 -0500
@@ -0,0 +1,83 @@
+/* lt__glibc.h -- support for non glibc environments
+
+   Copyright (C) 2004, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__GLIBC_H)
+#define LT__GLIBC_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#if !defined(HAVE_ARGZ_H) || !defined(HAVE_WORKING_ARGZ)
+/* Redefine any glibc symbols we reimplement to import the
+   implementations into our lt__ namespace so we don't ever
+   clash with the system library if our clients use argz_*
+   from there in addition to libltdl.  */
+#  undef  argz_append
+#  define argz_append		lt__argz_append
+#  undef  argz_create_sep
+#  define argz_create_sep	lt__argz_create_sep
+#  undef  argz_insert
+#  define argz_insert		lt__argz_insert
+#  undef  argz_next
+#  define argz_next		lt__argz_next
+#  undef  argz_stringify
+#  define argz_stringify	lt__argz_stringify
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <argz.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+# define slist_concat	lt__slist_concat
+# define slist_cons	lt__slist_cons
+# define slist_delete	lt__slist_delete
+# define slist_remove	lt__slist_remove
+# define slist_reverse	lt__slist_reverse
+# define slist_sort	lt__slist_sort
+# define slist_tail	lt__slist_tail
+# define slist_nth	lt__slist_nth
+# define slist_find	lt__slist_find
+# define slist_length	lt__slist_length
+# define slist_foreach	lt__slist_foreach
+# define slist_box	lt__slist_box
+# define slist_unbox	lt__slist_unbox
+
+#include <slist.h>
+
+#endif /*!defined(LT__GLIBC_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__private.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__private.h	2008-06-16 01:19:12.953125000 -0500
@@ -0,0 +1,152 @@
+/* lt__private.h -- internal apis for libltdl
+
+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy con be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__PRIVATE_H)
+#define LT__PRIVATE_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#if defined(HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+/* Import internal interfaces...  */
+#include "lt__alloc.h"
+#include "lt__dirent.h"
+#include "lt__strl.h"
+#include "lt__glibc.h"
+
+/* ...and all exported interfaces.  */
+#include "ltdl.h"
+
+#if defined(WITH_DMALLOC)
+#  include <dmalloc.h>
+#endif
+
+/* DLL building support on win32 hosts;  mostly to workaround their
+   ridiculous implementation of data symbol exporting. */
+#ifndef LT_GLOBAL_DATA
+# if defined(__WINDOWS__) || defined(__CYGWIN__)
+#  if defined(DLL_EXPORT)	/* defined by libtool (if required) */
+#   define LT_GLOBAL_DATA	__declspec(dllexport)
+#  endif
+# endif
+# ifndef LT_GLOBAL_DATA
+#  define LT_GLOBAL_DATA	/* static linking or !__WINDOWS__ */
+# endif
+#endif
+
+#ifndef __attribute__
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8) || __STRICT_ANSI__
+#  define __attribute__(x)
+# endif
+#endif
+
+#ifndef LT__UNUSED
+# define LT__UNUSED __attribute__ ((__unused__))
+#endif
+
+
+LT_BEGIN_C_DECLS
+
+#if !defined(errno)
+extern int errno;
+#endif
+
+LT_SCOPE void	lt__alloc_die_callback (void);
+
+
+/* For readability:  */
+#define strneq(s1, s2)	(strcmp((s1), (s2)) != 0)
+#define streq(s1, s2)	(!strcmp((s1), (s2)))
+
+
+
+/* --- OPAQUE STRUCTURES DECLARED IN LTDL.H --- */
+
+/* This type is used for the array of interface data sets in each handler. */
+typedef struct {
+  lt_dlinterface_id	key;
+  void *		data;
+} lt_interface_data;
+
+typedef struct lt__handle lt__handle;
+
+struct lt__handle {
+  lt__handle *		next;
+  const lt_dlvtable *	vtable;		/* dlopening interface */
+  lt_dlinfo		info;		/* user visible fields */
+  int			depcount;	/* number of dependencies */
+  lt_dlhandle *		deplibs;	/* dependencies */
+  lt_module		module;		/* system module handle */
+  void *		system;		/* system specific data */
+  lt_interface_data *	interface_data;	/* per caller associated data */
+  int			flags;		/* various boolean stats */
+};
+
+typedef struct lt__advise lt__advise;
+
+struct lt__advise {
+  unsigned int	try_ext:1;	/* try system library extensions.  */
+  unsigned int	is_resident:1;	/* module can't be unloaded. */
+  unsigned int	is_symglobal:1;	/* module symbols can satisfy
+				   subsequently loaded modules.  */
+  unsigned int	is_symlocal:1;	/* module symbols are only available
+				   locally. */
+};
+
+/* --- ERROR HANDLING --- */
+
+/* Extract the diagnostic strings from the error table macro in the same
+   order as the enumerated indices in lt_error.h. */
+
+#define LT__STRERROR(name)	lt__error_string(LT_CONC(LT_ERROR_,name))
+
+#define LT__GETERROR(lvalue)	      (lvalue) = lt__get_last_error()
+#define LT__SETERRORSTR(errormsg)     lt__set_last_error(errormsg)
+#define LT__SETERROR(errorcode)	      LT__SETERRORSTR(LT__STRERROR(errorcode))
+
+LT_SCOPE const char *lt__error_string	(int errorcode);
+LT_SCOPE const char *lt__get_last_error	(void);
+LT_SCOPE const char *lt__set_last_error	(const char *errormsg);
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT__PRIVATE_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__strl.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt__strl.h	2008-06-16 01:19:13.328125000 -0500
@@ -0,0 +1,53 @@
+/* lt__strl.h -- size-bounded string copying and concatenation
+
+   Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT__STRL_H)
+#define LT__STRL_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <string.h>
+#include "lt_system.h"
+
+#if !defined(HAVE_STRLCAT)
+#  define strlcat(dst,src,dstsize) lt_strlcat(dst,src,dstsize)
+LT_SCOPE size_t lt_strlcat(char *dst, const char *src, const size_t dstsize);
+#endif /* !defined(HAVE_STRLCAT) */
+
+#if !defined(HAVE_STRLCPY)
+#  define strlcpy(dst,src,dstsize) lt_strlcpy(dst,src,dstsize)
+LT_SCOPE size_t lt_strlcpy(char *dst, const char *src, const size_t dstsize);
+#endif /* !defined(HAVE_STRLCPY) */
+
+#endif /*!defined(LT__STRL_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_dlloader.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_dlloader.h	2008-06-16 01:19:13.671875000 -0500
@@ -0,0 +1,90 @@
+/* lt_dlloader.h -- dynamic library loader interface
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT_DLLOADER_H)
+#define LT_DLLOADER_H 1
+
+#include <libltdl/lt_system.h>
+
+LT_BEGIN_C_DECLS
+
+typedef	void *	lt_dlloader;
+typedef void *	lt_module;
+typedef void *	lt_user_data;
+typedef void *	lt_dladvise;
+
+/* Function pointer types for module loader vtable entries:  */
+typedef lt_module   lt_module_open	(lt_user_data data,
+					 const char *filename,
+					 lt_dladvise advise);
+typedef int	    lt_module_close	(lt_user_data data,
+					 lt_module module);
+typedef void *	    lt_find_sym		(lt_user_data data, lt_module module,
+					 const char *symbolname);
+typedef int	    lt_dlloader_init	(lt_user_data data);
+typedef int	    lt_dlloader_exit	(lt_user_data data);
+
+/* Default priority is LT_DLLOADER_PREPEND if none is explicitly given.  */
+typedef enum {
+  LT_DLLOADER_PREPEND = 0, LT_DLLOADER_APPEND
+} lt_dlloader_priority;
+
+/* This structure defines a module loader, as populated by the get_vtable
+   entry point of each loader.  */
+typedef struct {
+  const char *		name;
+  const char *		sym_prefix;
+  lt_module_open *	module_open;
+  lt_module_close *	module_close;
+  lt_find_sym *		find_sym;
+  lt_dlloader_init *	dlloader_init;
+  lt_dlloader_exit *	dlloader_exit;
+  lt_user_data		dlloader_data;
+  lt_dlloader_priority	priority;
+} lt_dlvtable;
+
+LT_SCOPE int		lt_dlloader_add	   (const lt_dlvtable *vtable);
+LT_SCOPE lt_dlloader	lt_dlloader_next   (const lt_dlloader loader);
+
+LT_SCOPE lt_dlvtable *	lt_dlloader_remove	(char *name);
+LT_SCOPE const lt_dlvtable *lt_dlloader_find	(char *name);
+LT_SCOPE const lt_dlvtable *lt_dlloader_get	(lt_dlloader loader);
+
+
+/* Type of a function to get a loader's vtable:  */
+typedef  const lt_dlvtable *lt_get_vtable	(lt_user_data data);
+
+#ifdef LT_DEBUG_LOADERS
+LT_SCOPE void		lt_dlloader_dump	(void);
+#endif
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT_DLLOADER_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_error.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_error.h	2008-06-16 01:19:14.062500000 -0500
@@ -0,0 +1,85 @@
+/* lt_error.h -- error propogation interface
+
+   Copyright (C) 1999, 2000, 2001, 2004, 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+/* Only include this header file once. */
+#if !defined(LT_ERROR_H)
+#define LT_ERROR_H 1
+
+#include <libltdl/lt_system.h>
+
+LT_BEGIN_C_DECLS
+
+/* Defining error strings alongside their symbolic names in a macro in
+   this way allows us to expand the macro in different contexts with
+   confidence that the enumeration of symbolic names will map correctly
+   onto the table of error strings.  \0 is appended to the strings to
+   expilicitely initialize the string terminator. */
+#define lt_dlerror_table						\
+    LT_ERROR(UNKNOWN,		    "unknown error\0")			\
+    LT_ERROR(DLOPEN_NOT_SUPPORTED,  "dlopen support not available\0")	\
+    LT_ERROR(INVALID_LOADER,	    "invalid loader\0")			\
+    LT_ERROR(INIT_LOADER,	    "loader initialization failed\0")	\
+    LT_ERROR(REMOVE_LOADER,	    "loader removal failed\0")		\
+    LT_ERROR(FILE_NOT_FOUND,	    "file not found\0")			\
+    LT_ERROR(DEPLIB_NOT_FOUND,	    "dependency library not found\0")	\
+    LT_ERROR(NO_SYMBOLS,	    "no symbols defined\0")		\
+    LT_ERROR(CANNOT_OPEN,	    "can't open the module\0")		\
+    LT_ERROR(CANNOT_CLOSE,	    "can't close the module\0")		\
+    LT_ERROR(SYMBOL_NOT_FOUND,	    "symbol not found\0")		\
+    LT_ERROR(NO_MEMORY,		    "not enough memory\0")		\
+    LT_ERROR(INVALID_HANDLE,	    "invalid module handle\0")		\
+    LT_ERROR(BUFFER_OVERFLOW,	    "internal buffer overflow\0")	\
+    LT_ERROR(INVALID_ERRORCODE,	    "invalid errorcode\0")		\
+    LT_ERROR(SHUTDOWN,		    "library already shutdown\0")	\
+    LT_ERROR(CLOSE_RESIDENT_MODULE, "can't close resident module\0")	\
+    LT_ERROR(INVALID_MUTEX_ARGS,    "internal error (code withdrawn)\0")\
+    LT_ERROR(INVALID_POSITION,	    "invalid search path insert position\0")\
+    LT_ERROR(CONFLICTING_FLAGS,	    "symbol visibility can be global or local\0")
+
+/* Enumerate the symbolic error names. */
+enum {
+#define LT_ERROR(name, diagnostic)	LT_CONC(LT_ERROR_, name),
+	lt_dlerror_table
+#undef LT_ERROR
+
+	LT_ERROR_MAX
+};
+
+/* Should be max of the error string lengths above (plus one for C++) */
+#define LT_ERROR_LEN_MAX (41)
+
+/* These functions are only useful from inside custom module loaders. */
+LT_SCOPE int	lt_dladderror	(const char *diagnostic);
+LT_SCOPE int	lt_dlseterror	(int errorcode);
+
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT_ERROR_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_system.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/lt_system.h	2008-06-16 01:19:14.468750000 -0500
@@ -0,0 +1,154 @@
+/* lt_system.h -- system portability abstraction layer
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT_SYSTEM_H)
+#define LT_SYSTEM_H 1
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/types.h>
+
+/* Some systems do not define EXIT_*, even with STDC_HEADERS.  */
+#if !defined(EXIT_SUCCESS)
+# define EXIT_SUCCESS 0
+#endif
+#if !defined(EXIT_FAILURE)
+# define EXIT_FAILURE 1
+#endif
+
+/* Just pick a big number... */
+#define LT_FILENAME_MAX 2048
+
+
+/* Saves on those hard to debug '\0' typos....  */
+#define LT_EOS_CHAR	'\0'
+
+/* LTDL_BEGIN_C_DECLS should be used at the beginning of your declarations,
+   so that C++ compilers don't mangle their names.  Use LTDL_END_C_DECLS at
+   the end of C declarations. */
+#if defined(__cplusplus)
+# define LT_BEGIN_C_DECLS	extern "C" {
+# define LT_END_C_DECLS		}
+#else
+# define LT_BEGIN_C_DECLS	/* empty */
+# define LT_END_C_DECLS		/* empty */
+#endif
+
+/* LT_STMT_START/END are used to create macros which expand to a
+   a single compound statement in a portable way.  */
+#if defined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)
+#  define LT_STMT_START        (void)(
+#  define LT_STMT_END          )
+#else
+#  if (defined (sun) || defined (__sun__))
+#    define LT_STMT_START      if (1)
+#    define LT_STMT_END        else (void)0
+#  else
+#    define LT_STMT_START      do
+#    define LT_STMT_END        while (0)
+#  endif
+#endif
+
+/* Canonicalise Windows and Cygwin recognition macros.
+   To match the values set by recent Cygwin compilers, make sure that if
+   __CYGWIN__ is defined (after canonicalisation), __WINDOWS__ is NOT!  */
+#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
+# define __CYGWIN__ __CYGWIN32__
+#endif
+#if defined(__CYGWIN__)
+# if defined(__WINDOWS__)
+#   undef __WINDOWS__
+# endif
+#elif defined(_WIN32)
+# define __WINDOWS__ _WIN32
+#elif defined(WIN32)
+# define __WINDOWS__ WIN32
+#endif
+#if defined(__CYGWIN__) && defined(__WINDOWS__)
+# undef __WINDOWS__
+#endif
+
+
+/* DLL building support on win32 hosts;  mostly to workaround their
+   ridiculous implementation of data symbol exporting. */
+#if !defined(LT_SCOPE)
+#  if defined(__WINDOWS__) || defined(__CYGWIN__)
+#    if defined(DLL_EXPORT)		/* defined by libtool (if required) */
+#      define LT_SCOPE	extern __declspec(dllexport)
+#    endif
+#    if defined(LIBLTDL_DLL_IMPORT)	/* define if linking with this dll */
+       /* note: cygwin/mingw compilers can rely instead on auto-import */
+#      define LT_SCOPE	extern __declspec(dllimport)
+#    endif
+#  endif
+#  if !defined(LT_SCOPE)		/* static linking or !__WINDOWS__ */
+#    define LT_SCOPE	extern
+#  endif
+#endif
+
+#if defined(__WINDOWS__)
+/* LT_DIRSEP_CHAR is accepted *in addition* to '/' as a directory
+   separator when it is set. */
+# define LT_DIRSEP_CHAR		'\\'
+# define LT_PATHSEP_CHAR	';'
+#else
+# define LT_PATHSEP_CHAR	':'
+#endif
+
+#if defined(_MSC_VER) /* Visual Studio */
+#  define R_OK 4
+#endif
+
+/* fopen() mode flags for reading a text file */
+#undef	LT_READTEXT_MODE
+#if defined(__WINDOWS__) || defined(__CYGWIN__)
+#  define LT_READTEXT_MODE "rt"
+#else
+#  define LT_READTEXT_MODE "r"
+#endif
+
+/* The extra indirection to the LT__STR and LT__CONC macros is required so
+   that if the arguments to LT_STR() (or LT_CONC()) are themselves macros,
+   they will be expanded before being quoted.   */
+#ifndef LT_STR
+#  define LT__STR(arg)		#arg
+#  define LT_STR(arg)		LT__STR(arg)
+#endif
+
+#ifndef LT_CONC
+#  define LT__CONC(a, b)	a##b
+#  define LT_CONC(a, b)		LT__CONC(a, b)
+#endif
+#ifndef LT_CONC3
+#  define LT__CONC3(a, b, c)	a##b##c
+#  define LT_CONC3(a, b, c)	LT__CONC3(a, b, c)
+#endif
+
+#endif /*!defined(LT_SYSTEM_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/libltdl/slist.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/libltdl/slist.h	2008-06-16 01:19:14.859375000 -0500
@@ -0,0 +1,94 @@
+/* slist.h -- generalised singly linked lists
+
+   Copyright (C) 2000, 2004 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2000
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+/* A generalised list.  This is deliberately transparent so that you
+   can make the NEXT field of all your chained data structures first,
+   and then cast them to `(SList *)' so that they can be manipulated
+   by this API.
+
+   Alternatively, you can generate raw SList elements using slist_new(),
+   and put the element data in the USERDATA field.  Either way you
+   get to manage the memory involved by yourself.
+*/
+
+#if !defined(SLIST_H)
+#define SLIST_H 1
+
+#if defined(LTDL)
+#  include <libltdl/lt__glibc.h>
+#  include <libltdl/lt_system.h>
+#else
+#  define LT_SCOPE
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct slist {
+  struct slist *next;		/* chain forward pointer*/
+  const void *userdata;		/* for boxed `SList' item */
+} SList;
+
+typedef void *	SListCallback	(SList *item, void *userdata);
+typedef int	SListCompare	(const SList *item1, const SList *item2,
+				 void *userdata);
+
+LT_SCOPE SList *slist_concat	(SList *head, SList *tail);
+LT_SCOPE SList *slist_cons	(SList *item, SList *slist);
+
+LT_SCOPE SList *slist_delete	(SList *slist, void (*delete_fct) (void *item));
+LT_SCOPE void *	slist_remove	(SList **phead, SListCallback *find,
+				 void *matchdata);
+LT_SCOPE SList *slist_reverse	(SList *slist);
+LT_SCOPE SList *slist_sort	(SList *slist, SListCompare *compare,
+				 void *userdata);
+
+LT_SCOPE SList *slist_tail	(SList *slist);
+LT_SCOPE SList *slist_nth	(SList *slist, size_t n);
+LT_SCOPE void *	slist_find	(SList *slist, SListCallback *find,
+				 void *matchdata);
+LT_SCOPE size_t slist_length	(SList *slist);
+
+LT_SCOPE void *	slist_foreach   (SList *slist, SListCallback *foreach,
+				 void *userdata);
+
+LT_SCOPE SList *slist_box	(const void *userdata);
+LT_SCOPE void *	slist_unbox	(SList *item);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#if !defined(LTDL)
+#  undef LT_SCOPE
+#endif
+
+#endif /*!defined(SLIST_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/dld_link.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/dld_link.c	2008-06-16 01:19:08.171875000 -0500
@@ -0,0 +1,158 @@
+/* loader-dld_link.c -- dynamic linking with dld
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dld_link_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dld_link";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DLD_H)
+#  include <dld.h>
+#endif
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module module = lt__strdup (filename);
+
+  if (dld_link (filename) != 0)
+    {
+      LT__SETERROR (CANNOT_OPEN);
+      FREE (module);
+    }
+
+  return module;
+}
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (dld_unlink_by_file ((char*)(module), 1) != 0)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+  else
+    {
+      FREE (module);
+    }
+
+  return errors;
+}
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module LT__UNUSED module,
+	const char *name)
+{
+  void *address = dld_get_func (name);
+
+  if (!address)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/dlopen.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/dlopen.c	2008-06-16 01:19:08.625000000 -0500
@@ -0,0 +1,242 @@
+/* loader-dlopen.c --  dynamic linking with dlopen/dlsym
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dlopen_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dlopen";
+#if defined(DLSYM_USCORE)
+      vtable->sym_prefix	= "_";
+#endif
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_PREPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DLFCN_H)
+#  include <dlfcn.h>
+#endif
+
+#if defined(HAVE_SYS_DL_H)
+#  include <sys/dl.h>
+#endif
+
+
+/* We may have to define LT_LAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#if !defined(LT_LAZY_OR_NOW)
+#  if defined(RTLD_LAZY)
+#    define LT_LAZY_OR_NOW	RTLD_LAZY
+#  else
+#    if defined(DL_LAZY)
+#      define LT_LAZY_OR_NOW	DL_LAZY
+#    endif
+#  endif /* !RTLD_LAZY */
+#endif
+#if !defined(LT_LAZY_OR_NOW)
+#  if defined(RTLD_NOW)
+#    define LT_LAZY_OR_NOW	RTLD_NOW
+#  else
+#    if defined(DL_NOW)
+#      define LT_LAZY_OR_NOW	DL_NOW
+#    endif
+#  endif /* !RTLD_NOW */
+#endif
+#if !defined(LT_LAZY_OR_NOW)
+#  define LT_LAZY_OR_NOW	0
+#endif /* !LT_LAZY_OR_NOW */
+
+/* We only support local and global symbols from modules for loaders
+   that provide such a thing, otherwise the system default is used.  */
+#if !defined(RTLD_GLOBAL)
+#  if defined(DL_GLOBAL)
+#    define RTLD_GLOBAL		DL_GLOBAL
+#  endif
+#endif /* !RTLD_GLOBAL */
+#if !defined(RTLD_LOCAL)
+#  if defined(DL_LOCAL)
+#    define RTLD_LOCAL		DL_LOCAL
+#  endif
+#endif /* !RTLD_LOCAL */
+
+#if defined(HAVE_DLERROR)
+#  define DLERROR(arg)	dlerror ()
+#else
+#  define DLERROR(arg)	LT__STRERROR (arg)
+#endif
+
+#define DL__SETERROR(errorcode) \
+	LT__SETERRORSTR (DLERROR (errorcode))
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise advise)
+{
+  int		module_flags = LT_LAZY_OR_NOW;
+  lt_module	module;
+
+  if (advise)
+    {
+#ifdef RTLD_GLOBAL
+      /* If there is some means of asking for global symbol resolution,
+         do so.  */
+      if (((lt__advise *) advise)->is_symglobal)
+        module_flags |= RTLD_GLOBAL;
+#else
+      /* Otherwise, reset that bit so the caller can tell it wasn't
+         acted on.  */
+      ((lt__advise *) advise)->is_symglobal = 0;
+#endif
+
+/* And similarly for local only symbol resolution.  */
+#ifdef RTLD_LOCAL
+      if (((lt__advise *) advise)->is_symlocal)
+        module_flags |= RTLD_LOCAL;
+#else
+      ((lt__advise *) advise)->is_symlocal = 0;
+#endif
+    }
+
+  /* On AIX, dlopen(NULL) succeeds but dlsym of symbols fails.
+     In this case, fail here to let the preopen loader do the job. */
+#ifndef LTDL_DLOPEN_SELF_WORKS
+  if (!filename)
+    module = NULL;
+  else
+#endif
+    module = dlopen (filename, module_flags);
+
+  if (!module)
+    {
+      DL__SETERROR (CANNOT_OPEN);
+    }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (dlclose (module) != 0)
+    {
+      DL__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = dlsym (module, name);
+
+  if (!address)
+    {
+      DL__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/dyld.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/dyld.c	2008-06-16 01:19:08.984375000 -0500
@@ -0,0 +1,511 @@
+/* loader-dyld.c -- dynamic linking on darwin and OS X
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Peter O'Gorman, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dyld_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_init  (lt_user_data loader_data);
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dyld";
+      vtable->sym_prefix	= "_";
+      vtable->dlloader_init	= vl_init;
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_MACH_O_DYLD_H)
+#  if !defined(__APPLE_CC__) && !defined(__MWERKS__) && !defined(__private_extern__)
+  /* Is this correct? Does it still function properly? */
+#    define __private_extern__ extern
+#  endif
+#  include <mach-o/dyld.h>
+#endif
+
+#include <mach-o/getsect.h>
+
+/* We have to put some stuff here that isn't in older dyld.h files */
+#if !defined(ENUM_DYLD_BOOL)
+# define ENUM_DYLD_BOOL
+# undef FALSE
+# undef TRUE
+ enum DYLD_BOOL {
+    FALSE,
+    TRUE
+ };
+#endif
+#if !defined(LC_REQ_DYLD)
+# define LC_REQ_DYLD 0x80000000
+#endif
+#if !defined(LC_LOAD_WEAK_DYLIB)
+# define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)
+#endif
+
+#if !defined(NSADDIMAGE_OPTION_NONE)
+#  define NSADDIMAGE_OPTION_NONE                          0x0
+#endif
+#if !defined(NSADDIMAGE_OPTION_RETURN_ON_ERROR)
+#  define NSADDIMAGE_OPTION_RETURN_ON_ERROR               0x1
+#endif
+#if !defined(NSADDIMAGE_OPTION_WITH_SEARCHING)
+#  define NSADDIMAGE_OPTION_WITH_SEARCHING                0x2
+#endif
+#if !defined(NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED)
+#  define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED         0x4
+#endif
+#if !defined(NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME)
+#  define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8
+#endif
+
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND               0x0
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW           0x1
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY         0x2
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR    0x4
+#endif
+
+#define LT__SYMLOOKUP_OPTS	(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW \
+				| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR)
+
+#if defined(__BIG_ENDIAN__)
+#  define LT__MAGIC	MH_MAGIC
+#else
+#  define LT__MAGIC	MH_CIGAM
+#endif
+
+#define DYLD__SETMYERROR(errmsg)    LT__SETERRORSTR (dylderror (errmsg))
+#define DYLD__SETERROR(errcode)	    DYLD__SETMYERROR (LT__STRERROR (errcode))
+
+typedef struct mach_header mach_header;
+typedef struct dylib_command dylib_command;
+
+static const char *dylderror (const char *errmsg);
+static const mach_header *lt__nsmodule_get_header (NSModule module);
+static const char *lt__header_get_instnam (const mach_header *mh);
+static const mach_header *lt__match_loadedlib (const char *name);
+static NSSymbol lt__linkedlib_symbol (const char *symname, const mach_header *mh);
+
+static const mach_header *(*lt__addimage)	(const char *image_name,
+						 unsigned long options) = 0;
+static NSSymbol	(*lt__image_symbol)		(const mach_header *image,
+						 const char *symbolName,
+						 unsigned long options) = 0;
+static enum DYLD_BOOL (*lt__image_symbol_p)	(const mach_header *image,
+						 const char *symbolName) = 0;
+static enum DYLD_BOOL (*lt__module_export)	(NSModule module) = 0;
+
+static int dyld_cannot_close				  = 0;
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to initialise this loader.  */
+static int
+vl_init (lt_user_data loader_data)
+{
+  int errors = 0;
+
+  if (! dyld_cannot_close)
+    {
+      if (!_dyld_present ())
+	{
+	  ++errors;
+	}
+      else
+	{
+	  (void) _dyld_func_lookup ("__dyld_NSAddImage",
+				    (unsigned long*) &lt__addimage);
+	  (void) _dyld_func_lookup ("__dyld_NSLookupSymbolInImage",
+				    (unsigned long*)&lt__image_symbol);
+	  (void) _dyld_func_lookup ("__dyld_NSIsSymbolNameDefinedInImage",
+				    (unsigned long*) &lt__image_symbol_p);
+	  (void) _dyld_func_lookup ("__dyld_NSMakePrivateModulePublic",
+				    (unsigned long*) &lt__module_export);
+	  dyld_cannot_close = lt_dladderror ("can't close a dylib");
+	}
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module module = 0;
+  NSObjectFileImage ofi = 0;
+
+  if (!filename)
+    {
+      return (lt_module) -1;
+    }
+
+  switch (NSCreateObjectFileImageFromFile (filename, &ofi))
+    {
+    case NSObjectFileImageSuccess:
+      module = NSLinkModule (ofi, filename, NSLINKMODULE_OPTION_RETURN_ON_ERROR
+			     		    | NSLINKMODULE_OPTION_PRIVATE
+			     		    | NSLINKMODULE_OPTION_BINDNOW);
+      NSDestroyObjectFileImage (ofi);
+
+      if (module)
+	{
+	  lt__module_export (module);
+	}
+      break;
+
+    case NSObjectFileImageInappropriateFile:
+      if (lt__image_symbol_p && lt__image_symbol)
+	{
+	  module = (lt_module) lt__addimage(filename,
+					    NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+	}
+      break;
+
+    case NSObjectFileImageFailure:
+    case NSObjectFileImageArch:
+    case NSObjectFileImageFormat:
+    case NSObjectFileImageAccess:
+      /*NOWORK*/
+      break;
+    }
+
+  if (!module)
+    {
+      DYLD__SETERROR (CANNOT_OPEN);
+    }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (module != (lt_module) -1)
+    {
+      const mach_header *mh = (const mach_header *) module;
+      int flags = 0;
+      if (mh->magic == LT__MAGIC)
+	{
+	  lt_dlseterror (dyld_cannot_close);
+	  ++errors;
+	}
+      else
+	{
+	  /* Currently, if a module contains c++ static destructors and it
+	     is unloaded, we get a segfault in atexit(), due to compiler and
+	     dynamic loader differences of opinion, this works around that.  */
+	  if ((const struct section *) NULL !=
+	      getsectbynamefromheader (lt__nsmodule_get_header (module),
+				       "__DATA", "__mod_term_func"))
+	    {
+	      flags |= NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
+	    }
+#if defined(__ppc__)
+	  flags |= NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
+#endif
+	  if (!NSUnLinkModule (module, flags))
+	    {
+	      DYLD__SETERROR (CANNOT_CLOSE);
+	      ++errors;
+	    }
+	}
+    }
+
+  return errors;
+}
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data loader_data, lt_module module, const char *name)
+{
+  NSSymbol *nssym = 0;
+  const mach_header *mh = (const mach_header *) module;
+  char saveError[256] = "Symbol not found";
+
+  if (module == (lt_module) -1)
+    {
+      void *address, *unused;
+      _dyld_lookup_and_bind (name, (unsigned long*) &address, &unused);
+      return address;
+    }
+
+  if (mh->magic == LT__MAGIC)
+    {
+      if (lt__image_symbol_p && lt__image_symbol)
+	{
+	  if (lt__image_symbol_p (mh, name))
+	    {
+	      nssym = lt__image_symbol (mh, name, LT__SYMLOOKUP_OPTS);
+	    }
+	}
+
+    }
+  else
+    {
+      nssym = NSLookupSymbolInModule (module, name);
+    }
+
+  if (!nssym)
+    {
+      strncpy (saveError, dylderror (LT__STRERROR (SYMBOL_NOT_FOUND)), 255);
+      saveError[255] = 0;
+      if (!mh)
+	{
+	  mh = (mach_header *)lt__nsmodule_get_header (module);
+	}
+      nssym = lt__linkedlib_symbol (name, mh);
+    }
+
+  if (!nssym)
+    {
+      LT__SETERRORSTR (saveError);
+    }
+
+  return nssym ? NSAddressOfSymbol (nssym) : 0;
+}
+
+
+
+
+/* --- HELPER FUNCTIONS --- */
+
+
+/* Return the dyld error string, or the passed in error string if none. */
+static const char *
+dylderror (const char *errmsg)
+{
+  NSLinkEditErrors ler;
+  int lerno;
+  const char *file;
+  const char *errstr;
+
+  NSLinkEditError (&ler, &lerno, &file, &errstr);
+
+  if (! (errstr && *errstr))
+    {
+      errstr = errmsg;
+    }
+
+  return errstr;
+}
+
+/* There should probably be an apple dyld api for this. */
+static const mach_header *
+lt__nsmodule_get_header (NSModule module)
+{
+  int i = _dyld_image_count();
+  const char *modname = NSNameOfModule (module);
+  const mach_header *mh = 0;
+
+  if (!modname)
+    return NULL;
+
+  while (i > 0)
+    {
+      --i;
+      if (strneq (_dyld_get_image_name (i), modname))
+	{
+	  mh = _dyld_get_image_header (i);
+	  break;
+	}
+    }
+
+  return mh;
+}
+
+/* NSAddImage is also used to get the loaded image, but it only works if
+   the lib is installed, for uninstalled libs we need to check the
+   install_names against each other.  Note that this is still broken if
+   DYLD_IMAGE_SUFFIX is set and a different lib was loaded as a result.  */
+static const char *
+lt__header_get_instnam (const mach_header *mh)
+{
+  unsigned long offset = sizeof(mach_header);
+  const char* result   = 0;
+  int j;
+
+  for (j = 0; j < mh->ncmds; j++)
+    {
+      struct load_command *lc;
+
+      lc = (struct load_command*) (((unsigned long) mh) + offset);
+      if (LC_ID_DYLIB == lc->cmd)
+	{
+	  result=(char*)(((dylib_command*) lc)->dylib.name.offset +
+			 (unsigned long) lc);
+	}
+      offset += lc->cmdsize;
+    }
+
+  return result;
+}
+
+static const mach_header *
+lt__match_loadedlib (const char *name)
+{
+  const mach_header *mh	= 0;
+  int i = _dyld_image_count();
+
+  while (i > 0)
+    {
+      const char *id;
+
+      --i;
+      id = lt__header_get_instnam (_dyld_get_image_header (i));
+      if (id && strneq (id, name))
+	{
+	  mh = _dyld_get_image_header (i);
+	  break;
+	}
+    }
+
+  return mh;
+}
+
+/* Safe to assume our mh is good. */
+static NSSymbol
+lt__linkedlib_symbol (const char *symname, const mach_header *mh)
+{
+  NSSymbol symbol = 0;
+
+  if (lt__image_symbol && NSIsSymbolNameDefined (symname))
+    {
+      unsigned long offset = sizeof(mach_header);
+      struct load_command *lc;
+      int j;
+
+      for (j = 0; j < mh->ncmds; j++)
+	{
+	  lc = (struct load_command*) (((unsigned long) mh) + offset);
+	  if ((LC_LOAD_DYLIB == lc->cmd) || (LC_LOAD_WEAK_DYLIB == lc->cmd))
+	    {
+	      unsigned long base = ((dylib_command *) lc)->dylib.name.offset;
+	      char *name = (char *) (base + (unsigned long) lc);
+	      const mach_header *mh1 = lt__match_loadedlib (name);
+
+	      if (!mh1)
+		{
+		  /* Maybe NSAddImage can find it */
+		  mh1 = lt__addimage (name,
+				      NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED
+				      | NSADDIMAGE_OPTION_WITH_SEARCHING
+				      | NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+		}
+
+	      if (mh1)
+		{
+		  symbol = lt__image_symbol (mh1, symname, LT__SYMLOOKUP_OPTS);
+		  if (symbol)
+		    break;
+		}
+	    }
+
+	  offset += lc->cmdsize;
+	}
+    }
+
+  return symbol;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/load_add_on.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/load_add_on.c	2008-06-16 01:19:09.375000000 -0500
@@ -0,0 +1,167 @@
+/* loader-load_add_on.c --  dynamic linking for BeOS
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	load_add_on_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_load_add_on";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#include <kernel/image.h>
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  image_id image = 0;
+
+  if (filename)
+    {
+      image = load_add_on (filename);
+    }
+  else
+    {
+      image_info info;
+      int32 cookie = 0;
+      if (get_next_image_info (0, &cookie, &info) == B_OK)
+	image = load_add_on (info.name);
+    }
+
+  if (image <= 0)
+    {
+      LT__SETERROR (CANNOT_OPEN);
+      image = 0;
+    }
+
+  return (lt_module) image;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (unload_add_on ((image_id) module) != B_OK)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = 0;
+  image_id image = (image_id) module;
+
+  if (get_image_symbol (image, name, B_SYMBOL_TYPE_ANY, address) != B_OK)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+      address = 0;
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/loadlibrary.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/loadlibrary.c	2008-06-16 01:19:09.781250000 -0500
@@ -0,0 +1,244 @@
+/* loader-loadlibrary.c --  dynamic linking for Win32
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+#if defined(__CYGWIN__)
+# include <sys/cygwin.h>
+#endif
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	loadlibrary_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlinterface_id iface_id = 0;
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+      iface_id = lt_dlinterface_register ("ltdl loadlibrary", NULL);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_loadlibrary";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#include <windows.h>
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module	module	   = 0;
+  char		*ext;
+  char		wpath[MAX_PATH];
+  size_t	len;
+
+  if (!filename)
+    {
+      /* Get the name of main module */
+      *wpath = 0;
+      GetModuleFileName (NULL, wpath, sizeof (wpath));
+      filename = wpath;
+    }
+  else
+    {
+      len = LT_STRLEN (filename);
+
+      if (len >= MAX_PATH)
+        {
+	  LT__SETERROR (CANNOT_OPEN);
+	  return 0;
+	}
+
+#if defined(__CYGWIN__)
+      cygwin_conv_to_full_win32_path (filename, wpath);
+      len = 0;
+#else
+      strcpy(wpath, filename);
+#endif
+
+      ext = strrchr (wpath, '.');
+      if (!ext)
+	{
+	  /* Append a `.' to stop Windows from adding an
+	     implicit `.dll' extension. */
+	  if (!len)
+	    len = LT_STRLEN (wpath);
+
+	  if (len + 1 >= MAX_PATH)
+	    {
+	      LT__SETERROR (CANNOT_OPEN);
+	      return 0;
+	    }
+
+	  wpath[len] = '.';
+	  wpath[len+1] = '\0';
+	}
+    }
+
+  {
+    /* Silence dialog from LoadLibrary on some failures.
+       No way to get the error mode, but to set it,
+       so set it twice to preserve any previous flags. */
+    UINT errormode = SetErrorMode(SEM_FAILCRITICALERRORS);
+    SetErrorMode(errormode | SEM_FAILCRITICALERRORS);
+
+    module = LoadLibrary (wpath);
+
+    /* Restore the error mode. */
+    SetErrorMode(errormode);
+  }
+
+  /* libltdl expects this function to fail if it is unable
+     to physically load the library.  Sadly, LoadLibrary
+     will search the loaded libraries for a match and return
+     one of them if the path search load fails.
+
+     We check whether LoadLibrary is returning a handle to
+     an already loaded module, and simulate failure if we
+     find one. */
+  {
+    lt__handle *        cur        = 0;
+
+    while ((cur = (lt__handle *) lt_dlhandle_iterate (iface_id, (lt_dlhandle) cur)))
+      {
+        if (!cur->module)
+          {
+            cur = 0;
+            break;
+          }
+
+        if (cur->module == module)
+          {
+            break;
+          }
+      }
+
+    if (cur || !module)
+      {
+        LT__SETERROR (CANNOT_OPEN);
+        module = 0;
+      }
+  }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (FreeLibrary((HMODULE) module) == 0)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = (void *) GetProcAddress ((HMODULE) module, name);
+
+  if (!address)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/preopen.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/preopen.c	2008-06-16 01:19:15.265625000 -0500
@@ -0,0 +1,375 @@
+/* loader-preopen.c -- emulate dynamic linking using preloaded_symbols
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	preopen_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_init  (lt_user_data loader_data);
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_preopen";
+      vtable->sym_prefix	= 0;
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_init	= vl_init;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_PREPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+/* Wrapper type to chain together symbol lists of various origins.  */
+typedef struct symlist_chain
+{
+  struct symlist_chain *next;
+  const lt_dlsymlist   *symlist;
+} symlist_chain;
+
+
+static int add_symlist   (const lt_dlsymlist *symlist);
+static int free_symlists (void);
+
+/* The start of the symbol lists chain.  */
+static symlist_chain	       *preloaded_symlists		= 0;
+
+/* A symbol list preloaded before lt_init() was called.  */
+static const	lt_dlsymlist   *default_preloaded_symbols	= 0;
+
+
+/* A function called through the vtable to initialise this loader.  */
+static int
+vl_init (lt_user_data LT__UNUSED loader_data)
+{
+  int errors = 0;
+
+  preloaded_symlists = 0;
+  if (default_preloaded_symbols)
+    {
+      errors = lt_dlpreload (default_preloaded_symbols);
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  free_symlists ();
+  return 0;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  symlist_chain *lists;
+  lt_module	 module = 0;
+
+  if (!preloaded_symlists)
+    {
+      LT__SETERROR (NO_SYMBOLS);
+      goto done;
+    }
+
+  /* Can't use NULL as the reflective symbol header, as NULL is
+     used to mark the end of the entire symbol list.  Self-dlpreopened
+     symbols follow this magic number, chosen to be an unlikely
+     clash with a real module name.  */
+  if (!filename)
+    {
+      filename = "@PROGRAM@";
+    }
+
+  for (lists = preloaded_symlists; lists; lists = lists->next)
+    {
+      const lt_dlsymlist *symbol;
+      for (symbol= lists->symlist; symbol->name; ++symbol)
+	{
+	  if (!symbol->address && streq (symbol->name, filename))
+	    {
+	      /* If the next symbol's name and address is 0, it means
+		 the module just contains the originator and no symbols.
+		 In this case we pretend that we never saw the module and
+	         hope that some other loader will be able to load the module
+	         and have access to its symbols */
+	      const lt_dlsymlist *next_symbol = symbol +1;
+	      if (next_symbol->address && next_symbol->name)
+		{
+	          module = (lt_module) lists->symlist;
+	          goto done;
+		}
+	    }
+	}
+    }
+
+  LT__SETERROR (FILE_NOT_FOUND);
+
+ done:
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module LT__UNUSED module)
+{
+  /* Just to silence gcc -Wall */
+  module = 0;
+  return 0;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  lt_dlsymlist	       *symbol = (lt_dlsymlist*) module;
+
+  symbol +=2;			/* Skip header (originator then libname). */
+
+  while (symbol->name)
+    {
+      if (streq (symbol->name, name))
+	{
+	  return symbol->address;
+	}
+
+    ++symbol;
+  }
+
+  LT__SETERROR (SYMBOL_NOT_FOUND);
+
+  return 0;
+}
+
+
+
+/* --- HELPER FUNCTIONS --- */
+
+
+/* The symbol lists themselves are not allocated from the heap, but
+   we can unhook them and free up the chain of links between them.  */
+static int
+free_symlists (void)
+{
+  symlist_chain *lists;
+
+  lists = preloaded_symlists;
+  while (lists)
+    {
+      symlist_chain *next = lists->next;
+      FREE (lists);
+      lists = next;
+    }
+  preloaded_symlists = 0;
+
+  return 0;
+}
+
+/* Add a new symbol list to the global chain.  */
+static int
+add_symlist (const lt_dlsymlist *symlist)
+{
+  symlist_chain *lists;
+  int		 errors   = 0;
+
+  /* Search for duplicate entries:  */
+  for (lists = preloaded_symlists;
+       lists && lists->symlist != symlist; lists = lists->next)
+    /*NOWORK*/;
+
+  /* Don't add the same list twice:  */
+  if (!lists)
+    {
+      symlist_chain *tmp = (symlist_chain *) lt__zalloc (sizeof *tmp);
+
+      if (tmp)
+	{
+	  tmp->symlist = symlist;
+	  tmp->next = preloaded_symlists;
+	  preloaded_symlists = tmp;
+	}
+      else
+	{
+	  ++errors;
+	}
+    }
+
+  return errors;
+}
+
+
+
+/* --- PRELOADING API CALL IMPLEMENTATIONS --- */
+
+
+/* Save a default symbol list for later.  */
+int
+lt_dlpreload_default (const lt_dlsymlist *preloaded)
+{
+  default_preloaded_symbols = preloaded;
+  return 0;
+}
+
+
+/* Add a symbol list to the global chain, or with a NULL argument,
+   revert to just the default list.  */
+int
+lt_dlpreload (const lt_dlsymlist *preloaded)
+{
+  int errors = 0;
+
+  if (preloaded)
+    {
+      errors = add_symlist (preloaded);
+    }
+  else
+    {
+      free_symlists();
+
+      if (default_preloaded_symbols)
+	{
+	  errors = lt_dlpreload (default_preloaded_symbols);
+	}
+    }
+
+  return errors;
+}
+
+
+/* Open all the preloaded modules from the named originator, executing
+   a callback for each one.  If ORIGINATOR is NULL, then call FUNC for
+   each preloaded module from the program itself.  */
+int
+lt_dlpreload_open (const char *originator, lt_dlpreload_callback_func *func)
+{
+  symlist_chain *list;
+  int		 errors = 0;
+  int		 found  = 0;
+
+  /* For each symlist in the chain...  */
+  for (list = preloaded_symlists; list; list = list->next)
+    {
+      /* ...that was preloaded by the requesting ORIGINATOR... */
+      if ((originator && streq (list->symlist->name, originator))
+          || (!originator && streq (list->symlist->name, "@PROGRAM@")))
+	{
+	  const lt_dlsymlist *symbol;
+	  unsigned int idx = 0;
+
+	  ++found;
+
+	  /* ...load the symbols per source compilation unit:
+	     (we preincrement the index to skip over the originator entry)  */
+	  while ((symbol = &list->symlist[++idx])->name != 0)
+	    {
+	      if ((symbol->address == 0)
+		  && (strneq (symbol->name, "@PROGRAM@")))
+		{
+		  lt_dlhandle handle = lt_dlopen (symbol->name);
+		  if (handle == 0)
+		    {
+		      ++errors;
+		    }
+		  else
+		    {
+		      errors += (*func) (handle);
+		    }
+		}
+	    }
+	}
+    }
+
+  if (!found)
+    {
+      LT__SETERROR(CANNOT_OPEN);
+      ++errors;
+    }
+
+  return errors;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/loaders/shl_load.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/loaders/shl_load.c	2008-06-16 01:19:10.140625000 -0500
@@ -0,0 +1,222 @@
+/* loader-shl_load.c --  dynamic linking with shl_load (HP-UX)
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	shl_load_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_shl_load";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DL_H)
+#  include <dl.h>
+#endif
+
+/* some flags are missing on some systems, so we provide
+ * harmless defaults.
+ *
+ * Mandatory:
+ * BIND_IMMEDIATE  - Resolve symbol references when the library is loaded.
+ * BIND_DEFERRED   - Delay code symbol resolution until actual reference.
+ *
+ * Optionally:
+ * BIND_FIRST	   - Place the library at the head of the symbol search
+ * 		     order.
+ * BIND_NONFATAL   - The default BIND_IMMEDIATE behavior is to treat all
+ * 		     unsatisfied symbols as fatal.  This flag allows
+ * 		     binding of unsatisfied code symbols to be deferred
+ * 		     until use.
+ *		     [Perl: For certain libraries, like DCE, deferred
+ *		     binding often causes run time problems. Adding
+ *		     BIND_NONFATAL to BIND_IMMEDIATE still allows
+ *		     unresolved references in situations like this.]
+ * BIND_NOSTART	   - Do not call the initializer for the shared library
+ *		     when the library is loaded, nor on a future call to
+ *		     shl_unload().
+ * BIND_VERBOSE	   - Print verbose messages concerning possible
+ *		     unsatisfied symbols.
+ *
+ * hp9000s700/hp9000s800:
+ * BIND_RESTRICTED - Restrict symbols visible by the library to those
+ *		     present at library load time.
+ * DYNAMIC_PATH	   - Allow the loader to dynamically search for the
+ *		     library specified by the path argument.
+ */
+
+#if !defined(DYNAMIC_PATH)
+#  define DYNAMIC_PATH		0
+#endif
+#if !defined(BIND_RESTRICTED)
+#  define BIND_RESTRICTED	0
+#endif
+
+#define	LT_BIND_FLAGS	(BIND_IMMEDIATE | BIND_NONFATAL | DYNAMIC_PATH)
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  static shl_t self = (shl_t) 0;
+  lt_module module = shl_load (filename, LT_BIND_FLAGS, 0L);
+
+  /* Since searching for a symbol against a NULL module handle will also
+     look in everything else that was already loaded and exported with
+     the -E compiler flag, we always cache a handle saved before any
+     modules are loaded.  */
+  if (!self)
+    {
+      void *address;
+      shl_findsym (&self, "main", TYPE_UNDEFINED, &address);
+    }
+
+  if (!filename)
+    {
+      module = self;
+    }
+  else
+    {
+      module = shl_load (filename, LT_BIND_FLAGS, 0L);
+
+      if (!module)
+	{
+	  LT__SETERROR (CANNOT_OPEN);
+	}
+    }
+
+  return module;
+}
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (module && (shl_unload ((shl_t) (module)) != 0))
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = 0;
+
+  /* sys_shl_open should never return a NULL module handle */
+  if (module == (lt_module) 0)
+  {
+    LT__SETERROR (INVALID_HANDLE);
+  }
+  else if (!shl_findsym((shl_t*) &module, name, TYPE_UNDEFINED, &address))
+    {
+      if (!address)
+	{
+	  LT__SETERROR (SYMBOL_NOT_FOUND);
+	}
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__alloc.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__alloc.c	2008-06-16 01:19:15.687500000 -0500
@@ -0,0 +1,95 @@
+/* lt__alloc.c -- internal memory management interface
+
+   Copyright (C) 2004, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+
+#include <stdio.h>
+
+#include "lt__alloc.h"
+
+static void alloc_die_default (void);
+
+void (*lt__alloc_die) (void) = alloc_die_default;
+
+/* Unless overridden, exit on memory failure.  */
+static void
+alloc_die_default (void)
+{
+  fprintf (stderr, "Out of memory.\n");
+  exit (EXIT_FAILURE);
+}
+
+void *
+lt__malloc (size_t n)
+{
+  void *mem;
+
+  if (! (mem = malloc (n)))
+    (*lt__alloc_die) ();
+
+  return mem;
+}
+
+void *
+lt__zalloc (size_t n)
+{
+  void *mem;
+
+  if ((mem = lt__malloc (n)))
+    memset (mem, 0, n);
+
+  return mem;
+}
+
+void *
+lt__realloc (void *mem, size_t n)
+{
+  if (! (mem = realloc (mem, n)))
+    (*lt__alloc_die) ();
+
+  return mem;
+}
+
+void *
+lt__memdup (void const *mem, size_t n)
+{
+  void *newmem;
+
+  if ((newmem = lt__malloc (n)))
+    return memcpy (newmem, mem, n);
+
+  return 0;
+}
+
+char *
+lt__strdup (const char *string)
+{
+  return (char *) lt__memdup (string, strlen (string) +1);
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__alloc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__alloc.h	2008-06-16 01:20:00.187500000 -0500
@@ -0,0 +1,58 @@
+/* lt__alloc.h -- internal memory management interface
+
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__ALLOC_H)
+#define LT__ALLOC_H 1
+
+#include "lt_system.h"
+
+LT_BEGIN_C_DECLS
+
+#define MALLOC(tp, n)		(tp*) lt__malloc((n) * sizeof(tp))
+#define REALLOC(tp, mem, n)	(tp*) lt__realloc((mem), (n) * sizeof(tp))
+#define FREE(mem)					LT_STMT_START {	\
+	if (mem) { free ((void *)mem); mem = NULL; }	} LT_STMT_END
+#define MEMREASSIGN(p, q)				LT_STMT_START {	\
+	if ((p) != (q)) { if (p) free (p); (p) = (q); (q) = 0; }	\
+								} LT_STMT_END
+
+/* If set, this function is called when memory allocation has failed.  */
+LT_SCOPE void (*lt__alloc_die) (void);
+
+LT_SCOPE void *lt__malloc (size_t n);
+LT_SCOPE void *lt__zalloc (size_t n);
+LT_SCOPE void *lt__realloc (void *mem, size_t n);
+LT_SCOPE void *lt__memdup (void const *mem, size_t n);
+
+LT_SCOPE char *lt__strdup (const char *string);
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT__ALLOC_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__dirent.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__dirent.c	2008-06-16 01:19:10.656250000 -0500
@@ -0,0 +1,107 @@
+/* lt__dirent.c -- internal directory entry scanning interface
+
+   Copyright (C) 2001, 2004 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2001
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+
+#include <assert.h>
+#include <stddef.h>
+
+#include "lt__dirent.h"
+
+#if defined(__WINDOWS__)
+
+void
+closedir (DIR *entry)
+{
+  assert (entry != (DIR *) NULL);
+  FindClose (entry->hSearch);
+  free ((void *) entry);
+}
+
+
+DIR *
+opendir (const char *path)
+{
+  char file_spec[LT_FILENAME_MAX];
+  DIR *entry;
+
+  assert (path != (char *) 0);
+  if (lt_strlcpy (file_spec, path, sizeof file_spec) >= sizeof file_spec
+      || lt_strlcat (file_spec, "\\", sizeof file_spec) >= sizeof file_spec)
+    return (DIR *) 0;
+  entry = (DIR *) malloc (sizeof(DIR));
+  if (entry != (DIR *) 0)
+    {
+      entry->firsttime = TRUE;
+      entry->hSearch = FindFirstFile (file_spec, &entry->Win32FindData);
+
+      if (entry->hSearch == INVALID_HANDLE_VALUE)
+	{
+	  if (lt_strlcat (file_spec, "\\*.*", sizeof file_spec) < sizeof file_spec)
+	    {
+	      entry->hSearch = FindFirstFile (file_spec, &entry->Win32FindData);
+	    }
+
+	  if (entry->hSearch == INVALID_HANDLE_VALUE)
+	    {
+	      entry = (free (entry), (DIR *) 0);
+	    }
+	}
+    }
+
+  return entry;
+}
+
+
+struct dirent *
+readdir (DIR *entry)
+{
+  int status;
+
+  if (entry == (DIR *) 0)
+    return (struct dirent *) 0;
+
+  if (!entry->firsttime)
+    {
+      status = FindNextFile (entry->hSearch, &entry->Win32FindData);
+      if (status == 0)
+        return (struct dirent *) 0;
+    }
+
+  entry->firsttime = FALSE;
+  if (lt_strlcpy (entry->file_info.d_name, entry->Win32FindData.cFileName,
+	sizeof entry->file_info.d_name) >= sizeof entry->file_info.d_name)
+    return (struct dirent *) 0;
+  entry->file_info.d_namlen = strlen (entry->file_info.d_name);
+
+  return &entry->file_info;
+}
+
+#endif /*defined(__WINDOWS__)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__dirent.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__dirent.h	2008-06-16 01:20:00.546875000 -0500
@@ -0,0 +1,87 @@
+/* lt__dirent.h -- internal directory entry scanning interface
+
+   Copyright (C) 2001, 2004, 2006 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2001
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__DIRENT_H)
+#define LT__DIRENT_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include "lt_system.h"
+
+#ifdef HAVE_DIRENT_H
+/* We have a fully operational dirent subsystem.  */
+#  include <dirent.h>
+#  define D_NAMLEN(dirent) (strlen((dirent)->d_name))
+
+#elif defined __WINDOWS__
+/* Use some wrapper code to emulate dirent on windows..  */
+#  define WINDOWS_DIRENT_EMULATION 1
+
+#  include <windows.h>
+
+#  define D_NAMLEN(dirent)	(strlen((dirent)->d_name))
+#  define dirent		lt__dirent
+#  define DIR			lt__DIR
+#  define opendir		lt__opendir
+#  define readdir		lt__readdir
+#  define closedir		lt__closedir
+
+LT_BEGIN_C_DECLS
+
+struct dirent
+{
+  char d_name[LT_FILENAME_MAX];
+  int  d_namlen;
+};
+
+typedef struct
+{
+  HANDLE hSearch;
+  WIN32_FIND_DATA Win32FindData;
+  BOOL firsttime;
+  struct dirent file_info;
+} DIR;
+
+
+LT_SCOPE DIR *		opendir		(const char *path);
+LT_SCOPE struct dirent *readdir		(DIR *entry);
+LT_SCOPE void		closedir	(DIR *entry);
+
+LT_END_C_DECLS
+
+#else /* !defined(__WINDOWS__)*/
+ERROR - cannot find dirent
+#endif /*!defined(__WINDOWS__)*/
+
+#endif /*!defined(LT__DIRENT_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__glibc.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__glibc.h	2008-06-16 01:20:00.890625000 -0500
@@ -0,0 +1,83 @@
+/* lt__glibc.h -- support for non glibc environments
+
+   Copyright (C) 2004, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__GLIBC_H)
+#define LT__GLIBC_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#if !defined(HAVE_ARGZ_H) || !defined(HAVE_WORKING_ARGZ)
+/* Redefine any glibc symbols we reimplement to import the
+   implementations into our lt__ namespace so we don't ever
+   clash with the system library if our clients use argz_*
+   from there in addition to libltdl.  */
+#  undef  argz_append
+#  define argz_append		lt__argz_append
+#  undef  argz_create_sep
+#  define argz_create_sep	lt__argz_create_sep
+#  undef  argz_insert
+#  define argz_insert		lt__argz_insert
+#  undef  argz_next
+#  define argz_next		lt__argz_next
+#  undef  argz_stringify
+#  define argz_stringify	lt__argz_stringify
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <argz.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+# define slist_concat	lt__slist_concat
+# define slist_cons	lt__slist_cons
+# define slist_delete	lt__slist_delete
+# define slist_remove	lt__slist_remove
+# define slist_reverse	lt__slist_reverse
+# define slist_sort	lt__slist_sort
+# define slist_tail	lt__slist_tail
+# define slist_nth	lt__slist_nth
+# define slist_find	lt__slist_find
+# define slist_length	lt__slist_length
+# define slist_foreach	lt__slist_foreach
+# define slist_box	lt__slist_box
+# define slist_unbox	lt__slist_unbox
+
+#include <slist.h>
+
+#endif /*!defined(LT__GLIBC_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__private.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__private.h	2008-06-16 01:20:01.234375000 -0500
@@ -0,0 +1,152 @@
+/* lt__private.h -- internal apis for libltdl
+
+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy con be downloaded from http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+*/
+
+#if !defined(LT__PRIVATE_H)
+#define LT__PRIVATE_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#if defined(HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+/* Import internal interfaces...  */
+#include "lt__alloc.h"
+#include "lt__dirent.h"
+#include "lt__strl.h"
+#include "lt__glibc.h"
+
+/* ...and all exported interfaces.  */
+#include "ltdl.h"
+
+#if defined(WITH_DMALLOC)
+#  include <dmalloc.h>
+#endif
+
+/* DLL building support on win32 hosts;  mostly to workaround their
+   ridiculous implementation of data symbol exporting. */
+#ifndef LT_GLOBAL_DATA
+# if defined(__WINDOWS__) || defined(__CYGWIN__)
+#  if defined(DLL_EXPORT)	/* defined by libtool (if required) */
+#   define LT_GLOBAL_DATA	__declspec(dllexport)
+#  endif
+# endif
+# ifndef LT_GLOBAL_DATA
+#  define LT_GLOBAL_DATA	/* static linking or !__WINDOWS__ */
+# endif
+#endif
+
+#ifndef __attribute__
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8) || __STRICT_ANSI__
+#  define __attribute__(x)
+# endif
+#endif
+
+#ifndef LT__UNUSED
+# define LT__UNUSED __attribute__ ((__unused__))
+#endif
+
+
+LT_BEGIN_C_DECLS
+
+#if !defined(errno)
+extern int errno;
+#endif
+
+LT_SCOPE void	lt__alloc_die_callback (void);
+
+
+/* For readability:  */
+#define strneq(s1, s2)	(strcmp((s1), (s2)) != 0)
+#define streq(s1, s2)	(!strcmp((s1), (s2)))
+
+
+
+/* --- OPAQUE STRUCTURES DECLARED IN LTDL.H --- */
+
+/* This type is used for the array of interface data sets in each handler. */
+typedef struct {
+  lt_dlinterface_id	key;
+  void *		data;
+} lt_interface_data;
+
+typedef struct lt__handle lt__handle;
+
+struct lt__handle {
+  lt__handle *		next;
+  const lt_dlvtable *	vtable;		/* dlopening interface */
+  lt_dlinfo		info;		/* user visible fields */
+  int			depcount;	/* number of dependencies */
+  lt_dlhandle *		deplibs;	/* dependencies */
+  lt_module		module;		/* system module handle */
+  void *		system;		/* system specific data */
+  lt_interface_data *	interface_data;	/* per caller associated data */
+  int			flags;		/* various boolean stats */
+};
+
+typedef struct lt__advise lt__advise;
+
+struct lt__advise {
+  unsigned int	try_ext:1;	/* try system library extensions.  */
+  unsigned int	is_resident:1;	/* module can't be unloaded. */
+  unsigned int	is_symglobal:1;	/* module symbols can satisfy
+				   subsequently loaded modules.  */
+  unsigned int	is_symlocal:1;	/* module symbols are only available
+				   locally. */
+};
+
+/* --- ERROR HANDLING --- */
+
+/* Extract the diagnostic strings from the error table macro in the same
+   order as the enumerated indices in lt_error.h. */
+
+#define LT__STRERROR(name)	lt__error_string(LT_CONC(LT_ERROR_,name))
+
+#define LT__GETERROR(lvalue)	      (lvalue) = lt__get_last_error()
+#define LT__SETERRORSTR(errormsg)     lt__set_last_error(errormsg)
+#define LT__SETERROR(errorcode)	      LT__SETERRORSTR(LT__STRERROR(errorcode))
+
+LT_SCOPE const char *lt__error_string	(int errorcode);
+LT_SCOPE const char *lt__get_last_error	(void);
+LT_SCOPE const char *lt__set_last_error	(const char *errormsg);
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT__PRIVATE_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__strl.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__strl.c	2008-06-16 01:19:11.078125000 -0500
@@ -0,0 +1,127 @@
+/* lt__strl.c -- size-bounded string copying and concatenation
+
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include <assert.h>
+#include <string.h>
+
+#include "lt__strl.h"
+
+/*
+ lt_strlcat appends the NULL-terminated string src to the end of dst.
+ It will append at most dstsize - strlen(dst) - 1 bytes,
+ NULL-terminating the result. The total length of the string which
+ would have been created given sufficient buffer size (may be longer
+ than dstsize) is returned.  This function substitutes for strlcat()
+ which is available under NetBSD, FreeBSD and Solaris 9.
+
+ Buffer overflow can be checked as follows:
+
+   if (lt_strlcat(dst, src, dstsize) >= dstsize)
+     return -1;
+*/
+#if !defined(HAVE_STRLCAT)
+size_t
+lt_strlcat(char *dst, const char *src, const size_t dstsize)
+{
+  size_t length;
+  char *p;
+  const char *q;
+
+  assert(dst != NULL);
+  assert(src != (const char *) NULL);
+  assert(dstsize >= 1);
+
+  length=strlen(dst);
+
+  /*
+    Copy remaining characters from src while constraining length to
+    size - 1.
+  */
+  for ( p = dst + length, q = src;
+        (*q != 0) && (length < dstsize - 1) ;
+        length++, p++, q++ )
+    *p = *q;
+
+  dst[length]='\0';
+
+  /*
+    Add remaining length of src to length.
+  */
+  while (*q++)
+    length++;
+
+  return length;
+}
+#endif /* !defined(HAVE_STRLCAT) */
+
+/*
+  lt_strlcpy copies up to dstsize - 1 characters from the NULL-terminated
+  string src to dst, NULL-terminating the result. The total length of
+  the string which would have been created given sufficient buffer
+  size (may be longer than dstsize) is returned. This function
+  substitutes for strlcpy() which is available under OpenBSD, FreeBSD
+  and Solaris 9.
+
+  Buffer overflow can be checked as  follows:
+
+    if (lt_strlcpy(dst, src, dstsize) >= dstsize)
+      return -1;
+*/
+#if !defined(HAVE_STRLCPY)
+size_t
+lt_strlcpy(char *dst, const char *src, const size_t dstsize)
+{
+  size_t length=0;
+  char *p;
+  const char *q;
+
+  assert(dst != NULL);
+  assert(src != (const char *) NULL);
+  assert(dstsize >= 1);
+
+  /*
+    Copy src to dst within bounds of size-1.
+  */
+  for ( p=dst, q=src, length=0 ;
+        (*q != 0) && (length < dstsize-1) ;
+        length++, p++, q++ )
+    *p = *q;
+
+  dst[length]='\0';
+
+  /*
+    Add remaining length of src to length.
+  */
+  while (*q++)
+    length++;
+
+  return length;
+}
+#endif /* !defined(HAVE_STRLCPY) */
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt__strl.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt__strl.h	2008-06-16 01:20:01.578125000 -0500
@@ -0,0 +1,53 @@
+/* lt__strl.h -- size-bounded string copying and concatenation
+
+   Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT__STRL_H)
+#define LT__STRL_H 1
+
+#if defined(LT_CONFIG_H)
+#  include LT_CONFIG_H
+#else
+#  include <config.h>
+#endif
+
+#include <string.h>
+#include "lt_system.h"
+
+#if !defined(HAVE_STRLCAT)
+#  define strlcat(dst,src,dstsize) lt_strlcat(dst,src,dstsize)
+LT_SCOPE size_t lt_strlcat(char *dst, const char *src, const size_t dstsize);
+#endif /* !defined(HAVE_STRLCAT) */
+
+#if !defined(HAVE_STRLCPY)
+#  define strlcpy(dst,src,dstsize) lt_strlcpy(dst,src,dstsize)
+LT_SCOPE size_t lt_strlcpy(char *dst, const char *src, const size_t dstsize);
+#endif /* !defined(HAVE_STRLCPY) */
+
+#endif /*!defined(LT__STRL_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt_dlloader.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt_dlloader.c	2008-06-16 01:19:16.078125000 -0500
@@ -0,0 +1,210 @@
+/* lt_dlloader.c -- dynamic library loader interface
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+#define RETURN_SUCCESS 0
+#define RETURN_FAILURE 1
+
+static void *	loader_callback (SList *item, void *userdata);
+
+/* A list of all the dlloaders we know about, each stored as a boxed
+   SList item:  */
+static	SList    *loaders		= 0;
+
+
+/* Return NULL, unless the loader in this ITEM has a matching name,
+   in which case we return the matching item so that its address is
+   passed back out (for possible freeing) by slist_remove.  */
+static void *
+loader_callback (SList *item, void *userdata)
+{
+  const lt_dlvtable *vtable = (const lt_dlvtable *) item->userdata;
+  const char *	    name    = (const char *) userdata;
+
+  assert (vtable);
+
+  return streq (vtable->name, name) ? (void *) item : NULL;
+}
+
+
+/* Hook VTABLE into our global LOADERS list according to its own
+   PRIORITY field value.  */
+int
+lt_dlloader_add (const lt_dlvtable *vtable)
+{
+  SList *item;
+
+  if ((vtable == 0)	/* diagnose invalid vtable fields */
+      || (vtable->module_open == 0)
+      || (vtable->module_close == 0)
+      || (vtable->find_sym == 0)
+      || ((vtable->priority != LT_DLLOADER_PREPEND) &&
+	  (vtable->priority != LT_DLLOADER_APPEND)))
+    {
+      LT__SETERROR (INVALID_LOADER);
+      return RETURN_FAILURE;
+    }
+
+  item = slist_box (vtable);
+  if (!item)
+    {
+      (*lt__alloc_die) ();
+
+      /* Let the caller know something went wrong if lt__alloc_die
+	 doesn't abort.  */
+      return RETURN_FAILURE;
+    }
+
+  if (vtable->priority == LT_DLLOADER_PREPEND)
+    {
+      loaders = slist_cons (item, loaders);
+    }
+  else
+    {
+      assert (vtable->priority == LT_DLLOADER_APPEND);
+      loaders = slist_concat (loaders, item);
+    }
+
+  return RETURN_SUCCESS;
+}
+
+#ifdef LT_DEBUG_LOADERS
+static void *
+loader_dump_callback (SList *item, void *userdata)
+{
+  const lt_dlvtable *vtable = (const lt_dlvtable *) item->userdata;
+  fprintf (stderr, ", %s", (vtable && vtable->name) ? vtable->name : "(null)");
+  return 0;
+}
+
+void
+lt_dlloader_dump (void)
+{
+  fprintf (stderr, "loaders: ");
+  if (!loaders)
+    {
+      fprintf (stderr, "(empty)");
+    }
+  else
+    {
+      const lt_dlvtable *head = (const lt_dlvtable *) loaders->userdata;
+      fprintf (stderr, "%s", (head && head->name) ? head->name : "(null)");
+      if (slist_tail (loaders))
+	slist_foreach (slist_tail (loaders), loader_dump_callback, NULL);
+    }
+  fprintf (stderr, "\n");
+}
+#endif
+
+/* An iterator for the global loader list: if LOADER is NULL, then
+   return the first element, otherwise the following element.  */
+lt_dlloader
+lt_dlloader_next (lt_dlloader loader)
+{
+  SList *item = (SList *) loader;
+  return (lt_dlloader) (item ? item->next : loaders);
+}
+
+
+/* Non-destructive unboxing of a loader.  */
+const lt_dlvtable *
+lt_dlloader_get	(lt_dlloader loader)
+{
+  return (const lt_dlvtable *) (loader ? ((SList *) loader)->userdata : NULL);
+}
+
+
+/* Return the contents of the first item in the global loader list
+   with a matching NAME after removing it from that list.  If there
+   was no match, return NULL; if there is an error, return NULL and
+   set an error for lt_dlerror; do not set an error if only resident
+   modules need this loader; in either case, the loader list is not
+   changed if NULL is returned.  */
+lt_dlvtable *
+lt_dlloader_remove (char *name)
+{
+  const lt_dlvtable *	vtable	= lt_dlloader_find (name);
+  static const char	id_string[] = "lt_dlloader_remove";
+  lt_dlinterface_id	iface;
+  lt_dlhandle		handle = 0;
+  int			in_use = 0;
+  int			in_use_by_resident = 0;
+
+  if (!vtable)
+    {
+      LT__SETERROR (INVALID_LOADER);
+      return 0;
+    }
+
+  /* Fail if there are any open modules which use this loader.  */
+  iface = lt_dlinterface_register (id_string, NULL);
+  while ((handle = lt_dlhandle_iterate (iface, handle)))
+    {
+      lt__handle *cur = (lt__handle *) handle;
+      if (cur->vtable == vtable)
+	{
+	  in_use = 1;
+	  if (lt_dlisresident (handle))
+	    in_use_by_resident = 1;
+	}
+    }
+  lt_dlinterface_free (iface);
+  if (in_use)
+    {
+      if (!in_use_by_resident)
+	LT__SETERROR (REMOVE_LOADER);
+      return 0;
+    }
+
+  /* Call the loader finalisation function.  */
+  if (vtable && vtable->dlloader_exit)
+    {
+      if ((*vtable->dlloader_exit) (vtable->dlloader_data) != 0)
+	{
+	  /* If there is an exit function, and it returns non-zero
+	     then it must set an error, and we will not remove it
+	     from the list.  */
+	  return 0;
+	}
+    }
+
+  /* If we got this far, remove the loader from our global list.  */
+  return (lt_dlvtable *)
+      slist_unbox ((SList *) slist_remove (&loaders, loader_callback, name));
+}
+
+
+const lt_dlvtable *
+lt_dlloader_find (char *name)
+{
+  return lt_dlloader_get (slist_find (loaders, loader_callback, name));
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt_dlloader.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt_dlloader.h	2008-06-16 01:20:01.937500000 -0500
@@ -0,0 +1,90 @@
+/* lt_dlloader.h -- dynamic library loader interface
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT_DLLOADER_H)
+#define LT_DLLOADER_H 1
+
+#include <libltdl/lt_system.h>
+
+LT_BEGIN_C_DECLS
+
+typedef	void *	lt_dlloader;
+typedef void *	lt_module;
+typedef void *	lt_user_data;
+typedef void *	lt_dladvise;
+
+/* Function pointer types for module loader vtable entries:  */
+typedef lt_module   lt_module_open	(lt_user_data data,
+					 const char *filename,
+					 lt_dladvise advise);
+typedef int	    lt_module_close	(lt_user_data data,
+					 lt_module module);
+typedef void *	    lt_find_sym		(lt_user_data data, lt_module module,
+					 const char *symbolname);
+typedef int	    lt_dlloader_init	(lt_user_data data);
+typedef int	    lt_dlloader_exit	(lt_user_data data);
+
+/* Default priority is LT_DLLOADER_PREPEND if none is explicitly given.  */
+typedef enum {
+  LT_DLLOADER_PREPEND = 0, LT_DLLOADER_APPEND
+} lt_dlloader_priority;
+
+/* This structure defines a module loader, as populated by the get_vtable
+   entry point of each loader.  */
+typedef struct {
+  const char *		name;
+  const char *		sym_prefix;
+  lt_module_open *	module_open;
+  lt_module_close *	module_close;
+  lt_find_sym *		find_sym;
+  lt_dlloader_init *	dlloader_init;
+  lt_dlloader_exit *	dlloader_exit;
+  lt_user_data		dlloader_data;
+  lt_dlloader_priority	priority;
+} lt_dlvtable;
+
+LT_SCOPE int		lt_dlloader_add	   (const lt_dlvtable *vtable);
+LT_SCOPE lt_dlloader	lt_dlloader_next   (const lt_dlloader loader);
+
+LT_SCOPE lt_dlvtable *	lt_dlloader_remove	(char *name);
+LT_SCOPE const lt_dlvtable *lt_dlloader_find	(char *name);
+LT_SCOPE const lt_dlvtable *lt_dlloader_get	(lt_dlloader loader);
+
+
+/* Type of a function to get a loader's vtable:  */
+typedef  const lt_dlvtable *lt_get_vtable	(lt_user_data data);
+
+#ifdef LT_DEBUG_LOADERS
+LT_SCOPE void		lt_dlloader_dump	(void);
+#endif
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT_DLLOADER_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt_error.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt_error.c	2008-06-16 01:19:16.484375000 -0500
@@ -0,0 +1,110 @@
+/* lt_error.c -- error propogation interface
+
+   Copyright (C) 1999, 2000, 2001, 2004, 2005, 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_error.h"
+
+static const char	*last_error	= 0;
+static const char	error_strings[LT_ERROR_MAX][LT_ERROR_LEN_MAX + 1] =
+  {
+#define LT_ERROR(name, diagnostic)	diagnostic,
+    lt_dlerror_table
+#undef LT_ERROR
+  };
+
+static	const char    **user_error_strings	= 0;
+static	int		errorcount		= LT_ERROR_MAX;
+
+int
+lt_dladderror (const char *diagnostic)
+{
+  int		errindex = 0;
+  int		result	 = -1;
+  const char  **temp     = (const char **) 0;
+
+  assert (diagnostic);
+
+  errindex = errorcount - LT_ERROR_MAX;
+  temp = REALLOC (const char *, user_error_strings, 1 + errindex);
+  if (temp)
+    {
+      user_error_strings		= temp;
+      user_error_strings[errindex]	= diagnostic;
+      result				= errorcount++;
+    }
+
+  return result;
+}
+
+int
+lt_dlseterror (int errindex)
+{
+  int		errors	 = 0;
+
+  if (errindex >= errorcount || errindex < 0)
+    {
+      /* Ack!  Error setting the error message! */
+      LT__SETERROR (INVALID_ERRORCODE);
+      ++errors;
+    }
+  else if (errindex < LT_ERROR_MAX)
+    {
+      /* No error setting the error message! */
+      LT__SETERRORSTR (error_strings[errindex]);
+    }
+  else
+    {
+      /* No error setting the error message! */
+      LT__SETERRORSTR (user_error_strings[errindex - LT_ERROR_MAX]);
+    }
+
+  return errors;
+}
+
+const char *
+lt__error_string (int errorcode)
+{
+  assert (errorcode >= 0);
+  assert (errorcode < LT_ERROR_MAX);
+
+  return error_strings[errorcode];
+}
+
+const char *
+lt__get_last_error (void)
+{
+  return last_error;
+}
+
+const char *
+lt__set_last_error (const char *errormsg)
+{
+  return last_error = errormsg;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt_error.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt_error.h	2008-06-16 01:20:02.265625000 -0500
@@ -0,0 +1,85 @@
+/* lt_error.h -- error propogation interface
+
+   Copyright (C) 1999, 2000, 2001, 2004, 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+/* Only include this header file once. */
+#if !defined(LT_ERROR_H)
+#define LT_ERROR_H 1
+
+#include <libltdl/lt_system.h>
+
+LT_BEGIN_C_DECLS
+
+/* Defining error strings alongside their symbolic names in a macro in
+   this way allows us to expand the macro in different contexts with
+   confidence that the enumeration of symbolic names will map correctly
+   onto the table of error strings.  \0 is appended to the strings to
+   expilicitely initialize the string terminator. */
+#define lt_dlerror_table						\
+    LT_ERROR(UNKNOWN,		    "unknown error\0")			\
+    LT_ERROR(DLOPEN_NOT_SUPPORTED,  "dlopen support not available\0")	\
+    LT_ERROR(INVALID_LOADER,	    "invalid loader\0")			\
+    LT_ERROR(INIT_LOADER,	    "loader initialization failed\0")	\
+    LT_ERROR(REMOVE_LOADER,	    "loader removal failed\0")		\
+    LT_ERROR(FILE_NOT_FOUND,	    "file not found\0")			\
+    LT_ERROR(DEPLIB_NOT_FOUND,	    "dependency library not found\0")	\
+    LT_ERROR(NO_SYMBOLS,	    "no symbols defined\0")		\
+    LT_ERROR(CANNOT_OPEN,	    "can't open the module\0")		\
+    LT_ERROR(CANNOT_CLOSE,	    "can't close the module\0")		\
+    LT_ERROR(SYMBOL_NOT_FOUND,	    "symbol not found\0")		\
+    LT_ERROR(NO_MEMORY,		    "not enough memory\0")		\
+    LT_ERROR(INVALID_HANDLE,	    "invalid module handle\0")		\
+    LT_ERROR(BUFFER_OVERFLOW,	    "internal buffer overflow\0")	\
+    LT_ERROR(INVALID_ERRORCODE,	    "invalid errorcode\0")		\
+    LT_ERROR(SHUTDOWN,		    "library already shutdown\0")	\
+    LT_ERROR(CLOSE_RESIDENT_MODULE, "can't close resident module\0")	\
+    LT_ERROR(INVALID_MUTEX_ARGS,    "internal error (code withdrawn)\0")\
+    LT_ERROR(INVALID_POSITION,	    "invalid search path insert position\0")\
+    LT_ERROR(CONFLICTING_FLAGS,	    "symbol visibility can be global or local\0")
+
+/* Enumerate the symbolic error names. */
+enum {
+#define LT_ERROR(name, diagnostic)	LT_CONC(LT_ERROR_, name),
+	lt_dlerror_table
+#undef LT_ERROR
+
+	LT_ERROR_MAX
+};
+
+/* Should be max of the error string lengths above (plus one for C++) */
+#define LT_ERROR_LEN_MAX (41)
+
+/* These functions are only useful from inside custom module loaders. */
+LT_SCOPE int	lt_dladderror	(const char *diagnostic);
+LT_SCOPE int	lt_dlseterror	(int errorcode);
+
+
+LT_END_C_DECLS
+
+#endif /*!defined(LT_ERROR_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/lt_system.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/lt_system.h	2008-06-16 01:20:02.640625000 -0500
@@ -0,0 +1,154 @@
+/* lt_system.h -- system portability abstraction layer
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#if !defined(LT_SYSTEM_H)
+#define LT_SYSTEM_H 1
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/types.h>
+
+/* Some systems do not define EXIT_*, even with STDC_HEADERS.  */
+#if !defined(EXIT_SUCCESS)
+# define EXIT_SUCCESS 0
+#endif
+#if !defined(EXIT_FAILURE)
+# define EXIT_FAILURE 1
+#endif
+
+/* Just pick a big number... */
+#define LT_FILENAME_MAX 2048
+
+
+/* Saves on those hard to debug '\0' typos....  */
+#define LT_EOS_CHAR	'\0'
+
+/* LTDL_BEGIN_C_DECLS should be used at the beginning of your declarations,
+   so that C++ compilers don't mangle their names.  Use LTDL_END_C_DECLS at
+   the end of C declarations. */
+#if defined(__cplusplus)
+# define LT_BEGIN_C_DECLS	extern "C" {
+# define LT_END_C_DECLS		}
+#else
+# define LT_BEGIN_C_DECLS	/* empty */
+# define LT_END_C_DECLS		/* empty */
+#endif
+
+/* LT_STMT_START/END are used to create macros which expand to a
+   a single compound statement in a portable way.  */
+#if defined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)
+#  define LT_STMT_START        (void)(
+#  define LT_STMT_END          )
+#else
+#  if (defined (sun) || defined (__sun__))
+#    define LT_STMT_START      if (1)
+#    define LT_STMT_END        else (void)0
+#  else
+#    define LT_STMT_START      do
+#    define LT_STMT_END        while (0)
+#  endif
+#endif
+
+/* Canonicalise Windows and Cygwin recognition macros.
+   To match the values set by recent Cygwin compilers, make sure that if
+   __CYGWIN__ is defined (after canonicalisation), __WINDOWS__ is NOT!  */
+#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
+# define __CYGWIN__ __CYGWIN32__
+#endif
+#if defined(__CYGWIN__)
+# if defined(__WINDOWS__)
+#   undef __WINDOWS__
+# endif
+#elif defined(_WIN32)
+# define __WINDOWS__ _WIN32
+#elif defined(WIN32)
+# define __WINDOWS__ WIN32
+#endif
+#if defined(__CYGWIN__) && defined(__WINDOWS__)
+# undef __WINDOWS__
+#endif
+
+
+/* DLL building support on win32 hosts;  mostly to workaround their
+   ridiculous implementation of data symbol exporting. */
+#if !defined(LT_SCOPE)
+#  if defined(__WINDOWS__) || defined(__CYGWIN__)
+#    if defined(DLL_EXPORT)		/* defined by libtool (if required) */
+#      define LT_SCOPE	extern __declspec(dllexport)
+#    endif
+#    if defined(LIBLTDL_DLL_IMPORT)	/* define if linking with this dll */
+       /* note: cygwin/mingw compilers can rely instead on auto-import */
+#      define LT_SCOPE	extern __declspec(dllimport)
+#    endif
+#  endif
+#  if !defined(LT_SCOPE)		/* static linking or !__WINDOWS__ */
+#    define LT_SCOPE	extern
+#  endif
+#endif
+
+#if defined(__WINDOWS__)
+/* LT_DIRSEP_CHAR is accepted *in addition* to '/' as a directory
+   separator when it is set. */
+# define LT_DIRSEP_CHAR		'\\'
+# define LT_PATHSEP_CHAR	';'
+#else
+# define LT_PATHSEP_CHAR	':'
+#endif
+
+#if defined(_MSC_VER) /* Visual Studio */
+#  define R_OK 4
+#endif
+
+/* fopen() mode flags for reading a text file */
+#undef	LT_READTEXT_MODE
+#if defined(__WINDOWS__) || defined(__CYGWIN__)
+#  define LT_READTEXT_MODE "rt"
+#else
+#  define LT_READTEXT_MODE "r"
+#endif
+
+/* The extra indirection to the LT__STR and LT__CONC macros is required so
+   that if the arguments to LT_STR() (or LT_CONC()) are themselves macros,
+   they will be expanded before being quoted.   */
+#ifndef LT_STR
+#  define LT__STR(arg)		#arg
+#  define LT_STR(arg)		LT__STR(arg)
+#endif
+
+#ifndef LT_CONC
+#  define LT__CONC(a, b)	a##b
+#  define LT_CONC(a, b)		LT__CONC(a, b)
+#endif
+#ifndef LT_CONC3
+#  define LT__CONC3(a, b, c)	a##b##c
+#  define LT_CONC3(a, b, c)	LT__CONC3(a, b, c)
+#endif
+
+#endif /*!defined(LT_SYSTEM_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/ltdl.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/ltdl.c	2008-06-16 01:19:16.953125000 -0500
@@ -0,0 +1,2395 @@
+/* ltdl.c -- system independent dlopen wrapper
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
+		 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_system.h"
+#include "lt_dlloader.h"
+
+
+/* --- MANIFEST CONSTANTS --- */
+
+
+/* Standard libltdl search path environment variable name  */
+#undef  LTDL_SEARCHPATH_VAR
+#define LTDL_SEARCHPATH_VAR	"LTDL_LIBRARY_PATH"
+
+/* Standard libtool archive file extension.  */
+#undef  LT_ARCHIVE_EXT
+#define LT_ARCHIVE_EXT	".la"
+
+/* max. filename length */
+#if !defined(LT_FILENAME_MAX)
+#  define LT_FILENAME_MAX	1024
+#endif
+
+/* This is the maximum symbol size that won't require malloc/free */
+#undef	LT_SYMBOL_LENGTH
+#define LT_SYMBOL_LENGTH	128
+
+/* This accounts for the _LTX_ separator */
+#undef	LT_SYMBOL_OVERHEAD
+#define LT_SYMBOL_OVERHEAD	5
+
+/* Various boolean flags can be stored in the flags field of an
+   lt_dlhandle... */
+#define LT_DLIS_RESIDENT(handle)  (((lt__handle*)handle)->info.is_resident)
+#define LT_DLIS_SYMGLOBAL(handle) (((lt__handle*)handle)->info.is_symglobal)
+#define LT_DLIS_SYMLOCAL(handle)  (((lt__handle*)handle)->info.is_symlocal)
+
+
+static	const char	objdir[]		= LT_OBJDIR;
+static	const char	archive_ext[]		= LT_ARCHIVE_EXT;
+#if defined(LT_MODULE_EXT)
+static	const char	shlib_ext[]		= LT_MODULE_EXT;
+#endif
+#if defined(LT_DLSEARCH_PATH)
+static	const char	sys_dlsearch_path[]	= LT_DLSEARCH_PATH;
+#endif
+
+
+
+
+/* --- DYNAMIC MODULE LOADING --- */
+
+
+/* The type of a function used at each iteration of  foreach_dirinpath().  */
+typedef int	foreach_callback_func (char *filename, void *data1,
+				       void *data2);
+/* foreachfile_callback itself calls a function of this type: */
+typedef int	file_worker_func      (const char *filename, void *data);
+
+
+static	int	foreach_dirinpath     (const char *search_path,
+				       const char *base_name,
+				       foreach_callback_func *func,
+				       void *data1, void *data2);
+static	int	find_file_callback    (char *filename, void *data1,
+				       void *data2);
+static	int	find_handle_callback  (char *filename, void *data,
+				       void *ignored);
+static	int	foreachfile_callback  (char *filename, void *data1,
+				       void *data2);
+
+
+static	int     canonicalize_path     (const char *path, char **pcanonical);
+static	int	argzize_path	      (const char *path,
+				       char **pargz, size_t *pargz_len);
+static	FILE   *find_file	      (const char *search_path,
+				       const char *base_name, char **pdir);
+static	lt_dlhandle *find_handle      (const char *search_path,
+				       const char *base_name,
+				       lt_dlhandle *handle,
+				       lt_dladvise advise);
+static	int	find_module	      (lt_dlhandle *handle, const char *dir,
+				       const char *libdir, const char *dlname,
+				       const char *old_name, int installed,
+				       lt_dladvise advise);
+static  int     has_library_ext       (const char *filename);
+static	int	load_deplibs	      (lt_dlhandle handle,  char *deplibs);
+static	int	trim		      (char **dest, const char *str);
+static	int	try_dlopen	      (lt_dlhandle *handle,
+				       const char *filename, const char *ext,
+				       lt_dladvise advise);
+static	int	tryall_dlopen	      (lt_dlhandle *handle,
+				       const char *filename,
+				       lt_dladvise padvise,
+				       const lt_dlvtable *vtable);
+static	int	unload_deplibs	      (lt_dlhandle handle);
+static	int	lt_argz_insert	      (char **pargz, size_t *pargz_len,
+				       char *before, const char *entry);
+static	int	lt_argz_insertinorder (char **pargz, size_t *pargz_len,
+				       const char *entry);
+static	int	lt_argz_insertdir     (char **pargz, size_t *pargz_len,
+				       const char *dirnam, struct dirent *dp);
+static	int	lt_dlpath_insertdir   (char **ppath, char *before,
+				       const char *dir);
+static	int	list_files_by_dir     (const char *dirnam,
+				       char **pargz, size_t *pargz_len);
+static	int	file_not_found	      (void);
+
+#ifdef HAVE_LIBDLLOADER
+static	int	loader_init_callback  (lt_dlhandle handle);
+#endif /* HAVE_LIBDLLOADER */
+
+static	int	loader_init	      (lt_get_vtable *vtable_func,
+				       lt_user_data data);
+
+static	char	       *user_search_path= 0;
+static	lt_dlhandle	handles	= 0;
+static	int		initialized	= 0;
+
+/* Our memory failure callback sets the error message to be passed back
+   up to the client, so we must be careful to return from mallocation
+   callers if allocation fails (as this callback returns!!).  */
+void
+lt__alloc_die_callback (void)
+{
+  LT__SETERROR (NO_MEMORY);
+}
+
+#ifdef HAVE_LIBDLLOADER
+/* This function is called to initialise each preloaded module loader,
+   and hook it into the list of loaders to be used when attempting to
+   dlopen an application module.  */
+static int
+loader_init_callback (lt_dlhandle handle)
+{
+  lt_get_vtable *vtable_func = (lt_get_vtable *) lt_dlsym (handle, "get_vtable");
+  return loader_init (vtable_func, 0);
+}
+#endif /* HAVE_LIBDLLOADER */
+
+static int
+loader_init (lt_get_vtable *vtable_func, lt_user_data data)
+{
+  const lt_dlvtable *vtable = 0;
+  int errors = 0;
+
+  if (vtable_func)
+    {
+      vtable = (*vtable_func) (data);
+    }
+
+  /* lt_dlloader_add will LT__SETERROR if it fails.  */
+  errors += lt_dlloader_add (vtable);
+
+  assert (errors || vtable);
+
+  if ((!errors) && vtable->dlloader_init)
+    {
+      if ((*vtable->dlloader_init) (vtable->dlloader_data))
+	{
+	  LT__SETERROR (INIT_LOADER);
+	  ++errors;
+	}
+    }
+
+  return errors;
+}
+
+/* Bootstrap the loader loading with the preopening loader.  */
+#define get_vtable		preopen_LTX_get_vtable
+#define preloaded_symbols	LT_CONC3(lt_, LTDLOPEN, _LTX_preloaded_symbols)
+
+LT_BEGIN_C_DECLS
+LT_SCOPE const lt_dlvtable *	get_vtable (lt_user_data data);
+LT_END_C_DECLS
+#ifdef HAVE_LIBDLLOADER
+extern lt_dlsymlist		preloaded_symbols;
+#endif
+
+/* Initialize libltdl. */
+int
+lt_dlinit (void)
+{
+  int	errors	= 0;
+
+  /* Initialize only at first call. */
+  if (++initialized == 1)
+    {
+      lt__alloc_die	= lt__alloc_die_callback;
+      handles		= 0;
+      user_search_path	= 0; /* empty search path */
+
+      /* First set up the statically loaded preload module loader, so
+	 we can use it to preopen the other loaders we linked in at
+	 compile time.  */
+      errors += loader_init (get_vtable, 0);
+
+      /* Now open all the preloaded module loaders, so the application
+	 can use _them_ to lt_dlopen its own modules.  */
+#ifdef HAVE_LIBDLLOADER
+      if (!errors)
+	{
+	  errors += lt_dlpreload (&preloaded_symbols);
+	}
+
+      if (!errors)
+	{
+	  errors += lt_dlpreload_open (LT_STR(LTDLOPEN), loader_init_callback);
+	}
+#endif /* HAVE_LIBDLLOADER */
+    }
+
+#ifdef LT_DEBUG_LOADERS
+  lt_dlloader_dump();
+#endif
+
+  return errors;
+}
+
+int
+lt_dlexit (void)
+{
+  /* shut down libltdl */
+  lt_dlloader *loader   = 0;
+  lt__handle  *handle   = (lt__handle *) handles;
+  int	       errors   = 0;
+
+  if (!initialized)
+    {
+      LT__SETERROR (SHUTDOWN);
+      ++errors;
+      goto done;
+    }
+
+  /* shut down only at last call. */
+  if (--initialized == 0)
+    {
+      int	level;
+
+      while (handles && LT_DLIS_RESIDENT (handles))
+	{
+	  handles = ((lt__handle *) handles)->next;
+	}
+
+      /* close all modules */
+      for (level = 1; handle; ++level)
+	{
+	  lt__handle *cur = (lt__handle *) handles;
+	  int saw_nonresident = 0;
+
+	  while (cur)
+	    {
+	      lt__handle *tmp = cur;
+	      cur = cur->next;
+	      if (!LT_DLIS_RESIDENT (tmp))
+		{
+		  saw_nonresident = 1;
+		  if (tmp->info.ref_count <= level)
+		    {
+		      if (lt_dlclose (tmp))
+			{
+			  ++errors;
+			}
+		      /* Make sure that the handle pointed to by 'cur' still exists.
+			 lt_dlclose recursively closes dependent libraries which removes
+			 them from the linked list.  One of these might be the one
+			 pointed to by 'cur'.  */
+		      if (cur)
+			{
+			  for (tmp = (lt__handle *) handles; tmp; tmp = tmp->next)
+			    if (tmp == cur)
+			      break;
+			  if (! tmp)
+			    cur = (lt__handle *) handles;
+			}
+		    }
+		}
+	    }
+	  /* done if only resident modules are left */
+	  if (!saw_nonresident)
+	    break;
+	}
+
+      /* When removing loaders, we can only find out failure by testing
+	 the error string, so avoid a spurious one from an earlier
+	 failed command. */
+      if (!errors)
+	LT__SETERRORSTR (0);
+
+      /* close all loaders */
+      for (loader = (lt_dlloader *) lt_dlloader_next (NULL); loader;)
+	{
+	  lt_dlloader *next   = (lt_dlloader *) lt_dlloader_next (loader);
+	  lt_dlvtable *vtable = (lt_dlvtable *) lt_dlloader_get (loader);
+
+	  if ((vtable = lt_dlloader_remove ((char *) vtable->name)))
+	    {
+	      FREE (vtable);
+	    }
+	  else
+	    {
+	      /* ignore errors due to resident modules */
+	      const char *err;
+	      LT__GETERROR (err);
+	      if (err)
+		++errors;
+	    }
+
+	  loader = next;
+	}
+
+      FREE(user_search_path);
+    }
+
+ done:
+  return errors;
+}
+
+
+/* Try VTABLE or, if VTABLE is NULL, all available loaders for FILENAME.
+   If the library is not successfully loaded, return non-zero.  Otherwise,
+   the dlhandle is stored at the address given in PHANDLE.  */
+static int
+tryall_dlopen (lt_dlhandle *phandle, const char *filename,
+	       lt_dladvise padvise, const lt_dlvtable *vtable)
+{
+  lt__handle *	handle		= (lt__handle *) handles;
+  const char *	saved_error	= 0;
+  int		errors		= 0;
+  lt__advise *  advise		= (lt__advise *) padvise;
+
+#ifdef LT_DEBUG_LOADERS
+  fprintf (stderr, "tryall_dlopen (%s, %s)\n",
+	   filename ? filename : "(null)",
+	   vtable ? vtable->name : "(ALL)");
+#endif
+
+  LT__GETERROR (saved_error);
+
+  /* check whether the module was already opened */
+  for (;handle; handle = handle->next)
+    {
+      if ((handle->info.filename == filename) /* dlopen self: 0 == 0 */
+	  || (handle->info.filename && filename
+	      && streq (handle->info.filename, filename)))
+	{
+	  break;
+	}
+    }
+
+  if (handle)
+    {
+      ++handle->info.ref_count;
+      *phandle = handle;
+      goto done;
+    }
+
+  handle = (lt__handle *) *phandle;
+  if (filename)
+    {
+      /* Comment out the check of file permissions using access.
+	 This call seems to always return -1 with error EACCES.
+      */
+      /* We need to catch missing file errors early so that
+	 file_not_found() can detect what happened.
+      if (access (filename, R_OK) != 0)
+	{
+	  LT__SETERROR (FILE_NOT_FOUND);
+	  ++errors;
+	  goto done;
+	} */
+
+      handle->info.filename = lt__strdup (filename);
+      if (!handle->info.filename)
+	{
+	  ++errors;
+	  goto done;
+	}
+    }
+  else
+    {
+      handle->info.filename = 0;
+    }
+
+  {
+    lt_dlloader loader = lt_dlloader_next (0);
+    const lt_dlvtable *loader_vtable;
+
+    do
+      {
+	if (vtable)
+	  loader_vtable = vtable;
+	else
+	  loader_vtable = lt_dlloader_get (loader);
+
+#ifdef LT_DEBUG_LOADERS
+	fprintf (stderr, "Calling %s->module_open (%s)\n",
+		 (loader_vtable && loader_vtable->name) ? loader_vtable->name : "(null)",
+		 filename ? filename : "(null)");
+#endif
+	handle->module = (*loader_vtable->module_open) (loader_vtable->dlloader_data,
+							filename, advise);
+#ifdef LT_DEBUG_LOADERS
+	fprintf (stderr, "  Result: %s\n",
+		 handle->module ? "Success" : "Failed");
+#endif
+
+	if (handle->module != 0)
+	  {
+	    if (advise)
+	      {
+		handle->info.is_resident  = advise->is_resident;
+		handle->info.is_symglobal = advise->is_symglobal;
+		handle->info.is_symlocal  = advise->is_symlocal;
+	      }
+	    break;
+	  }
+      }
+    while (!vtable && (loader = lt_dlloader_next (loader)));
+
+    /* If VTABLE was given but couldn't open the module, or VTABLE wasn't
+       given but we exhausted all loaders without opening the module, bail
+       out!  */
+    if ((vtable && !handle->module)
+	|| (!vtable && !loader))
+      {
+	FREE (handle->info.filename);
+	++errors;
+	goto done;
+      }
+
+    handle->vtable = loader_vtable;
+  }
+
+  LT__SETERRORSTR (saved_error);
+
+ done:
+  return errors;
+}
+
+
+static int
+tryall_dlopen_module (lt_dlhandle *handle, const char *prefix,
+		      const char *dirname, const char *dlname,
+		      lt_dladvise advise)
+{
+  int      error	= 0;
+  char     *filename	= 0;
+  size_t   filename_len	= 0;
+  size_t   dirname_len	= LT_STRLEN (dirname);
+
+  assert (handle);
+  assert (dirname);
+  assert (dlname);
+#if defined(LT_DIRSEP_CHAR)
+  /* Only canonicalized names (i.e. with DIRSEP chars already converted)
+     should make it into this function:  */
+  assert (strchr (dirname, LT_DIRSEP_CHAR) == 0);
+#endif
+
+  if (dirname_len > 0)
+    if (dirname[dirname_len -1] == '/')
+      --dirname_len;
+  filename_len = dirname_len + 1 + LT_STRLEN (dlname);
+
+  /* Allocate memory, and combine DIRNAME and MODULENAME into it.
+     The PREFIX (if any) is handled below.  */
+  filename  = MALLOC (char, filename_len + 1);
+  if (!filename)
+    return 1;
+
+  sprintf (filename, "%.*s/%s", (int) dirname_len, dirname, dlname);
+
+  /* Now that we have combined DIRNAME and MODULENAME, if there is
+     also a PREFIX to contend with, simply recurse with the arguments
+     shuffled.  Otherwise, attempt to open FILENAME as a module.  */
+  if (prefix)
+    {
+      error += tryall_dlopen_module (handle, (const char *) 0,
+				     prefix, filename, advise);
+    }
+  else if (tryall_dlopen (handle, filename, advise, 0) != 0)
+    {
+      ++error;
+    }
+
+  FREE (filename);
+  return error;
+}
+
+static int
+find_module (lt_dlhandle *handle, const char *dir, const char *libdir,
+	     const char *dlname,  const char *old_name, int installed,
+	     lt_dladvise advise)
+{
+  /* Try to open the old library first; if it was dlpreopened,
+     we want the preopened version of it, even if a dlopenable
+     module is available.  */
+  if (old_name && tryall_dlopen (handle, old_name, advise, 0) == 0)
+    {
+      return 0;
+    }
+
+  /* Try to open the dynamic library.  */
+  if (dlname)
+    {
+      /* try to open the installed module */
+      if (installed && libdir)
+	{
+	  if (tryall_dlopen_module (handle, (const char *) 0,
+				    libdir, dlname, advise) == 0)
+	    return 0;
+	}
+
+      /* try to open the not-installed module */
+      if (!installed)
+	{
+	  if (tryall_dlopen_module (handle, dir, objdir,
+				    dlname, advise) == 0)
+	    return 0;
+	}
+
+      /* maybe it was moved to another directory */
+      {
+	  if (dir && (tryall_dlopen_module (handle, (const char *) 0,
+					    dir, dlname, advise) == 0))
+	    return 0;
+      }
+    }
+
+  return 1;
+}
+
+
+static int
+canonicalize_path (const char *path, char **pcanonical)
+{
+  char *canonical = 0;
+
+  assert (path && *path);
+  assert (pcanonical);
+
+  canonical = MALLOC (char, 1+ LT_STRLEN (path));
+  if (!canonical)
+    return 1;
+
+  {
+    size_t dest = 0;
+    size_t src;
+    for (src = 0; path[src] != LT_EOS_CHAR; ++src)
+      {
+	/* Path separators are not copied to the beginning or end of
+	   the destination, or if another separator would follow
+	   immediately.  */
+	if (path[src] == LT_PATHSEP_CHAR)
+	  {
+	    if ((dest == 0)
+		|| (path[1+ src] == LT_PATHSEP_CHAR)
+		|| (path[1+ src] == LT_EOS_CHAR))
+	      continue;
+	  }
+
+	/* Anything other than a directory separator is copied verbatim.  */
+	if ((path[src] != '/')
+#if defined(LT_DIRSEP_CHAR)
+	    && (path[src] != LT_DIRSEP_CHAR)
+#endif
+	    )
+	  {
+	    canonical[dest++] = path[src];
+	  }
+	/* Directory separators are converted and copied only if they are
+	   not at the end of a path -- i.e. before a path separator or
+	   NULL terminator.  */
+	else if ((path[1+ src] != LT_PATHSEP_CHAR)
+		 && (path[1+ src] != LT_EOS_CHAR)
+#if defined(LT_DIRSEP_CHAR)
+		 && (path[1+ src] != LT_DIRSEP_CHAR)
+#endif
+		 && (path[1+ src] != '/'))
+	  {
+	    canonical[dest++] = '/';
+	  }
+      }
+
+    /* Add an end-of-string marker at the end.  */
+    canonical[dest] = LT_EOS_CHAR;
+  }
+
+  /* Assign new value.  */
+  *pcanonical = canonical;
+
+  return 0;
+}
+
+static int
+argzize_path (const char *path, char **pargz, size_t *pargz_len)
+{
+  error_t error;
+
+  assert (path);
+  assert (pargz);
+  assert (pargz_len);
+
+  if ((error = argz_create_sep (path, LT_PATHSEP_CHAR, pargz, pargz_len)))
+    {
+      switch (error)
+	{
+	case ENOMEM:
+	  LT__SETERROR (NO_MEMORY);
+	  break;
+	default:
+	  LT__SETERROR (UNKNOWN);
+	  break;
+	}
+
+      return 1;
+    }
+
+  return 0;
+}
+
+/* Repeatedly call FUNC with each LT_PATHSEP_CHAR delimited element
+   of SEARCH_PATH and references to DATA1 and DATA2, until FUNC returns
+   non-zero or all elements are exhausted.  If BASE_NAME is non-NULL,
+   it is appended to each SEARCH_PATH element before FUNC is called.  */
+static int
+foreach_dirinpath (const char *search_path, const char *base_name,
+		   foreach_callback_func *func, void *data1, void *data2)
+{
+  int	 result		= 0;
+  size_t filenamesize	= 0;
+  size_t lenbase	= LT_STRLEN (base_name);
+  size_t argz_len	= 0;
+  char *argz		= 0;
+  char *filename	= 0;
+  char *canonical	= 0;
+
+  if (!search_path || !*search_path)
+    {
+      LT__SETERROR (FILE_NOT_FOUND);
+      goto cleanup;
+    }
+
+  if (canonicalize_path (search_path, &canonical) != 0)
+    goto cleanup;
+
+  if (argzize_path (canonical, &argz, &argz_len) != 0)
+    goto cleanup;
+
+  {
+    char *dir_name = 0;
+    while ((dir_name = argz_next (argz, argz_len, dir_name)))
+      {
+	size_t lendir = LT_STRLEN (dir_name);
+
+	if (1+ lendir + lenbase >= filenamesize)
+	{
+	  FREE (filename);
+	  filenamesize	= 1+ lendir + 1+ lenbase; /* "/d" + '/' + "f" + '\0' */
+	  filename	= MALLOC (char, filenamesize);
+	  if (!filename)
+	    goto cleanup;
+	}
+
+	assert (filenamesize > lendir);
+	strcpy (filename, dir_name);
+
+	if (base_name && *base_name)
+	  {
+	    if (filename[lendir -1] != '/')
+	      filename[lendir++] = '/';
+	    strcpy (filename +lendir, base_name);
+	  }
+
+	if ((result = (*func) (filename, data1, data2)))
+	  {
+	    break;
+	  }
+      }
+  }
+
+ cleanup:
+  FREE (argz);
+  FREE (canonical);
+  FREE (filename);
+
+  return result;
+}
+
+/* If FILEPATH can be opened, store the name of the directory component
+   in DATA1, and the opened FILE* structure address in DATA2.  Otherwise
+   DATA1 is unchanged, but DATA2 is set to a pointer to NULL.  */
+static int
+find_file_callback (char *filename, void *data1, void *data2)
+{
+  char	     **pdir	= (char **) data1;
+  FILE	     **pfile	= (FILE **) data2;
+  int	     is_done	= 0;
+
+  assert (filename && *filename);
+  assert (pdir);
+  assert (pfile);
+
+  if ((*pfile = fopen (filename, LT_READTEXT_MODE)))
+    {
+      char *dirend = strrchr (filename, '/');
+
+      if (dirend > filename)
+	*dirend   = LT_EOS_CHAR;
+
+      FREE (*pdir);
+      *pdir   = lt__strdup (filename);
+      is_done = (*pdir == 0) ? -1 : 1;
+    }
+
+  return is_done;
+}
+
+static FILE *
+find_file (const char *search_path, const char *base_name, char **pdir)
+{
+  FILE *file = 0;
+
+  foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);
+
+  return file;
+}
+
+static int
+find_handle_callback (char *filename, void *data, void *data2)
+{
+  lt_dlhandle  *handle		= (lt_dlhandle *) data;
+  int		notfound	= access (filename, R_OK);
+  lt_dladvise   advise		= (lt_dladvise) data2;
+
+  /* Bail out if file cannot be read...  */
+  if (notfound)
+    return 0;
+
+  /* Try to dlopen the file, but do not continue searching in any
+     case.  */
+  if (tryall_dlopen (handle, filename, advise, 0) != 0)
+    *handle = 0;
+
+  return 1;
+}
+
+/* If HANDLE was found return it, otherwise return 0.  If HANDLE was
+   found but could not be opened, *HANDLE will be set to 0.  */
+static lt_dlhandle *
+find_handle (const char *search_path, const char *base_name,
+	     lt_dlhandle *handle, lt_dladvise advise)
+{
+  if (!search_path)
+    return 0;
+
+  if (!foreach_dirinpath (search_path, base_name, find_handle_callback,
+			  handle, advise))
+    return 0;
+
+  return handle;
+}
+
+#if !defined(LTDL_DLOPEN_DEPLIBS)
+static int
+load_deplibs (lt_dlhandle handle, char * LT__UNUSED deplibs)
+{
+  ((lt__handle *) handle)->depcount = 0;
+  return 0;
+}
+
+#else /* defined(LTDL_DLOPEN_DEPLIBS) */
+static int
+load_deplibs (lt_dlhandle handle, char *deplibs)
+{
+  char	*p, *save_search_path = 0;
+  int   depcount = 0;
+  int	i;
+  char	**names = 0;
+  int	errors = 0;
+
+  ((lt__handle *) handle)->depcount = 0;
+
+  if (!deplibs)
+    {
+      return errors;
+    }
+  ++errors;
+
+  if (user_search_path)
+    {
+      save_search_path = lt__strdup (user_search_path);
+      if (!save_search_path)
+	goto cleanup;
+    }
+
+  /* extract search paths and count deplibs */
+  p = deplibs;
+  while (*p)
+    {
+      if (!isspace ((unsigned char) *p))
+	{
+	  char *end = p+1;
+	  while (*end && !isspace((unsigned char) *end))
+	    {
+	      ++end;
+	    }
+
+	  if (strncmp(p, "-L", 2) == 0 || strncmp(p, "-R", 2) == 0)
+	    {
+	      char save = *end;
+	      *end = 0; /* set a temporary string terminator */
+	      if (lt_dladdsearchdir(p+2))
+		{
+		  goto cleanup;
+		}
+	      *end = save;
+	    }
+	  else
+	    {
+	      ++depcount;
+	    }
+
+	  p = end;
+	}
+      else
+	{
+	  ++p;
+	}
+    }
+
+
+  if (!depcount)
+    {
+      errors = 0;
+      goto cleanup;
+    }
+
+  names = MALLOC (char *, depcount);
+  if (!names)
+    goto cleanup;
+
+  /* now only extract the actual deplibs */
+  depcount = 0;
+  p = deplibs;
+  while (*p)
+    {
+      if (isspace ((unsigned char) *p))
+	{
+	  ++p;
+	}
+      else
+	{
+	  char *end = p+1;
+	  while (*end && !isspace ((unsigned char) *end))
+	    {
+	      ++end;
+	    }
+
+	  if (strncmp(p, "-L", 2) != 0 && strncmp(p, "-R", 2) != 0)
+	    {
+	      char *name;
+	      char save = *end;
+	      *end = 0; /* set a temporary string terminator */
+	      if (strncmp(p, "-l", 2) == 0)
+		{
+		  size_t name_len = 3+ /* "lib" */ LT_STRLEN (p + 2);
+		  name = MALLOC (char, 1+ name_len);
+		  if (name)
+		    sprintf (name, "lib%s", p+2);
+		}
+	      else
+		name = lt__strdup(p);
+
+	      if (!name)
+		goto cleanup_names;
+
+	      names[depcount++] = name;
+	      *end = save;
+	    }
+	  p = end;
+	}
+    }
+
+  /* load the deplibs (in reverse order)
+     At this stage, don't worry if the deplibs do not load correctly,
+     they may already be statically linked into the loading application
+     for instance.  There will be a more enlightening error message
+     later on if the loaded module cannot resolve all of its symbols.  */
+  if (depcount)
+    {
+      lt__handle *cur = (lt__handle *) handle;
+      int	j = 0;
+
+      cur->deplibs = (lt_dlhandle *) MALLOC (lt__handle, depcount);
+      if (!cur->deplibs)
+	goto cleanup_names;
+
+      for (i = 0; i < depcount; ++i)
+	{
+	  cur->deplibs[j] = lt_dlopenext(names[depcount-1-i]);
+	  if (cur->deplibs[j])
+	    {
+	      ++j;
+	    }
+	}
+
+      cur->depcount	= j;	/* Number of successfully loaded deplibs */
+      errors		= 0;
+    }
+
+ cleanup_names:
+  for (i = 0; i < depcount; ++i)
+    {
+      FREE (names[i]);
+    }
+
+ cleanup:
+  FREE (names);
+  /* restore the old search path */
+  if (save_search_path) {
+    MEMREASSIGN (user_search_path, save_search_path);
+  }
+
+  return errors;
+}
+#endif /* defined(LTDL_DLOPEN_DEPLIBS) */
+
+static int
+unload_deplibs (lt_dlhandle handle)
+{
+  int i;
+  int errors = 0;
+  lt__handle *cur = (lt__handle *) handle;
+
+  if (cur->depcount)
+    {
+      for (i = 0; i < cur->depcount; ++i)
+	{
+	  if (!LT_DLIS_RESIDENT (cur->deplibs[i]))
+	    {
+	      errors += lt_dlclose (cur->deplibs[i]);
+	    }
+	}
+      FREE (cur->deplibs);
+    }
+
+  return errors;
+}
+
+static int
+trim (char **dest, const char *str)
+{
+  /* remove the leading and trailing "'" from str
+     and store the result in dest */
+  const char *end   = strrchr (str, '\'');
+  size_t len	    = LT_STRLEN (str);
+  char *tmp;
+
+  FREE (*dest);
+
+  if (!end)
+    return 1;
+
+  if (len > 3 && str[0] == '\'')
+    {
+      tmp = MALLOC (char, end - str);
+      if (!tmp)
+	return 1;
+
+      memcpy(tmp, &str[1], (end - str) - 1);
+      tmp[(end - str) - 1] = LT_EOS_CHAR;
+      *dest = tmp;
+    }
+  else
+    {
+      *dest = 0;
+    }
+
+  return 0;
+}
+
+/* Read the .la file FILE. */
+static int
+parse_dotla_file(FILE *file, char **dlname, char **libdir, char **deplibs,
+    char **old_name, int *installed)
+{
+  int		errors = 0;
+  size_t	line_len = LT_FILENAME_MAX;
+  char *	line = MALLOC (char, line_len);
+
+  if (!line)
+    {
+      LT__SETERROR (FILE_NOT_FOUND);
+      return 1;
+    }
+
+  while (!feof (file))
+    {
+      line[line_len-2] = '\0';
+      if (!fgets (line, (int) line_len, file))
+	{
+	  break;
+	}
+
+      /* Handle the case where we occasionally need to read a line
+	 that is longer than the initial buffer size.
+	 Behave even if the file contains NUL bytes due to corruption. */
+      while (line[line_len-2] != '\0' && line[line_len-2] != '\n' && !feof (file))
+	{
+	  line = REALLOC (char, line, line_len *2);
+	  if (!line)
+	    {
+	      ++errors;
+	      goto cleanup;
+	    }
+	  line[line_len * 2 - 2] = '\0';
+	  if (!fgets (&line[line_len -1], (int) line_len +1, file))
+	    {
+	      break;
+	    }
+	  line_len *= 2;
+	}
+
+      if (line[0] == '\n' || line[0] == '#')
+	{
+	  continue;
+	}
+
+#undef  STR_DLNAME
+#define STR_DLNAME	"dlname="
+      if (strncmp (line, STR_DLNAME, sizeof (STR_DLNAME) - 1) == 0)
+	{
+	  errors += trim (dlname, &line[sizeof (STR_DLNAME) - 1]);
+	}
+
+#undef  STR_OLD_LIBRARY
+#define STR_OLD_LIBRARY	"old_library="
+      else if (strncmp (line, STR_OLD_LIBRARY,
+	    sizeof (STR_OLD_LIBRARY) - 1) == 0)
+	{
+	  errors += trim (old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
+	}
+#undef  STR_LIBDIR
+#define STR_LIBDIR	"libdir="
+      else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
+	{
+	  errors += trim (libdir, &line[sizeof(STR_LIBDIR) - 1]);
+	}
+
+#undef  STR_DL_DEPLIBS
+#define STR_DL_DEPLIBS	"dependency_libs="
+      else if (strncmp (line, STR_DL_DEPLIBS,
+	    sizeof (STR_DL_DEPLIBS) - 1) == 0)
+	{
+	  errors += trim (deplibs, &line[sizeof (STR_DL_DEPLIBS) - 1]);
+	}
+      else if (streq (line, "installed=yes\n"))
+	{
+	  *installed = 1;
+	}
+      else if (streq (line, "installed=no\n"))
+	{
+	  *installed = 0;
+	}
+
+#undef  STR_LIBRARY_NAMES
+#define STR_LIBRARY_NAMES "library_names="
+      else if (!*dlname && strncmp (line, STR_LIBRARY_NAMES,
+	    sizeof (STR_LIBRARY_NAMES) - 1) == 0)
+	{
+	  char *last_libname;
+	  errors += trim (dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
+	  if (!errors
+	      && *dlname
+	      && (last_libname = strrchr (*dlname, ' ')) != 0)
+	    {
+	      last_libname = lt__strdup (last_libname + 1);
+	      if (!last_libname)
+		{
+		  ++errors;
+		  goto cleanup;
+		}
+	      MEMREASSIGN (*dlname, last_libname);
+	    }
+	}
+
+      if (errors)
+	break;
+    }
+cleanup:
+  FREE (line);
+  return errors;
+}
+
+
+/* Try to open FILENAME as a module. */
+static int
+try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
+	    lt_dladvise advise)
+{
+  const char *	saved_error	= 0;
+  char *	canonical	= 0;
+  char *	base_name	= 0;
+  char *	dir		= 0;
+  char *	name		= 0;
+  char *        attempt		= 0;
+  int		errors		= 0;
+  lt_dlhandle	newhandle;
+
+  assert (phandle);
+  assert (*phandle == 0);
+
+#ifdef LT_DEBUG_LOADERS
+  fprintf (stderr, "try_dlopen (%s, %s)\n",
+	   filename ? filename : "(null)",
+	   ext ? ext : "(null)");
+#endif
+
+  LT__GETERROR (saved_error);
+
+  /* dlopen self? */
+  if (!filename)
+    {
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
+      if (*phandle == 0)
+	return 1;
+
+      newhandle	= *phandle;
+
+      /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
+      ((lt__handle *) newhandle)->info.is_resident = 1;
+
+      if (tryall_dlopen (&newhandle, 0, advise, 0) != 0)
+	{
+	  FREE (*phandle);
+	  return 1;
+	}
+
+      goto register_handle;
+    }
+
+  assert (filename && *filename);
+
+  if (ext)
+    {
+      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);
+      if (!attempt)
+	return 1;
+
+      sprintf(attempt, "%s%s", filename, ext);
+    }
+  else
+    {
+      attempt = lt__strdup (filename);
+      if (!attempt)
+	return 1;
+    }
+
+  /* Doing this immediately allows internal functions to safely
+     assume only canonicalized paths are passed.  */
+  if (canonicalize_path (attempt, &canonical) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  /* If the canonical module name is a path (relative or absolute)
+     then split it into a directory part and a name part.  */
+  base_name = strrchr (canonical, '/');
+  if (base_name)
+    {
+      size_t dirlen = (1+ base_name) - canonical;
+
+      dir = MALLOC (char, 1+ dirlen);
+      if (!dir)
+	{
+	  ++errors;
+	  goto cleanup;
+	}
+
+      strncpy (dir, canonical, dirlen);
+      dir[dirlen] = LT_EOS_CHAR;
+
+      ++base_name;
+    }
+  else
+    MEMREASSIGN (base_name, canonical);
+
+  assert (base_name && *base_name);
+
+  ext = strrchr (base_name, '.');
+  if (!ext)
+    {
+      ext = base_name + LT_STRLEN (base_name);
+    }
+
+  /* extract the module name from the file name */
+  name = MALLOC (char, ext - base_name + 1);
+  if (!name)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  /* canonicalize the module name */
+  {
+    int i;
+    for (i = 0; i < ext - base_name; ++i)
+      {
+	if (isalnum ((unsigned char)(base_name[i])))
+	  {
+	    name[i] = base_name[i];
+	  }
+	else
+	  {
+	    name[i] = '_';
+	  }
+      }
+    name[ext - base_name] = LT_EOS_CHAR;
+  }
+
+  /* Before trawling through the filesystem in search of a module,
+     check whether we are opening a preloaded module.  */
+  if (!dir)
+    {
+      const lt_dlvtable *vtable	= lt_dlloader_find ("lt_preopen");
+
+      if (vtable)
+	{
+	  *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
+
+	  if (*phandle == NULL)
+	    {
+	      ++errors;
+	      goto cleanup;
+	    }
+	  newhandle = *phandle;
+
+	  if (tryall_dlopen (&newhandle, attempt, advise, vtable) == 0)
+	    {
+	      goto register_handle;
+	    }
+
+	  /* If we're still here, there was no matching preloaded module,
+	     so put things back as we found them, and continue searching.  */
+	  FREE (*phandle);
+	  newhandle = NULL;
+	}
+    }
+
+  /* Check whether we are opening a libtool module (.la extension).  */
+  if (ext && streq (ext, archive_ext))
+    {
+      /* this seems to be a libtool module */
+      FILE *	file	 = 0;
+      char *	dlname	 = 0;
+      char *	old_name = 0;
+      char *	libdir	 = 0;
+      char *	deplibs	 = 0;
+
+      /* if we can't find the installed flag, it is probably an
+	 installed libtool archive, produced with an old version
+	 of libtool */
+      int	installed = 1;
+
+      /* Now try to open the .la file.  If there is no directory name
+	 component, try to find it first in user_search_path and then other
+	 prescribed paths.  Otherwise (or in any case if the module was not
+	 yet found) try opening just the module name as passed.  */
+      if (!dir)
+	{
+	  const char *search_path = user_search_path;
+
+	  if (search_path)
+	    file = find_file (user_search_path, base_name, &dir);
+
+	  if (!file)
+	    {
+	      search_path = getenv (LTDL_SEARCHPATH_VAR);
+	      if (search_path)
+		file = find_file (search_path, base_name, &dir);
+	    }
+
+#if defined(LT_MODULE_PATH_VAR)
+	  if (!file)
+	    {
+	      search_path = getenv (LT_MODULE_PATH_VAR);
+	      if (search_path)
+		file = find_file (search_path, base_name, &dir);
+	    }
+#endif
+#if defined(LT_DLSEARCH_PATH)
+	  if (!file && *sys_dlsearch_path)
+	    {
+	      file = find_file (sys_dlsearch_path, base_name, &dir);
+	    }
+#endif
+	}
+      if (!file)
+	{
+	  file = fopen (attempt, LT_READTEXT_MODE);
+	}
+
+      /* If we didn't find the file by now, it really isn't there.  Set
+	 the status flag, and bail out.  */
+      if (!file)
+	{
+	  LT__SETERROR (FILE_NOT_FOUND);
+	  ++errors;
+	  goto cleanup;
+	}
+
+      /* read the .la file */
+      if (parse_dotla_file(file, &dlname, &libdir, &deplibs,
+	    &old_name, &installed) != 0)
+	++errors;
+
+      fclose (file);
+
+      /* allocate the handle */
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
+      if (*phandle == 0)
+	++errors;
+
+      if (errors)
+	{
+	  FREE (dlname);
+	  FREE (old_name);
+	  FREE (libdir);
+	  FREE (deplibs);
+	  FREE (*phandle);
+	  goto cleanup;
+	}
+
+      assert (*phandle);
+
+      if (load_deplibs (*phandle, deplibs) == 0)
+	{
+	  newhandle = *phandle;
+	  /* find_module may replace newhandle */
+	  if (find_module (&newhandle, dir, libdir, dlname, old_name,
+			   installed, advise))
+	    {
+	      unload_deplibs (*phandle);
+	      ++errors;
+	    }
+	}
+      else
+	{
+	  ++errors;
+	}
+
+      FREE (dlname);
+      FREE (old_name);
+      FREE (libdir);
+      FREE (deplibs);
+
+      if (errors)
+	{
+	  FREE (*phandle);
+	  goto cleanup;
+	}
+
+      if (*phandle != newhandle)
+	{
+	  unload_deplibs (*phandle);
+	}
+    }
+  else
+    {
+      /* not a libtool module */
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
+      if (*phandle == 0)
+	{
+	  ++errors;
+	  goto cleanup;
+	}
+
+      newhandle = *phandle;
+
+      /* If the module has no directory name component, try to find it
+	 first in user_search_path and then other prescribed paths.
+	 Otherwise (or in any case if the module was not yet found) try
+	 opening just the module name as passed.  */
+      if ((dir || (!find_handle (user_search_path, base_name,
+				 &newhandle, advise)
+		   && !find_handle (getenv (LTDL_SEARCHPATH_VAR), base_name,
+				    &newhandle, advise)
+#if defined(LT_MODULE_PATH_VAR)
+		   && !find_handle (getenv (LT_MODULE_PATH_VAR), base_name,
+				    &newhandle, advise)
+#endif
+#if defined(LT_DLSEARCH_PATH)
+		   && !find_handle (sys_dlsearch_path, base_name,
+				    &newhandle, advise)
+#endif
+		   )))
+	{
+	  if (tryall_dlopen (&newhandle, attempt, advise, 0) != 0)
+	    {
+	      newhandle = NULL;
+	    }
+	}
+
+      if (!newhandle)
+	{
+	  FREE (*phandle);
+	  ++errors;
+	  goto cleanup;
+	}
+    }
+
+ register_handle:
+  MEMREASSIGN (*phandle, newhandle);
+
+  if (((lt__handle *) *phandle)->info.ref_count == 0)
+    {
+      ((lt__handle *) *phandle)->info.ref_count	= 1;
+      MEMREASSIGN (((lt__handle *) *phandle)->info.name, name);
+
+      ((lt__handle *) *phandle)->next	= (lt__handle *) handles;
+      handles				= *phandle;
+    }
+
+  LT__SETERRORSTR (saved_error);
+
+ cleanup:
+  FREE (dir);
+  FREE (attempt);
+  FREE (name);
+  if (!canonical)		/* was MEMREASSIGNed */
+    FREE (base_name);
+  FREE (canonical);
+
+  return errors;
+}
+
+
+/* If the last error messge store was `FILE_NOT_FOUND', then return
+   non-zero.  */
+static int
+file_not_found (void)
+{
+  const char *error = 0;
+
+  LT__GETERROR (error);
+  if (error == LT__STRERROR (FILE_NOT_FOUND))
+    return 1;
+
+  return 0;
+}
+
+
+/* Unless FILENAME already bears a suitable library extension, then
+   return 0.  */
+static int
+has_library_ext (const char *filename)
+{
+  char *	ext     = 0;
+
+  assert (filename);
+
+  ext = strrchr (filename, '.');
+
+  if (ext && ((streq (ext, archive_ext))
+#if defined(LT_MODULE_EXT)
+	     || (streq (ext, shlib_ext))
+#endif
+    ))
+    {
+      return 1;
+    }
+
+  return 0;
+}
+
+
+/* Initialise and configure a user lt_dladvise opaque object.  */
+
+int
+lt_dladvise_init (lt_dladvise *padvise)
+{
+  lt__advise *advise = (lt__advise *) lt__zalloc (sizeof (lt__advise));
+  *padvise = advise;
+  return (advise ? 0 : 1);
+}
+
+int
+lt_dladvise_destroy (lt_dladvise *padvise)
+{
+  if (padvise)
+    FREE(*padvise);
+  return 0;
+}
+
+int
+lt_dladvise_ext (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->try_ext = 1;
+  return 0;
+}
+
+int
+lt_dladvise_resident (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_resident = 1;
+  return 0;
+}
+
+int
+lt_dladvise_local (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_symlocal = 1;
+  return 0;
+}
+
+int
+lt_dladvise_global (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_symglobal = 1;
+  return 0;
+}
+
+/* Libtool-1.5.x interface for loading a new module named FILENAME.  */
+lt_dlhandle
+lt_dlopen (const char *filename)
+{
+  return lt_dlopenadvise (filename, NULL);
+}
+
+
+/* If FILENAME has an ARCHIVE_EXT or MODULE_EXT extension, try to
+   open the FILENAME as passed.  Otherwise try appending ARCHIVE_EXT,
+   and if a file is still not found try again with MODULE_EXT appended
+   instead.  */
+lt_dlhandle
+lt_dlopenext (const char *filename)
+{
+  lt_dlhandle	handle	= 0;
+  lt_dladvise	advise;
+
+  if (!lt_dladvise_init (&advise) && !lt_dladvise_ext (&advise))
+    handle = lt_dlopenadvise (filename, advise);
+
+  lt_dladvise_destroy (&advise);
+  return handle;
+}
+
+
+lt_dlhandle
+lt_dlopenadvise (const char *filename, lt_dladvise advise)
+{
+  lt_dlhandle	handle	= 0;
+  int		errors	= 0;
+
+  /* Can't have symbols hidden and visible at the same time!  */
+  if (advise
+      && ((lt__advise *) advise)->is_symlocal
+      && ((lt__advise *) advise)->is_symglobal)
+    {
+      LT__SETERROR (CONFLICTING_FLAGS);
+      return 0;
+    }
+
+  if (!filename
+      || !advise
+      || !((lt__advise *) advise)->try_ext
+      || has_library_ext (filename))
+    {
+      /* Just incase we missed a code path in try_dlopen() that reports
+	 an error, but forgot to reset handle... */
+      if (try_dlopen (&handle, filename, NULL, advise) != 0)
+	return 0;
+
+      return handle;
+    }
+  else if (filename && *filename)
+    {
+
+      /* First try appending ARCHIVE_EXT.  */
+      errors += try_dlopen (&handle, filename, archive_ext, advise);
+
+      /* If we found FILENAME, stop searching -- whether we were able to
+	 load the file as a module or not.  If the file exists but loading
+	 failed, it is better to return an error message here than to
+	 report FILE_NOT_FOUND when the alternatives (foo.so etc) are not
+	 in the module search path.  */
+      if (handle || ((errors > 0) && !file_not_found ()))
+	return handle;
+
+#if defined(LT_MODULE_EXT)
+      /* Try appending SHLIB_EXT.   */
+      errors = try_dlopen (&handle, filename, shlib_ext, advise);
+
+      /* As before, if the file was found but loading failed, return now
+	 with the current error message.  */
+      if (handle || ((errors > 0) && !file_not_found ()))
+	return handle;
+#endif
+    }
+
+  /* Still here?  Then we really did fail to locate any of the file
+     names we tried.  */
+  LT__SETERROR (FILE_NOT_FOUND);
+  return 0;
+}
+
+
+static int
+lt_argz_insert (char **pargz, size_t *pargz_len, char *before,
+		const char *entry)
+{
+  error_t error;
+
+  /* Prior to Sep 8, 2005, newlib had a bug where argz_insert(pargz,
+     pargz_len, NULL, entry) failed with EINVAL.  */
+  if (before)
+    error = argz_insert (pargz, pargz_len, before, entry);
+  else
+    error = argz_append (pargz, pargz_len, entry, 1 + strlen (entry));
+
+  if (error)
+    {
+      switch (error)
+	{
+	case ENOMEM:
+	  LT__SETERROR (NO_MEMORY);
+	  break;
+	default:
+	  LT__SETERROR (UNKNOWN);
+	  break;
+	}
+      return 1;
+    }
+
+  return 0;
+}
+
+static int
+lt_argz_insertinorder (char **pargz, size_t *pargz_len, const char *entry)
+{
+  char *before = 0;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert (entry && *entry);
+
+  if (*pargz)
+    while ((before = argz_next (*pargz, *pargz_len, before)))
+      {
+	int cmp = strcmp (entry, before);
+
+	if (cmp < 0)  break;
+	if (cmp == 0) return 0;	/* No duplicates! */
+      }
+
+  return lt_argz_insert (pargz, pargz_len, before, entry);
+}
+
+static int
+lt_argz_insertdir (char **pargz, size_t *pargz_len, const char *dirnam,
+		   struct dirent *dp)
+{
+  char   *buf	    = 0;
+  size_t buf_len    = 0;
+  char   *end	    = 0;
+  size_t end_offset = 0;
+  size_t dir_len    = 0;
+  int    errors	    = 0;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert (dp);
+
+  dir_len = LT_STRLEN (dirnam);
+  end     = dp->d_name + D_NAMLEN(dp);
+
+  /* Ignore version numbers.  */
+  {
+    char *p;
+    for (p = end; p -1 > dp->d_name; --p)
+      if (strchr (".0123456789", p[-1]) == 0)
+	break;
+
+    if (*p == '.')
+      end = p;
+  }
+
+  /* Ignore filename extension.  */
+  {
+    char *p;
+    for (p = end -1; p > dp->d_name; --p)
+      if (*p == '.')
+	{
+	  end = p;
+	  break;
+	}
+  }
+
+  /* Prepend the directory name.  */
+  end_offset	= end - dp->d_name;
+  buf_len	= dir_len + 1+ end_offset;
+  buf		= MALLOC (char, 1+ buf_len);
+  if (!buf)
+    return ++errors;
+
+  assert (buf);
+
+  strcpy  (buf, dirnam);
+  strcat  (buf, "/");
+  strncat (buf, dp->d_name, end_offset);
+  buf[buf_len] = LT_EOS_CHAR;
+
+  /* Try to insert (in order) into ARGZ/ARGZ_LEN.  */
+  if (lt_argz_insertinorder (pargz, pargz_len, buf) != 0)
+    ++errors;
+
+  FREE (buf);
+
+  return errors;
+}
+
+static int
+list_files_by_dir (const char *dirnam, char **pargz, size_t *pargz_len)
+{
+  DIR	*dirp	  = 0;
+  int    errors	  = 0;
+
+  assert (dirnam && *dirnam);
+  assert (pargz);
+  assert (pargz_len);
+  assert (dirnam[LT_STRLEN(dirnam) -1] != '/');
+
+  dirp = opendir (dirnam);
+  if (dirp)
+    {
+      struct dirent *dp	= 0;
+
+      while ((dp = readdir (dirp)))
+	if (dp->d_name[0] != '.')
+	  if (lt_argz_insertdir (pargz, pargz_len, dirnam, dp))
+	    {
+	      ++errors;
+	      break;
+	    }
+
+      closedir (dirp);
+    }
+  else
+    ++errors;
+
+  return errors;
+}
+
+
+/* If there are any files in DIRNAME, call the function passed in
+   DATA1 (with the name of each file and DATA2 as arguments).  */
+static int
+foreachfile_callback (char *dirname, void *data1, void *data2)
+{
+  file_worker_func *func = *(file_worker_func **) data1;
+
+  int	  is_done  = 0;
+  char   *argz     = 0;
+  size_t  argz_len = 0;
+
+  if (list_files_by_dir (dirname, &argz, &argz_len) != 0)
+    goto cleanup;
+  if (!argz)
+    goto cleanup;
+
+  {
+    char *filename = 0;
+    while ((filename = argz_next (argz, argz_len, filename)))
+      if ((is_done = (*func) (filename, data2)))
+	break;
+  }
+
+ cleanup:
+  FREE (argz);
+
+  return is_done;
+}
+
+
+/* Call FUNC for each unique extensionless file in SEARCH_PATH, along
+   with DATA.  The filenames passed to FUNC would be suitable for
+   passing to lt_dlopenext.  The extensions are stripped so that
+   individual modules do not generate several entries (e.g. libfoo.la,
+   libfoo.so, libfoo.so.1, libfoo.so.1.0.0).  If SEARCH_PATH is NULL,
+   then the same directories that lt_dlopen would search are examined.  */
+int
+lt_dlforeachfile (const char *search_path,
+		  int (*func) (const char *filename, void *data),
+		  void *data)
+{
+  int is_done = 0;
+  file_worker_func **fpptr = &func;
+
+  if (search_path)
+    {
+      /* If a specific path was passed, search only the directories
+	 listed in it.  */
+      is_done = foreach_dirinpath (search_path, 0,
+				   foreachfile_callback, fpptr, data);
+    }
+  else
+    {
+      /* Otherwise search the default paths.  */
+      is_done = foreach_dirinpath (user_search_path, 0,
+				   foreachfile_callback, fpptr, data);
+      if (!is_done)
+	{
+	  is_done = foreach_dirinpath (getenv(LTDL_SEARCHPATH_VAR), 0,
+				       foreachfile_callback, fpptr, data);
+	}
+
+#if defined(LT_MODULE_PATH_VAR)
+      if (!is_done)
+	{
+	  is_done = foreach_dirinpath (getenv(LT_MODULE_PATH_VAR), 0,
+				       foreachfile_callback, fpptr, data);
+	}
+#endif
+#if defined(LT_DLSEARCH_PATH)
+      if (!is_done && *sys_dlsearch_path)
+	{
+	  is_done = foreach_dirinpath (sys_dlsearch_path, 0,
+				       foreachfile_callback, fpptr, data);
+	}
+#endif
+    }
+
+  return is_done;
+}
+
+int
+lt_dlclose (lt_dlhandle handle)
+{
+  lt__handle *cur, *last;
+  int errors = 0;
+
+  /* check whether the handle is valid */
+  last = cur = (lt__handle *) handles;
+  while (cur && handle != cur)
+    {
+      last = cur;
+      cur = cur->next;
+    }
+
+  if (!cur)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      ++errors;
+      goto done;
+    }
+
+  cur = (lt__handle *) handle;
+  cur->info.ref_count--;
+
+  /* Note that even with resident modules, we must track the ref_count
+     correctly incase the user decides to reset the residency flag
+     later (even though the API makes no provision for that at the
+     moment).  */
+  if (cur->info.ref_count <= 0 && !LT_DLIS_RESIDENT (cur))
+    {
+      lt_user_data data = cur->vtable->dlloader_data;
+
+      if (cur != handles)
+	{
+	  last->next = cur->next;
+	}
+      else
+	{
+	  handles = cur->next;
+	}
+
+      errors += cur->vtable->module_close (data, cur->module);
+      errors += unload_deplibs (handle);
+
+      /* It is up to the callers to free the data itself.  */
+      FREE (cur->interface_data);
+
+      FREE (cur->info.filename);
+      FREE (cur->info.name);
+      FREE (cur);
+
+      goto done;
+    }
+
+  if (LT_DLIS_RESIDENT (handle))
+    {
+      LT__SETERROR (CLOSE_RESIDENT_MODULE);
+      ++errors;
+    }
+
+ done:
+  return errors;
+}
+
+void *
+lt_dlsym (lt_dlhandle place, const char *symbol)
+{
+  size_t lensym;
+  char	lsym[LT_SYMBOL_LENGTH];
+  char	*sym;
+  void *address;
+  lt_user_data data;
+  lt__handle *handle;
+
+  if (!place)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      return 0;
+    }
+
+  handle = (lt__handle *) place;
+
+  if (!symbol)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+      return 0;
+    }
+
+  lensym = LT_STRLEN (symbol) + LT_STRLEN (handle->vtable->sym_prefix)
+					+ LT_STRLEN (handle->info.name);
+
+  if (lensym + LT_SYMBOL_OVERHEAD < LT_SYMBOL_LENGTH)
+    {
+      sym = lsym;
+    }
+  else
+    {
+      sym = MALLOC (char, lensym + LT_SYMBOL_OVERHEAD + 1);
+      if (!sym)
+	{
+	  LT__SETERROR (BUFFER_OVERFLOW);
+	  return 0;
+	}
+    }
+
+  data = handle->vtable->dlloader_data;
+  if (handle->info.name)
+    {
+      const char *saved_error;
+
+      LT__GETERROR (saved_error);
+
+      /* this is a libtool module */
+      if (handle->vtable->sym_prefix)
+	{
+	  strcpy(sym, handle->vtable->sym_prefix);
+	  strcat(sym, handle->info.name);
+	}
+      else
+	{
+	  strcpy(sym, handle->info.name);
+	}
+
+      strcat(sym, "_LTX_");
+      strcat(sym, symbol);
+
+      /* try "modulename_LTX_symbol" */
+      address = handle->vtable->find_sym (data, handle->module, sym);
+      if (address)
+	{
+	  if (sym != lsym)
+	    {
+	      FREE (sym);
+	    }
+	  return address;
+	}
+      LT__SETERRORSTR (saved_error);
+    }
+
+  /* otherwise try "symbol" */
+  if (handle->vtable->sym_prefix)
+    {
+      strcpy(sym, handle->vtable->sym_prefix);
+      strcat(sym, symbol);
+    }
+  else
+    {
+      strcpy(sym, symbol);
+    }
+
+  address = handle->vtable->find_sym (data, handle->module, sym);
+  if (sym != lsym)
+    {
+      FREE (sym);
+    }
+
+  return address;
+}
+
+const char *
+lt_dlerror (void)
+{
+  const char *error;
+
+  LT__GETERROR (error);
+  LT__SETERRORSTR (0);
+
+  return error ? error : NULL;
+}
+
+static int
+lt_dlpath_insertdir (char **ppath, char *before, const char *dir)
+{
+  int    errors		= 0;
+  char  *canonical	= 0;
+  char  *argz		= 0;
+  size_t argz_len	= 0;
+
+  assert (ppath);
+  assert (dir && *dir);
+
+  if (canonicalize_path (dir, &canonical) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  assert (canonical && *canonical);
+
+  /* If *PPATH is empty, set it to DIR.  */
+  if (*ppath == 0)
+    {
+      assert (!before);		/* BEFORE cannot be set without PPATH.  */
+      assert (dir);		/* Without DIR, don't call this function!  */
+
+      *ppath = lt__strdup (dir);
+      if (*ppath == 0)
+	++errors;
+
+      goto cleanup;
+    }
+
+  assert (ppath && *ppath);
+
+  if (argzize_path (*ppath, &argz, &argz_len) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  /* Convert BEFORE into an equivalent offset into ARGZ.  This only works
+     if *PPATH is already canonicalized, and hence does not change length
+     with respect to ARGZ.  We canonicalize each entry as it is added to
+     the search path, and don't call this function with (uncanonicalized)
+     user paths, so this is a fair assumption.  */
+  if (before)
+    {
+      assert (*ppath <= before);
+      assert ((int) (before - *ppath) <= (int) strlen (*ppath));
+
+      before = before - *ppath + argz;
+    }
+
+  if (lt_argz_insert (&argz, &argz_len, before, dir) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  argz_stringify (argz, argz_len, LT_PATHSEP_CHAR);
+  MEMREASSIGN(*ppath, argz);
+
+ cleanup:
+  FREE (argz);
+  FREE (canonical);
+
+  return errors;
+}
+
+int
+lt_dladdsearchdir (const char *search_dir)
+{
+  int errors = 0;
+
+  if (search_dir && *search_dir)
+    {
+      if (lt_dlpath_insertdir (&user_search_path, 0, search_dir) != 0)
+	++errors;
+    }
+
+  return errors;
+}
+
+int
+lt_dlinsertsearchdir (const char *before, const char *search_dir)
+{
+  int errors = 0;
+
+  if (before)
+    {
+      if ((before < user_search_path)
+	  || (before >= user_search_path + LT_STRLEN (user_search_path)))
+	{
+	  LT__SETERROR (INVALID_POSITION);
+	  return 1;
+	}
+    }
+
+  if (search_dir && *search_dir)
+    {
+      if (lt_dlpath_insertdir (&user_search_path,
+			       (char *) before, search_dir) != 0)
+	{
+	  ++errors;
+	}
+    }
+
+  return errors;
+}
+
+int
+lt_dlsetsearchpath (const char *search_path)
+{
+  int   errors	    = 0;
+
+  FREE (user_search_path);
+
+  if (!search_path || !LT_STRLEN (search_path))
+    {
+      return errors;
+    }
+
+  if (canonicalize_path (search_path, &user_search_path) != 0)
+    ++errors;
+
+  return errors;
+}
+
+const char *
+lt_dlgetsearchpath (void)
+{
+  const char *saved_path;
+
+  saved_path = user_search_path;
+
+  return saved_path;
+}
+
+int
+lt_dlmakeresident (lt_dlhandle handle)
+{
+  int errors = 0;
+
+  if (!handle)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      ++errors;
+    }
+  else
+    {
+      ((lt__handle *) handle)->info.is_resident = 1;
+    }
+
+  return errors;
+}
+
+int
+lt_dlisresident	(lt_dlhandle handle)
+{
+  if (!handle)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      return -1;
+    }
+
+  return LT_DLIS_RESIDENT (handle);
+}
+
+
+
+/* --- MODULE INFORMATION --- */
+
+typedef struct {
+  const char *id_string;
+  lt_dlhandle_interface *iface;
+} lt__interface_id;
+
+lt_dlinterface_id
+lt_dlinterface_register (const char *id_string, lt_dlhandle_interface *iface)
+{
+  lt__interface_id *interface_id = (lt__interface_id *) lt__malloc (sizeof *interface_id);
+
+  /* If lt__malloc fails, it will LT__SETERROR (NO_MEMORY), which
+     can then be detected with lt_dlerror() if we return 0.  */
+  if (interface_id)
+    {
+      interface_id->id_string = lt__strdup (id_string);
+      if (!interface_id->id_string)
+	FREE (interface_id);
+      else
+	interface_id->iface = iface;
+    }
+
+  return (lt_dlinterface_id) interface_id;
+}
+
+void lt_dlinterface_free (lt_dlinterface_id key)
+{
+  lt__interface_id *interface_id = (lt__interface_id *)key;
+  FREE (interface_id->id_string);
+  FREE (interface_id);
+}
+
+void *
+lt_dlcaller_set_data (lt_dlinterface_id key, lt_dlhandle handle, void *data)
+{
+  int n_elements = 0;
+  void *stale = (void *) 0;
+  lt__handle *cur = (lt__handle *) handle;
+  int i;
+
+  if (cur->interface_data)
+    while (cur->interface_data[n_elements].key)
+      ++n_elements;
+
+  for (i = 0; i < n_elements; ++i)
+    {
+      if (cur->interface_data[i].key == key)
+	{
+	  stale = cur->interface_data[i].data;
+	  break;
+	}
+    }
+
+  /* Ensure that there is enough room in this handle's interface_data
+     array to accept a new element (and an empty end marker).  */
+  if (i == n_elements)
+    {
+      lt_interface_data *temp
+	= REALLOC (lt_interface_data, cur->interface_data, 2+ n_elements);
+
+      if (!temp)
+	{
+	  stale = 0;
+	  goto done;
+	}
+
+      cur->interface_data = temp;
+
+      /* We only need this if we needed to allocate a new interface_data.  */
+      cur->interface_data[i].key	= key;
+      cur->interface_data[1+ i].key	= 0;
+    }
+
+  cur->interface_data[i].data = data;
+
+ done:
+  return stale;
+}
+
+void *
+lt_dlcaller_get_data (lt_dlinterface_id key, lt_dlhandle handle)
+{
+  void *result = (void *) 0;
+  lt__handle *cur = (lt__handle *) handle;
+
+  /* Locate the index of the element with a matching KEY.  */
+  if (cur->interface_data)
+    {
+      int i;
+      for (i = 0; cur->interface_data[i].key; ++i)
+	{
+	  if (cur->interface_data[i].key == key)
+	    {
+	      result = cur->interface_data[i].data;
+	      break;
+	    }
+	}
+    }
+
+  return result;
+}
+
+const lt_dlinfo *
+lt_dlgetinfo (lt_dlhandle handle)
+{
+  if (!handle)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      return 0;
+    }
+
+  return &(((lt__handle *) handle)->info);
+}
+
+
+lt_dlhandle
+lt_dlhandle_iterate (lt_dlinterface_id iface, lt_dlhandle place)
+{
+  lt__handle *handle = (lt__handle *) place;
+  lt__interface_id *iterator = (lt__interface_id *) iface;
+
+  assert (iface); /* iface is a required argument */
+
+  if (!handle)
+    handle = (lt__handle *) handles;
+  else
+    handle = handle->next;
+
+  /* advance while the interface check fails */
+  while (handle && iterator->iface
+	 && ((*iterator->iface) (handle, iterator->id_string) != 0))
+    {
+      handle = handle->next;
+    }
+
+  return (lt_dlhandle) handle;
+}
+
+
+lt_dlhandle
+lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)
+{
+  lt_dlhandle handle = 0;
+
+  assert (iface); /* iface is a required argument */
+
+  while ((handle = lt_dlhandle_iterate (iface, handle)))
+    {
+      lt__handle *cur = (lt__handle *) handle;
+      if (cur && cur->info.name && streq (cur->info.name, module_name))
+	break;
+    }
+
+  return handle;
+}
+
+
+int
+lt_dlhandle_map (lt_dlinterface_id iface,
+		 int (*func) (lt_dlhandle handle, void *data), void *data)
+{
+  lt__interface_id *iterator = (lt__interface_id *) iface;
+  lt__handle *cur = (lt__handle *) handles;
+
+  assert (iface); /* iface is a required argument */
+
+  while (cur)
+    {
+      int errorcode = 0;
+
+      /* advance while the interface check fails */
+      while (cur && iterator->iface
+	     && ((*iterator->iface) (cur, iterator->id_string) != 0))
+	{
+	  cur = cur->next;
+	}
+
+      if ((errorcode = (*func) (cur, data)) != 0)
+	return errorcode;
+    }
+
+  return 0;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/ltdl.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/ltdl.h	2008-06-16 01:19:17.359375000 -0500
@@ -0,0 +1,161 @@
+/* ltdl.h -- generic dlopen functions
+
+   Copyright (C) 1998-2000, 2004, 2005,
+                 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+/* Only include this header file once. */
+#if !defined(LTDL_H)
+#define LTDL_H 1
+
+#include <libltdl/lt_system.h>
+#include <libltdl/lt_error.h>
+#include <libltdl/lt_dlloader.h>
+
+LT_BEGIN_C_DECLS
+
+
+/* LT_STRLEN can be used safely on NULL pointers.  */
+#define LT_STRLEN(s)	(((s) && (s)[0]) ? strlen (s) : 0)
+
+
+/* --- DYNAMIC MODULE LOADING API --- */
+
+
+typedef	void * lt_dlhandle;	/* A loaded module.  */
+
+/* Initialisation and finalisation functions for libltdl. */
+LT_SCOPE int	    lt_dlinit		(void);
+LT_SCOPE int	    lt_dlexit		(void);
+
+/* Module search path manipulation.  */
+LT_SCOPE int	    lt_dladdsearchdir	 (const char *search_dir);
+LT_SCOPE int	    lt_dlinsertsearchdir (const char *before,
+						  const char *search_dir);
+LT_SCOPE int 	    lt_dlsetsearchpath	 (const char *search_path);
+LT_SCOPE const char *lt_dlgetsearchpath	 (void);
+LT_SCOPE int	    lt_dlforeachfile	 (
+			const char *search_path,
+			int (*func) (const char *filename, void *data),
+			void *data);
+
+/* User module loading advisors.  */
+LT_SCOPE int	    lt_dladvise_init	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_destroy  (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_ext	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_resident (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_local	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_global   (lt_dladvise *advise);
+
+/* Portable libltdl versions of the system dlopen() API. */
+LT_SCOPE lt_dlhandle lt_dlopen		(const char *filename);
+LT_SCOPE lt_dlhandle lt_dlopenext	(const char *filename);
+LT_SCOPE lt_dlhandle lt_dlopenadvise	(const char *filename,
+					 lt_dladvise advise);
+LT_SCOPE void *	    lt_dlsym		(lt_dlhandle handle, const char *name);
+LT_SCOPE const char *lt_dlerror		(void);
+LT_SCOPE int	    lt_dlclose		(lt_dlhandle handle);
+
+
+
+/* --- PRELOADED MODULE SUPPORT --- */
+
+
+/* A preopened symbol. Arrays of this type comprise the exported
+   symbols for a dlpreopened module. */
+typedef struct {
+  const char *name;
+  void       *address;
+} lt_dlsymlist;
+
+typedef int lt_dlpreload_callback_func (lt_dlhandle handle);
+
+LT_SCOPE int	lt_dlpreload	     (const lt_dlsymlist *preloaded);
+LT_SCOPE int	lt_dlpreload_default (const lt_dlsymlist *preloaded);
+LT_SCOPE int	lt_dlpreload_open    (const char *originator,
+				      lt_dlpreload_callback_func *func);
+
+#define lt_preloaded_symbols	lt__PROGRAM__LTX_preloaded_symbols
+#define LTDL_SET_PRELOADED_SYMBOLS() 			LT_STMT_START{	\
+	extern const lt_dlsymlist lt_preloaded_symbols[];		\
+	lt_dlpreload_default(lt_preloaded_symbols);			\
+							}LT_STMT_END
+
+
+
+
+/* --- MODULE INFORMATION --- */
+
+
+/* Associating user data with loaded modules. */
+typedef void * lt_dlinterface_id;
+typedef int lt_dlhandle_interface (lt_dlhandle handle, const char *id_string);
+
+LT_SCOPE lt_dlinterface_id lt_dlinterface_register (const char *id_string,
+					  lt_dlhandle_interface *iface);
+LT_SCOPE void	lt_dlinterface_free (lt_dlinterface_id key);
+LT_SCOPE void *	lt_dlcaller_set_data  (lt_dlinterface_id key,
+					  lt_dlhandle handle, void *data);
+LT_SCOPE void *	lt_dlcaller_get_data  (lt_dlinterface_id key,
+					  lt_dlhandle handle);
+
+
+/* Read only information pertaining to a loaded module. */
+typedef	struct {
+  char *	filename;	/* file name */
+  char *	name;		/* module name */
+  int		ref_count;	/* number of times lt_dlopened minus
+				   number of times lt_dlclosed. */
+  unsigned int	is_resident:1;	/* module can't be unloaded. */
+  unsigned int	is_symglobal:1;	/* module symbols can satisfy
+				   subsequently loaded modules.  */
+  unsigned int	is_symlocal:1;	/* module symbols are only available
+				   locally. */
+} lt_dlinfo;
+
+LT_SCOPE const lt_dlinfo *lt_dlgetinfo	    (lt_dlhandle handle);
+
+LT_SCOPE lt_dlhandle	lt_dlhandle_iterate (lt_dlinterface_id iface,
+					     lt_dlhandle place);
+LT_SCOPE lt_dlhandle	lt_dlhandle_fetch   (lt_dlinterface_id iface,
+					     const char *module_name);
+LT_SCOPE int		lt_dlhandle_map	    (lt_dlinterface_id iface,
+				int (*func) (lt_dlhandle handle, void *data),
+				void *data);
+
+
+
+/* Deprecated module residency management API. */
+LT_SCOPE int	    lt_dlmakeresident	(lt_dlhandle handle);
+LT_SCOPE int	    lt_dlisresident	(lt_dlhandle handle);
+
+#define lt_ptr void *
+
+LT_END_C_DECLS
+
+#endif /*!defined(LTDL_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/m4/argz.m4	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/m4/argz.m4	2008-06-16 01:19:00.015625000 -0500
@@ -0,0 +1,79 @@
+# Portability macros for glibc argz.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+#   Written by Gary V. Vaughan <gary@gnu.org>
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 5 argz.m4
+
+AC_DEFUN([gl_FUNC_ARGZ],
+[gl_PREREQ_ARGZ
+
+AC_CHECK_HEADERS([argz.h], [], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_TYPES([error_t],
+  [],
+  [AC_DEFINE([error_t], [int],
+   [Define to a type to use for `error_t' if it is not otherwise available.])
+   AC_DEFINE([__error_t_defined], [1], [Define so that glibc/gnulib argp.h
+    does not typedef error_t.])],
+  [#if defined(HAVE_ARGZ_H)
+#  include <argz.h>
+#endif])
+
+ARGZ_H=
+AC_CHECK_FUNCS([argz_add argz_append argz_count argz_create_sep argz_insert \
+	argz_next argz_stringify], [], [ARGZ_H=argz.h; AC_LIBOBJ([argz])])
+
+dnl if have system argz functions, allow forced use of 
+dnl libltdl-supplied implementation (and default to do so
+dnl on "known bad" systems). Could use a runtime check, but
+dnl (a) detecting malloc issues is notoriously unreliable
+dnl (b) only known system that declares argz functions,
+dnl     provides them, yet they are broken, is cygwin
+dnl     releases prior to 16-Mar-2007 (1.5.24 and earlier)
+dnl So, it's more straightforward simply to special case 
+dnl this for known bad systems.
+AS_IF([test -z "$ARGZ_H"],
+    [AC_CACHE_CHECK(
+        [if argz actually works],
+        [lt_cv_sys_argz_works],
+        [[case $host_os in #(
+	 *cygwin*)
+	   lt_cv_sys_argz_works=no
+	   if test "$cross_compiling" != no; then
+	     lt_cv_sys_argz_works="guessing no"
+	   else
+	     lt_sed_extract_leading_digits='s/^\([0-9\.]*\).*/\1/'
+	     save_IFS=$IFS
+	     IFS=-.
+	     set x `uname -r | sed -e "$lt_sed_extract_leading_digits"`
+	     IFS=$save_IFS
+	     lt_os_major=${2-0}
+	     lt_os_minor=${3-0}
+	     lt_os_micro=${4-0}
+	     if test "$lt_os_major" -gt 1 \
+		|| { test "$lt_os_major" -eq 1 \
+		  && { test "$lt_os_minor" -gt 5 \
+		    || { test "$lt_os_minor" -eq 5 \
+		      && test "$lt_os_micro" -gt 24; }; }; }; then
+	       lt_cv_sys_argz_works=yes
+	     fi
+	   fi
+	   ;; #(
+	 *) lt_cv_sys_argz_works=yes ;;
+	 esac]])
+     AS_IF([test $lt_cv_sys_argz_works = yes],
+        [AC_DEFINE([HAVE_WORKING_ARGZ], 1,
+                   [This value is set to 1 to indicate that the system argz facility works])],
+        [ARGZ_H=argz.h
+        AC_LIBOBJ([argz])])])
+
+AC_SUBST([ARGZ_H])
+])
+
+# Prerequisites of lib/argz.c.
+AC_DEFUN([gl_PREREQ_ARGZ], [:])
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/m4/ltdl.m4	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/m4/ltdl.m4	2008-06-16 01:19:00.921875000 -0500
@@ -0,0 +1,823 @@
+# ltdl.m4 - Configure ltdl for the target system. -*-Autoconf-*-
+#
+#   Copyright (C) 1999-2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Thomas Tanner, 1999
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 14 LTDL_INIT
+
+# LT_CONFIG_LTDL_DIR(DIRECTORY, [LTDL-MODE])
+# ------------------------------------------
+# DIRECTORY contains the libltdl sources.  It is okay to call this
+# function multiple times, as long as the same DIRECTORY is always given.
+AC_DEFUN([LT_CONFIG_LTDL_DIR],
+[AC_BEFORE([$0], [LTDL_INIT])
+_$0($*)
+])# LT_CONFIG_LTDL_DIR
+
+# We break this out into a separate macro, so that we can call it safely
+# internally without being caught accidentally by the sed scan in libtoolize.
+m4_defun([_LT_CONFIG_LTDL_DIR],
+[dnl remove trailing slashes
+m4_pushdef([_ARG_DIR], m4_bpatsubst([$1], [/*$]))
+m4_case(_LTDL_DIR,
+	[], [dnl only set lt_ltdl_dir if _ARG_DIR is not simply `.'
+	     m4_if(_ARG_DIR, [.],
+	             [],
+		 [m4_define([_LTDL_DIR], _ARG_DIR)
+	          _LT_SHELL_INIT([lt_ltdl_dir=']_ARG_DIR['])])],
+    [m4_if(_ARG_DIR, _LTDL_DIR,
+	    [],
+	[m4_fatal([multiple libltdl directories: `]_LTDL_DIR[', `]_ARG_DIR['])])])
+m4_popdef([_ARG_DIR])
+])# _LT_CONFIG_LTDL_DIR
+
+# Initialise:
+m4_define([_LTDL_DIR], [])
+
+
+# _LT_BUILD_PREFIX
+# ----------------
+# If Autoconf is new enough, expand to `${top_build_prefix}', otherwise
+# to `${top_builddir}/'.
+m4_define([_LT_BUILD_PREFIX],
+[m4_ifdef([AC_AUTOCONF_VERSION],
+   [m4_if(m4_version_compare(m4_defn([AC_AUTOCONF_VERSION]), [2.62]),
+	  [-1], [m4_ifdef([_AC_HAVE_TOP_BUILD_PREFIX],
+	  		  [${top_build_prefix}],
+			  [${top_builddir}/])],
+	  [${top_build_prefix}])],
+   [${top_builddir}/])[]dnl
+])
+
+
+# LTDL_CONVENIENCE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl convenience library and
+# LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-convenience to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called here.  LIBLTDL will be prefixed with
+# '${top_build_prefix}' if available, otherwise with '${top_builddir}/',
+# and LTDLINCL will be prefixed with '${top_srcdir}/' (note the single
+# quotes!).  If your package is not flat and you're not using automake,
+# define top_build_prefix, top_builddir, and top_srcdir appropriately
+# in your Makefiles.
+AC_DEFUN([LTDL_CONVENIENCE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_CONVENIENCE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_CONVENIENCE
+
+# AC_LIBLTDL_CONVENIENCE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_CONVENIENCE],
+[_LT_CONFIG_LTDL_DIR([$1])
+_LTDL_CONVENIENCE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_CONVENIENCE], [])
+
+
+# _LTDL_CONVENIENCE
+# -----------------
+# Code shared by LTDL_CONVENIENCE and LTDL_INIT([convenience]).
+m4_defun([_LTDL_CONVENIENCE],
+[case $enable_ltdl_convenience in
+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;
+  "") enable_ltdl_convenience=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-convenience" ;;
+esac
+LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdlc.la"
+LTDLDEPS=$LIBLTDL
+LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# _LTDL_CONVENIENCE
+
+
+# LTDL_INSTALLABLE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl installable library
+# and LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-install to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called from here.  If an installed libltdl
+# is not found, LIBLTDL will be prefixed with '${top_build_prefix}' if
+# available, otherwise with '${top_builddir}/', and LTDLINCL will be
+# prefixed with '${top_srcdir}/' (note the single quotes!).  If your
+# package is not flat and you're not using automake, define top_build_prefix,
+# top_builddir, and top_srcdir appropriately in your Makefiles.
+# In the future, this macro may have to be called after LT_INIT.
+AC_DEFUN([LTDL_INSTALLABLE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_INSTALLABLE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_INSTALLABLE
+
+# AC_LIBLTDL_INSTALLABLE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_INSTALLABLE],
+[_LT_CONFIG_LTDL_DIR([$1])
+_LTDL_INSTALLABLE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_INSTALLABLE], [])
+
+
+# _LTDL_INSTALLABLE
+# -----------------
+# Code shared by LTDL_INSTALLABLE and LTDL_INIT([installable]).
+m4_defun([_LTDL_INSTALLABLE],
+[if test -f $prefix/lib/libltdl.la; then
+  lt_save_LDFLAGS="$LDFLAGS"
+  LDFLAGS="-L$prefix/lib $LDFLAGS"
+  AC_CHECK_LIB([ltdl], [lt_dlinit], [lt_lib_ltdl=yes])
+  LDFLAGS="$lt_save_LDFLAGS"
+  if test x"${lt_lib_ltdl-no}" = xyes; then
+    if test x"$enable_ltdl_install" != xyes; then
+      # Don't overwrite $prefix/lib/libltdl.la without --enable-ltdl-install
+      AC_MSG_WARN([not overwriting libltdl at $prefix, force with `--enable-ltdl-install'])
+      enable_ltdl_install=no
+    fi
+  elif test x"$enable_ltdl_install" = xno; then
+    AC_MSG_WARN([libltdl not installed, but installation disabled])
+  fi
+fi
+
+# If configure.ac declared an installable ltdl, and the user didn't override
+# with --disable-ltdl-install, we will install the shipped libltdl.
+case $enable_ltdl_install in
+  no) ac_configure_args="$ac_configure_args --enable-ltdl-install=no"
+      LIBLTDL="-lltdl"
+      LTDLDEPS=
+      LTDLINCL=
+      ;;
+  *)  enable_ltdl_install=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-install"
+      LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdl.la"
+      LTDLDEPS=$LIBLTDL
+      LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+      ;;
+esac
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# LTDL_INSTALLABLE
+
+
+# _LTDL_MODE_DISPATCH
+# -------------------
+m4_define([_LTDL_MODE_DISPATCH],
+[dnl If _LTDL_DIR is `.', then we are configuring libltdl itself:
+m4_if(_LTDL_DIR, [],
+	[],
+    dnl if _LTDL_MODE was not set already, the default value is `subproject':
+    [m4_case(m4_default(_LTDL_MODE, [subproject]),
+	  [subproject], [AC_CONFIG_SUBDIRS(_LTDL_DIR)
+			  _LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"])],
+	  [nonrecursive], [_LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"; lt_libobj_prefix="$lt_ltdl_dir/"])],
+	  [recursive], [],
+	[m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])dnl
+dnl Be careful not to expand twice:
+m4_define([$0], [])
+])# _LTDL_MODE_DISPATCH
+
+
+# _LT_LIBOBJ(MODULE_NAME)
+# -----------------------
+# Like AC_LIBOBJ, except that MODULE_NAME goes into _LT_LIBOBJS instead
+# of into LIBOBJS.
+AC_DEFUN([_LT_LIBOBJ], [
+  m4_pattern_allow([^_LT_LIBOBJS$])
+  AS_LITERAL_IF([$1], [_LT_LIBSOURCES([$1.c])])dnl
+  _LT_LIBOBJS="$_LT_LIBOBJS $1.$ac_objext"
+])# _LT_LIBOBJS
+
+
+# _LT_LIBSOURCES(MODULE_NAMES)
+# ----------------------------
+# Like AC_LIBSOURCES, except the directory where the libltdl source files
+# are expected is distinct from the user LIBOBJ directory.
+AC_DEFUN([_LT_LIBSOURCES], [
+  m4_foreach([_LTNAME], [$1], [
+    m4_syscmd([test -r "$lt_libobj_prefix]_LTNAME[" ||
+		test -z "$lt_libobj_prefix" ||
+		test ! -d "$lt_libobj_prefix"])dnl
+    m4_if(m4_sysval, [0], [],
+      [AC_FATAL([missing $lt_libobj_prefix/]_LTNAME)])
+  ])
+])# _LT_LIBSOURCES
+
+
+# LTDL_INIT([OPTIONS])
+# --------------------
+# Clients of libltdl can use this macro to allow the installer to
+# choose between a shipped copy of the ltdl sources or a preinstalled
+# version of the library.  If the shipped ltdl sources are not in a
+# subdirectory named libltdl, the directory name must be given by
+# LT_CONFIG_LTDL_DIR.
+AC_DEFUN([LTDL_INIT],
+[dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+dnl We need to keep our own list of libobjs separate from our parent project,
+dnl and the easiest way to do that is redefine the AC_LIBOBJs macro while
+dnl we look for our own LIBOBJs. Definitions in ltdl-libobj.m4.
+m4_pushdef([AC_LIBOBJ], m4_defn([_LT_LIBOBJ]))
+m4_pushdef([AC_LIBSOURCES], m4_defn([_LT_LIBSOURCES]))
+
+dnl If not otherwise defined, default to the 1.5.x compatible subproject mode:
+m4_if(_LTDL_MODE, [],
+        [m4_define([_LTDL_MODE], m4_default([$2], [subproject]))
+        m4_if([-1], [m4_bregexp(_LTDL_MODE, [\(subproject\|\(non\)?recursive\)])],
+                [m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])
+
+AC_ARG_WITH([included_ltdl],
+    [AS_HELP_STRING([--with-included-ltdl],
+                    [use the GNU ltdl sources included here])])
+
+if test "x$with_included_ltdl" != xyes; then
+  # We are not being forced to use the included libltdl sources, so
+  # decide whether there is a useful installed version we can use.
+  AC_CHECK_HEADER([ltdl.h],
+      [AC_CHECK_DECL([lt_dlinterface_register],
+	   [AC_CHECK_LIB([ltdl], [lt_dlinterface_register],
+	       [with_included_ltdl=no],
+	       [with_included_ltdl=yes])],
+	   [with_included_ltdl=yes],
+	   [AC_INCLUDES_DEFAULT
+	    #include <ltdl.h>])],
+      [with_included_ltdl=yes],
+      [AC_INCLUDES_DEFAULT]
+  )
+fi
+
+dnl If neither LT_CONFIG_LTDL_DIR, LTDL_CONVENIENCE nor LTDL_INSTALLABLE
+dnl was called yet, then for old times' sake, we assume libltdl is in an
+dnl eponymous directory:
+AC_PROVIDE_IFELSE([LT_CONFIG_LTDL_DIR], [], [_LT_CONFIG_LTDL_DIR([libltdl])])
+
+AC_ARG_WITH([ltdl_include],
+    [AS_HELP_STRING([--with-ltdl-include=DIR],
+                    [use the ltdl headers installed in DIR])])
+
+if test -n "$with_ltdl_include"; then
+  if test -f "$with_ltdl_include/ltdl.h"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl include directory: `$with_ltdl_include'])
+  fi
+else
+  with_ltdl_include=no
+fi
+
+AC_ARG_WITH([ltdl_lib],
+    [AS_HELP_STRING([--with-ltdl-lib=DIR],
+                    [use the libltdl.la installed in DIR])])
+
+if test -n "$with_ltdl_lib"; then
+  if test -f "$with_ltdl_lib/libltdl.la"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl library directory: `$with_ltdl_lib'])
+  fi
+else
+  with_ltdl_lib=no
+fi
+
+case ,$with_included_ltdl,$with_ltdl_include,$with_ltdl_lib, in
+  ,yes,no,no,)
+	m4_case(m4_default(_LTDL_TYPE, [convenience]),
+	    [convenience], [_LTDL_CONVENIENCE],
+	    [installable], [_LTDL_INSTALLABLE],
+	  [m4_fatal([unknown libltdl build type: ]_LTDL_TYPE)])
+	;;
+  ,no,no,no,)
+	# If the included ltdl is not to be used, then use the
+	# preinstalled libltdl we found.
+	AC_DEFINE([HAVE_LTDL], [1],
+	  [Define this if a modern libltdl is already installed])
+	LIBLTDL=-lltdl
+	LTDLDEPS=
+	LTDLINCL=
+	;;
+  ,no*,no,*)
+	AC_MSG_ERROR([`--with-ltdl-include' and `--with-ltdl-lib' options must be used together])
+	;;
+  *)	with_included_ltdl=no
+	LIBLTDL="-L$with_ltdl_lib -lltdl"
+	LTDLDEPS=
+	LTDLINCL="-I$with_ltdl_include"
+	;;
+esac
+INCLTDL="$LTDLINCL"
+
+# Report our decision...
+AC_MSG_CHECKING([where to find libltdl headers])
+AC_MSG_RESULT([$LTDLINCL])
+AC_MSG_CHECKING([where to find libltdl library])
+AC_MSG_RESULT([$LIBLTDL])
+
+_LTDL_SETUP
+
+dnl restore autoconf definition.
+m4_popdef([AC_LIBOBJ])
+m4_popdef([AC_LIBSOURCES])
+
+AC_CONFIG_COMMANDS_PRE([
+    _ltdl_libobjs=
+    _ltdl_ltlibobjs=
+    if test -n "$_LT_LIBOBJS"; then
+      # Remove the extension.
+      _lt_sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $_LT_LIBOBJS; do echo "$i"; done | sed "$_lt_sed_drop_objext" | sort -u`; do
+        _ltdl_libobjs="$_ltdl_libobjs $lt_libobj_prefix$i.$ac_objext"
+        _ltdl_ltlibobjs="$_ltdl_ltlibobjs $lt_libobj_prefix$i.lo"
+      done
+    fi
+    AC_SUBST([ltdl_LIBOBJS], [$_ltdl_libobjs])
+    AC_SUBST([ltdl_LTLIBOBJS], [$_ltdl_ltlibobjs])
+])
+
+# Only expand once:
+m4_define([LTDL_INIT])
+])# LTDL_INIT
+
+# Old names:
+AU_DEFUN([AC_LIB_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([AC_WITH_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([LT_WITH_LTDL], [LTDL_INIT($@)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIB_LTDL], [])
+dnl AC_DEFUN([AC_WITH_LTDL], [])
+dnl AC_DEFUN([LT_WITH_LTDL], [])
+
+
+# _LTDL_SETUP
+# -----------
+# Perform all the checks necessary for compilation of the ltdl objects
+#  -- including compiler checks and header checks.  This is a public
+# interface  mainly for the benefit of libltdl's own configure.ac, most
+# other users should call LTDL_INIT instead.
+AC_DEFUN([_LTDL_SETUP],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_SYS_MODULE_EXT])dnl
+AC_REQUIRE([LT_SYS_MODULE_PATH])dnl
+AC_REQUIRE([LT_SYS_DLSEARCH_PATH])dnl
+AC_REQUIRE([LT_LIB_DLLOAD])dnl
+AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+AC_REQUIRE([LT_FUNC_DLSYM_USCORE])dnl
+AC_REQUIRE([LT_SYS_DLOPEN_DEPLIBS])dnl
+AC_REQUIRE([gl_FUNC_ARGZ])dnl
+
+m4_require([_LT_CHECK_OBJDIR])dnl
+m4_require([_LT_HEADER_DLFCN])dnl
+m4_require([_LT_CHECK_DLPREOPEN])dnl
+m4_require([_LT_DECL_SED])dnl
+
+# lt_cv_dlopen_self gets defined by LT_SYS_DLOPEN_SELF, called by LT_INIT
+if test "$lt_cv_dlopen_self" = yes; then
+  AC_DEFINE([LTDL_DLOPEN_SELF_WORKS], [1],
+    [Define if dlopen(NULL) is able to resolve symbols from the main program.])
+fi
+
+dnl Don't require this, or it will be expanded earlier than the code
+dnl that sets the variables it relies on:
+_LT_ENABLE_INSTALL
+
+dnl _LTDL_MODE specific code must be called at least once:
+_LTDL_MODE_DISPATCH
+
+# In order that ltdl.c can compile, find out the first AC_CONFIG_HEADERS
+# the user used.  This is so that ltdl.h can pick up the parent projects
+# config.h file, The first file in AC_CONFIG_HEADERS must contain the
+# definitions required by ltdl.c.
+# FIXME: Remove use of undocumented AC_LIST_HEADERS (2.59 compatibility).
+AC_CONFIG_COMMANDS_PRE([dnl
+m4_pattern_allow([^LT_CONFIG_H$])dnl
+m4_ifset([AH_HEADER],
+    [LT_CONFIG_H=AH_HEADER],
+    [m4_ifset([AC_LIST_HEADERS],
+	    [LT_CONFIG_H=`echo "AC_LIST_HEADERS" | $SED 's,^[[      ]]*,,;s,[[ :]].*$,,'`],
+	[])])])
+AC_SUBST([LT_CONFIG_H])
+
+AC_CHECK_HEADERS([unistd.h dl.h sys/dl.h dld.h mach-o/dyld.h dirent.h],
+	[], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_FUNCS([closedir opendir readdir], [], [AC_LIBOBJ([lt__dirent])])
+AC_CHECK_FUNCS([strlcat strlcpy], [], [AC_LIBOBJ([lt__strl])])
+
+name=ltdl
+LTDLOPEN=`eval "\\$ECHO \"$libname_spec\""`
+AC_SUBST([LTDLOPEN])
+])# _LTDL_SETUP
+
+
+# _LT_ENABLE_INSTALL
+# ------------------
+m4_define([_LT_ENABLE_INSTALL],
+[AC_ARG_ENABLE([ltdl-install],
+    [AS_HELP_STRING([--enable-ltdl-install], [install libltdl])])
+
+case ,${enable_ltdl_install},${enable_ltdl_convenience} in
+  *yes*) ;;
+  *) enable_ltdl_convenience=yes ;;
+esac
+
+m4_ifdef([AM_CONDITIONAL],
+[AM_CONDITIONAL(INSTALL_LTDL, test x"${enable_ltdl_install-no}" != xno)
+ AM_CONDITIONAL(CONVENIENCE_LTDL, test x"${enable_ltdl_convenience-no}" != xno)])
+])# _LT_ENABLE_INSTALL
+
+
+# LT_SYS_DLOPEN_DEPLIBS
+# ---------------------
+AC_DEFUN([LT_SYS_DLOPEN_DEPLIBS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_CACHE_CHECK([whether deplibs are loaded by dlopen],
+  [lt_cv_sys_dlopen_deplibs],
+  [# PORTME does your system automatically load deplibs for dlopen?
+  # or its logical equivalent (e.g. shl_load for HP-UX < 11)
+  # For now, we just catch OSes we know something about -- in the
+  # future, we'll try test this programmatically.
+  lt_cv_sys_dlopen_deplibs=unknown
+  case $host_os in
+  aix3*|aix4.1.*|aix4.2.*)
+    # Unknown whether this is true for these versions of AIX, but
+    # we want this `case' here to explicitly catch those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  aix[[4-9]]*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  amigaos*)
+    case $host_cpu in
+    powerpc)
+      lt_cv_sys_dlopen_deplibs=no
+      ;;
+    esac
+    ;;
+  darwin*)
+    # Assuming the user has installed a libdl from somewhere, this is true
+    # If you are looking for one http://www.opendarwin.org/projects/dlcompat
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  freebsd* | dragonfly*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  gnu* | linux* | k*bsd*-gnu)
+    # GNU and its variants, using gnu ld.so (Glibc)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  hpux10*|hpux11*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  interix*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  irix[[12345]]*|irix6.[[01]]*)
+    # Catch all versions of IRIX before 6.2, and indicate that we don't
+    # know how it worked for any of those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  irix*)
+    # The case above catches anything before 6.2, and it's known that
+    # at 6.2 and later dlopen does load deplibs.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  netbsd*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  openbsd*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  osf[[1234]]*)
+    # dlopen did load deplibs (at least at 4.x), but until the 5.x series,
+    # it did *not* use an RPATH in a shared library to find objects the
+    # library depends on, so we explicitly say `no'.
+    lt_cv_sys_dlopen_deplibs=no
+    ;;
+  osf5.0|osf5.0a|osf5.1)
+    # dlopen *does* load deplibs and with the right loader patch applied
+    # it even uses RPATH in a shared library to search for shared objects
+    # that the library depends on, but there's no easy way to know if that
+    # patch is installed.  Since this is the case, all we can really
+    # say is unknown -- it depends on the patch being installed.  If
+    # it is, this changes to `yes'.  Without it, it would be `no'.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  osf*)
+    # the two cases above should catch all versions of osf <= 5.1.  Read
+    # the comments above for what we know about them.
+    # At > 5.1, deplibs are loaded *and* any RPATH in a shared library
+    # is used to find them so we can finally say `yes'.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  qnx*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  solaris*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  esac
+  ])
+if test "$lt_cv_sys_dlopen_deplibs" != yes; then
+ AC_DEFINE([LTDL_DLOPEN_DEPLIBS], [1],
+    [Define if the OS needs help to load dependent libraries for dlopen().])
+fi
+])# LT_SYS_DLOPEN_DEPLIBS
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYS_DLOPEN_DEPLIBS], [LT_SYS_DLOPEN_DEPLIBS])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYS_DLOPEN_DEPLIBS], [])
+
+
+# LT_SYS_MODULE_EXT
+# -----------------
+AC_DEFUN([LT_SYS_MODULE_EXT],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which extension is used for runtime loadable modules],
+  [libltdl_cv_shlibext],
+[
+module=yes
+eval libltdl_cv_shlibext=$shrext_cmds
+  ])
+if test -n "$libltdl_cv_shlibext"; then
+  m4_pattern_allow([LT_MODULE_EXT])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_EXT], ["$libltdl_cv_shlibext"],
+    [Define to the extension used for runtime loadable modules, say, ".so".])
+fi
+])# LT_SYS_MODULE_EXT
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBEXT], [LT_SYS_MODULE_EXT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBEXT], [])
+
+
+# LT_SYS_MODULE_PATH
+# ------------------
+AC_DEFUN([LT_SYS_MODULE_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which variable specifies run-time module search path],
+  [lt_cv_module_path_var], [lt_cv_module_path_var="$shlibpath_var"])
+if test -n "$lt_cv_module_path_var"; then
+  m4_pattern_allow([LT_MODULE_PATH_VAR])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_PATH_VAR], ["$lt_cv_module_path_var"],
+    [Define to the name of the environment variable that determines the run-time module search path.])
+fi
+])# LT_SYS_MODULE_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBPATH], [LT_SYS_MODULE_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBPATH], [])
+
+
+# LT_SYS_DLSEARCH_PATH
+# --------------------
+AC_DEFUN([LT_SYS_DLSEARCH_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([for the default library search path],
+  [lt_cv_sys_dlsearch_path],
+  [lt_cv_sys_dlsearch_path="$sys_lib_dlsearch_path_spec"])
+if test -n "$lt_cv_sys_dlsearch_path"; then
+  sys_dlsearch_path=
+  for dir in $lt_cv_sys_dlsearch_path; do
+    if test -z "$sys_dlsearch_path"; then
+      sys_dlsearch_path="$dir"
+    else
+      sys_dlsearch_path="$sys_dlsearch_path$PATH_SEPARATOR$dir"
+    fi
+  done
+  m4_pattern_allow([LT_DLSEARCH_PATH])dnl
+  AC_DEFINE_UNQUOTED([LT_DLSEARCH_PATH], ["$sys_dlsearch_path"],
+    [Define to the system default library search path.])
+fi
+])# LT_SYS_DLSEARCH_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYSSEARCHPATH], [LT_SYS_DLSEARCH_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYSSEARCHPATH], [])
+
+
+# _LT_CHECK_DLPREOPEN
+# -------------------
+m4_defun([_LT_CHECK_DLPREOPEN],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([whether libtool supports -dlopen/-dlpreopen],
+  [libltdl_cv_preloaded_symbols],
+  [if test -n "$lt_cv_sys_global_symbol_pipe"; then
+    libltdl_cv_preloaded_symbols=yes
+  else
+    libltdl_cv_preloaded_symbols=no
+  fi
+  ])
+if test x"$libltdl_cv_preloaded_symbols" = xyes; then
+  AC_DEFINE([HAVE_PRELOADED_SYMBOLS], [1],
+    [Define if libtool can extract symbol lists from object files.])
+fi
+])# _LT_CHECK_DLPREOPEN
+
+
+# LT_LIB_DLLOAD
+# -------------
+AC_DEFUN([LT_LIB_DLLOAD],
+[m4_pattern_allow([^LT_DLLOADERS$])
+LT_DLLOADERS=
+AC_SUBST([LT_DLLOADERS])
+
+AC_LANG_PUSH([C])
+
+LIBADD_DLOPEN=
+AC_SEARCH_LIBS([dlopen], [dl],
+	[AC_DEFINE([HAVE_LIBDL], [1],
+		   [Define if you have the libdl library or equivalent.])
+	if test "$ac_cv_search_dlopen" != "none required" ; then
+	  LIBADD_DLOPEN="-ldl"
+	fi
+	libltdl_cv_lib_dl_dlopen="yes"
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#if HAVE_DLFCN_H
+#  include <dlfcn.h>
+#endif
+    ]], [[dlopen(0, 0);]])],
+	    [AC_DEFINE([HAVE_LIBDL], [1],
+		       [Define if you have the libdl library or equivalent.])
+	    libltdl_cv_func_dlopen="yes"
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+	[AC_CHECK_LIB([svld], [dlopen],
+		[AC_DEFINE([HAVE_LIBDL], [1],
+			 [Define if you have the libdl library or equivalent.])
+	        LIBADD_DLOPEN="-lsvld" libltdl_cv_func_dlopen="yes"
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"])])])
+if test x"$libltdl_cv_func_dlopen" = xyes || test x"$libltdl_cv_lib_dl_dlopen" = xyes
+then
+  lt_save_LIBS="$LIBS"
+  LIBS="$LIBS $LIBADD_DLOPEN"
+  AC_CHECK_FUNCS([dlerror])
+  LIBS="$lt_save_LIBS"
+fi
+AC_SUBST([LIBADD_DLOPEN])
+
+LIBADD_SHL_LOAD=
+AC_CHECK_FUNC([shl_load],
+	[AC_DEFINE([HAVE_SHL_LOAD], [1],
+		   [Define if you have the shl_load function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"],
+    [AC_CHECK_LIB([dld], [shl_load],
+	    [AC_DEFINE([HAVE_SHL_LOAD], [1],
+		       [Define if you have the shl_load function.])
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"
+	    LIBADD_SHL_LOAD="-ldld"])])
+AC_SUBST([LIBADD_SHL_LOAD])
+
+case $host_os in
+darwin[[1567]].*)
+# We only want this for pre-Mac OS X 10.4.
+  AC_CHECK_FUNC([_dyld_func_lookup],
+	[AC_DEFINE([HAVE_DYLD], [1],
+		   [Define if you have the _dyld_func_lookup function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dyld.la"])
+  ;;
+beos*)
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}load_add_on.la"
+  ;;
+cygwin* | mingw* | os2* | pw32*)
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}loadlibrary.la"
+  ;;
+esac
+
+AC_CHECK_LIB([dld], [dld_link],
+	[AC_DEFINE([HAVE_DLD], [1],
+		   [Define if you have the GNU dld library.])
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dld_link.la"])
+AC_SUBST([LIBADD_DLD_LINK])
+
+m4_pattern_allow([^LT_DLPREOPEN$])
+LT_DLPREOPEN=
+if test -n "$LT_DLLOADERS"
+then
+  for lt_loader in $LT_DLLOADERS; do
+    LT_DLPREOPEN="$LT_DLPREOPEN-dlpreopen $lt_loader "
+  done
+  AC_DEFINE([HAVE_LIBDLLOADER], [1],
+            [Define if libdlloader will be built on this platform])
+fi
+AC_SUBST([LT_DLPREOPEN])
+
+dnl This isn't used anymore, but set it for backwards compatibility
+LIBADD_DL="$LIBADD_DLOPEN $LIBADD_SHL_LOAD"
+AC_SUBST([LIBADD_DL])
+
+AC_LANG_POP
+])# LT_LIB_DLLOAD
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLLIB], [LT_LIB_DLLOAD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLLIB], [])
+
+
+# LT_SYS_SYMBOL_USCORE
+# --------------------
+# does the compiler prefix global symbols with an underscore?
+AC_DEFUN([LT_SYS_SYMBOL_USCORE],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([for _ prefix in compiled symbols],
+  [lt_cv_sys_symbol_underscore],
+  [lt_cv_sys_symbol_underscore=no
+  cat > conftest.$ac_ext <<_LT_EOF
+void nm_test_func(){}
+int main(){nm_test_func;return 0;}
+_LT_EOF
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    ac_nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
+      # See whether the symbols have a leading underscore.
+      if grep '^. _nm_test_func' "$ac_nlist" >/dev/null; then
+        lt_cv_sys_symbol_underscore=yes
+      else
+        if grep '^. nm_test_func ' "$ac_nlist" >/dev/null; then
+	  :
+        else
+	  echo "configure: cannot find nm_test_func in $ac_nlist" >&AS_MESSAGE_LOG_FD
+        fi
+      fi
+    else
+      echo "configure: cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "configure: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.c >&AS_MESSAGE_LOG_FD
+  fi
+  rm -rf conftest*
+  ])
+  sys_symbol_underscore=$lt_cv_sys_symbol_underscore
+  AC_SUBST([sys_symbol_underscore])
+])# LT_SYS_SYMBOL_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYMBOL_USCORE], [LT_SYS_SYMBOL_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYMBOL_USCORE], [])
+
+
+# LT_FUNC_DLSYM_USCORE
+# --------------------
+AC_DEFUN([LT_FUNC_DLSYM_USCORE],
+[AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+if test x"$lt_cv_sys_symbol_underscore" = xyes; then
+  if test x"$libltdl_cv_func_dlopen" = xyes ||
+     test x"$libltdl_cv_lib_dl_dlopen" = xyes ; then
+	AC_CACHE_CHECK([whether we have to add an underscore for dlsym],
+	  [libltdl_cv_need_uscore],
+	  [libltdl_cv_need_uscore=unknown
+          save_LIBS="$LIBS"
+          LIBS="$LIBS $LIBADD_DLOPEN"
+	  _LT_TRY_DLOPEN_SELF(
+	    [libltdl_cv_need_uscore=no], [libltdl_cv_need_uscore=yes],
+	    [],				 [libltdl_cv_need_uscore=cross])
+	  LIBS="$save_LIBS"
+	])
+  fi
+fi
+
+if test x"$libltdl_cv_need_uscore" = xyes; then
+  AC_DEFINE([NEED_USCORE], [1],
+    [Define if dlsym() requires a leading underscore in symbol names.])
+fi
+])# LT_FUNC_DLSYM_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLSYM_USCORE], [LT_FUNC_DLSYM_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLSYM_USCORE], [])
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/slist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/slist.c	2008-06-16 01:19:17.765625000 -0500
@@ -0,0 +1,375 @@
+/* slist.c -- generalised singly linked lists
+
+   Copyright (C) 2000, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2000
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include <assert.h>
+
+#include "slist.h"
+#include <stddef.h>
+
+static SList *	slist_sort_merge    (SList *left, SList *right,
+				     SListCompare *compare, void *userdata);
+
+
+/* Call DELETE repeatedly on each element of HEAD.
+
+   CAVEAT: If you call this when HEAD is the start of a list of boxed
+           items, you must remember that each item passed back to your
+	   DELETE function will be a boxed item that must be slist_unbox()ed
+	   before operating on its contents.
+
+   e.g. void boxed_delete (void *item) { item_free (slist_unbox (item)); }
+        ...
+	  slist = slist_delete (slist, boxed_delete);
+	...
+*/
+SList *
+slist_delete (SList *head, void (*delete_fct) (void *item))
+{
+  assert (delete_fct);
+
+  while (head)
+    {
+      SList *next = head->next;
+      (*delete_fct) (head);
+      head = next;
+    }
+
+  return 0;
+}
+
+/* Call FIND repeatedly with MATCHDATA and each item of *PHEAD, until
+   FIND returns non-NULL, or the list is exhausted.  If a match is found
+   the matching item is destructively removed from *PHEAD, and the value
+   returned by the matching call to FIND is returned.
+
+   CAVEAT: To avoid memory leaks, unless you already have the address of
+           the stale item, you should probably return that from FIND if
+	   it makes a successful match.  Don't forget to slist_unbox()
+	   every item in a boxed list before operating on its contents.   */
+void *
+slist_remove (SList **phead, SListCallback *find, void *matchdata)
+{
+  SList *stale = 0;
+  void *result = 0;
+
+  assert (find);
+
+  if (!phead || !*phead)
+    return 0;
+
+  /* Does the head of the passed list match? */
+  result = (*find) (*phead, matchdata);
+  if (result)
+    {
+      stale = *phead;
+      *phead = stale->next;
+    }
+  /* what about the rest of the elements? */
+  else
+    {
+      SList *head;
+      for (head = *phead; head->next; head = head->next)
+	{
+	  result = (*find) (head->next, matchdata);
+	  if (result)
+	    {
+	      stale		= head->next;
+	      head->next	= stale->next;
+	      break;
+	    }
+	}
+    }
+
+  return result;
+}
+
+/* Call FIND repeatedly with each element of SLIST and MATCHDATA, until
+   FIND returns non-NULL, or the list is exhausted.  If a match is found
+   the value returned by the matching call to FIND is returned. */
+void *
+slist_find (SList *slist, SListCallback *find, void *matchdata)
+{
+  void *result = 0;
+
+  assert (find);
+
+  for (; slist; slist = slist->next)
+    {
+      result = (*find) (slist, matchdata);
+      if (result)
+	break;
+    }
+
+  return result;
+}
+
+/* Return a single list, composed by destructively concatenating the
+   items in HEAD and TAIL.  The values of HEAD and TAIL are undefined
+   after calling this function.
+
+   CAVEAT: Don't mix boxed and unboxed items in a single list.
+
+   e.g.  slist1 = slist_concat (slist1, slist2);  */
+SList *
+slist_concat (SList *head, SList *tail)
+{
+  SList *last;
+
+  if (!head)
+    {
+      return tail;
+    }
+
+  last = head;
+  while (last->next)
+    last = last->next;
+
+  last->next = tail;
+
+  return head;
+}
+
+/* Return a single list, composed by destructively appending all of
+   the items in SLIST to ITEM.  The values of ITEM and SLIST are undefined
+   after calling this function.
+
+   CAVEAT:  Don't mix boxed and unboxed items in a single list.
+
+   e.g.  slist1 = slist_cons (slist_box (data), slist1);  */
+SList *
+slist_cons (SList *item, SList *slist)
+{
+  if (!item)
+    {
+      return slist;
+    }
+
+  assert (!item->next);
+
+  item->next = slist;
+  return item;
+}
+
+/* Return a list starting at the second item of SLIST.  */
+SList *
+slist_tail (SList *slist)
+{
+  return slist ? slist->next : NULL;
+}
+
+/* Return a list starting at the Nth item of SLIST.  If SLIST is less
+   than N items long, NULL is returned.  Just to be confusing, list items
+   are counted from 1, to get the 2nd element of slist:
+
+   e.g. shared_list = slist_nth (slist, 2);  */
+SList *
+slist_nth (SList *slist, size_t n)
+{
+  for (;n > 1 && slist; n--)
+    slist = slist->next;
+
+  return slist;
+}
+
+/* Return the number of items in SLIST.  We start counting from 1, so
+   the length of a list with no items is 0, and so on.  */
+size_t
+slist_length (SList *slist)
+{
+  size_t n;
+
+  for (n = 0; slist; ++n)
+    slist = slist->next;
+
+  return n;
+}
+
+/* Destructively reverse the order of items in SLIST.  The value of SLIST
+   is undefined after calling this function.
+
+  CAVEAT: You must store the result of this function, or you might not
+          be able to get all the items except the first one back again.
+
+  e.g.    slist = slist_reverse (slist);  */
+SList *
+slist_reverse (SList *slist)
+{
+  SList *result = 0;
+  SList *next;
+
+  while (slist)
+    {
+      next		= slist->next;
+      slist->next	= result;
+      result		= slist;
+      slist 		= next;
+    }
+
+  return result;
+}
+
+/* Call FOREACH once for each item in SLIST, passing both the item and
+   USERDATA on each call. */
+void *
+slist_foreach (SList *slist, SListCallback *foreach, void *userdata)
+{
+  void *result = 0;
+
+  assert (foreach);
+
+  while (slist)
+    {
+      SList *next = slist->next;
+      result = (*foreach) (slist, userdata);
+
+      if (result)
+	break;
+
+      slist = next;
+    }
+
+  return result;
+}
+
+/* Destructively merge the items of two ordered lists LEFT and RIGHT,
+   returning a single sorted list containing the items of both --  Part of
+   the quicksort algorithm.  The values of LEFT and RIGHT are undefined
+   after calling this function.
+
+   At each iteration, add another item to the merged list by taking the
+   lowest valued item from the head of either LEFT or RIGHT, determined
+   by passing those items and USERDATA to COMPARE.  COMPARE should return
+   less than 0 if the head of LEFT has the lower value, greater than 0 if
+   the head of RIGHT has the lower value, otherwise 0.  */
+static SList *
+slist_sort_merge (SList *left, SList *right, SListCompare *compare,
+		  void *userdata)
+{
+  SList merged, *insert;
+
+  insert = &merged;
+
+  while (left && right)
+    {
+      if ((*compare) (left, right, userdata) <= 0)
+	{
+	  insert = insert->next = left;
+	  left = left->next;
+	}
+      else
+	{
+	  insert = insert->next = right;
+	  right = right->next;
+	}
+    }
+
+  insert->next = left ? left : right;
+
+  return merged.next;
+}
+
+/* Perform a destructive quicksort on the items in SLIST, by repeatedly
+   calling COMPARE with a pair of items from SLIST along with USERDATA
+   at every iteration.  COMPARE is a function as defined above for
+   slist_sort_merge().  The value of SLIST is undefined after calling
+   this function.
+
+   e.g.  slist = slist_sort (slist, compare, 0);  */
+SList *
+slist_sort (SList *slist, SListCompare *compare, void *userdata)
+{
+  SList *left, *right;
+
+  if (!slist)
+    return slist;
+
+  /* Be sure that LEFT and RIGHT never contain the same item.  */
+  left = slist;
+  right = slist->next;
+
+  /* Skip two items with RIGHT and one with SLIST, until RIGHT falls off
+     the end.  SLIST must be about half way along.  */
+  while (right && (right = right->next))
+    {
+      if (!right || !(right = right->next))
+	break;
+      slist = slist->next;
+    }
+  right = slist->next;
+  slist->next = 0;
+
+  /* Sort LEFT and RIGHT, then merge the two.  */
+  return slist_sort_merge (slist_sort (left, compare, userdata),
+			   slist_sort (right, compare, userdata),
+			   compare, userdata);
+}
+
+
+/* Aside from using the functions above to manage chained structures of
+   any type that has a NEXT pointer as its first field, SLISTs can
+   be comprised of boxed items.  The boxes are chained together in
+   that case, so there is no need for a NEXT field in the item proper.
+   Some care must be taken to slist_box and slist_unbox each item in
+   a boxed list at the appropriate points to avoid leaking the memory
+   used for the boxes.  It us usually a very bad idea to mix boxed and
+   non-boxed items in a single list.  */
+
+/* Return a `boxed' freshly mallocated 1 element list containing
+   USERDATA.  */
+SList *
+slist_box (const void *userdata)
+{
+  SList *item = (SList *) malloc (sizeof *item);
+
+  if (item)
+    {
+      item->next     = 0;
+      item->userdata = userdata;
+    }
+
+  return item;
+}
+
+/* Return the contents of a `boxed' ITEM, recycling the box itself.  */
+void *
+slist_unbox (SList *item)
+{
+  void *userdata = 0;
+
+  if (item)
+    {
+      /* Strip the const, because responsibility for this memory
+	 passes to the caller on return.  */
+      userdata = (void *) item->userdata;
+      free (item);
+    }
+
+  return userdata;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/libltdl/slist.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/libltdl/slist.h	2008-06-16 01:20:03.031250000 -0500
@@ -0,0 +1,94 @@
+/* slist.h -- generalised singly linked lists
+
+   Copyright (C) 2000, 2004 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2000
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+/* A generalised list.  This is deliberately transparent so that you
+   can make the NEXT field of all your chained data structures first,
+   and then cast them to `(SList *)' so that they can be manipulated
+   by this API.
+
+   Alternatively, you can generate raw SList elements using slist_new(),
+   and put the element data in the USERDATA field.  Either way you
+   get to manage the memory involved by yourself.
+*/
+
+#if !defined(SLIST_H)
+#define SLIST_H 1
+
+#if defined(LTDL)
+#  include <libltdl/lt__glibc.h>
+#  include <libltdl/lt_system.h>
+#else
+#  define LT_SCOPE
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct slist {
+  struct slist *next;		/* chain forward pointer*/
+  const void *userdata;		/* for boxed `SList' item */
+} SList;
+
+typedef void *	SListCallback	(SList *item, void *userdata);
+typedef int	SListCompare	(const SList *item1, const SList *item2,
+				 void *userdata);
+
+LT_SCOPE SList *slist_concat	(SList *head, SList *tail);
+LT_SCOPE SList *slist_cons	(SList *item, SList *slist);
+
+LT_SCOPE SList *slist_delete	(SList *slist, void (*delete_fct) (void *item));
+LT_SCOPE void *	slist_remove	(SList **phead, SListCallback *find,
+				 void *matchdata);
+LT_SCOPE SList *slist_reverse	(SList *slist);
+LT_SCOPE SList *slist_sort	(SList *slist, SListCompare *compare,
+				 void *userdata);
+
+LT_SCOPE SList *slist_tail	(SList *slist);
+LT_SCOPE SList *slist_nth	(SList *slist, size_t n);
+LT_SCOPE void *	slist_find	(SList *slist, SListCallback *find,
+				 void *matchdata);
+LT_SCOPE size_t slist_length	(SList *slist);
+
+LT_SCOPE void *	slist_foreach   (SList *slist, SListCallback *foreach,
+				 void *userdata);
+
+LT_SCOPE SList *slist_box	(const void *userdata);
+LT_SCOPE void *	slist_unbox	(SList *item);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#if !defined(LTDL)
+#  undef LT_SCOPE
+#endif
+
+#endif /*!defined(SLIST_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/dld_link.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/dld_link.c	2008-06-16 01:19:57.031250000 -0500
@@ -0,0 +1,158 @@
+/* loader-dld_link.c -- dynamic linking with dld
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dld_link_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dld_link";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DLD_H)
+#  include <dld.h>
+#endif
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module module = lt__strdup (filename);
+
+  if (dld_link (filename) != 0)
+    {
+      LT__SETERROR (CANNOT_OPEN);
+      FREE (module);
+    }
+
+  return module;
+}
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (dld_unlink_by_file ((char*)(module), 1) != 0)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+  else
+    {
+      FREE (module);
+    }
+
+  return errors;
+}
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module LT__UNUSED module,
+	const char *name)
+{
+  void *address = dld_get_func (name);
+
+  if (!address)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/dlopen.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/dlopen.c	2008-06-16 01:19:57.406250000 -0500
@@ -0,0 +1,242 @@
+/* loader-dlopen.c --  dynamic linking with dlopen/dlsym
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dlopen_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dlopen";
+#if defined(DLSYM_USCORE)
+      vtable->sym_prefix	= "_";
+#endif
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_PREPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DLFCN_H)
+#  include <dlfcn.h>
+#endif
+
+#if defined(HAVE_SYS_DL_H)
+#  include <sys/dl.h>
+#endif
+
+
+/* We may have to define LT_LAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#if !defined(LT_LAZY_OR_NOW)
+#  if defined(RTLD_LAZY)
+#    define LT_LAZY_OR_NOW	RTLD_LAZY
+#  else
+#    if defined(DL_LAZY)
+#      define LT_LAZY_OR_NOW	DL_LAZY
+#    endif
+#  endif /* !RTLD_LAZY */
+#endif
+#if !defined(LT_LAZY_OR_NOW)
+#  if defined(RTLD_NOW)
+#    define LT_LAZY_OR_NOW	RTLD_NOW
+#  else
+#    if defined(DL_NOW)
+#      define LT_LAZY_OR_NOW	DL_NOW
+#    endif
+#  endif /* !RTLD_NOW */
+#endif
+#if !defined(LT_LAZY_OR_NOW)
+#  define LT_LAZY_OR_NOW	0
+#endif /* !LT_LAZY_OR_NOW */
+
+/* We only support local and global symbols from modules for loaders
+   that provide such a thing, otherwise the system default is used.  */
+#if !defined(RTLD_GLOBAL)
+#  if defined(DL_GLOBAL)
+#    define RTLD_GLOBAL		DL_GLOBAL
+#  endif
+#endif /* !RTLD_GLOBAL */
+#if !defined(RTLD_LOCAL)
+#  if defined(DL_LOCAL)
+#    define RTLD_LOCAL		DL_LOCAL
+#  endif
+#endif /* !RTLD_LOCAL */
+
+#if defined(HAVE_DLERROR)
+#  define DLERROR(arg)	dlerror ()
+#else
+#  define DLERROR(arg)	LT__STRERROR (arg)
+#endif
+
+#define DL__SETERROR(errorcode) \
+	LT__SETERRORSTR (DLERROR (errorcode))
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise advise)
+{
+  int		module_flags = LT_LAZY_OR_NOW;
+  lt_module	module;
+
+  if (advise)
+    {
+#ifdef RTLD_GLOBAL
+      /* If there is some means of asking for global symbol resolution,
+         do so.  */
+      if (((lt__advise *) advise)->is_symglobal)
+        module_flags |= RTLD_GLOBAL;
+#else
+      /* Otherwise, reset that bit so the caller can tell it wasn't
+         acted on.  */
+      ((lt__advise *) advise)->is_symglobal = 0;
+#endif
+
+/* And similarly for local only symbol resolution.  */
+#ifdef RTLD_LOCAL
+      if (((lt__advise *) advise)->is_symlocal)
+        module_flags |= RTLD_LOCAL;
+#else
+      ((lt__advise *) advise)->is_symlocal = 0;
+#endif
+    }
+
+  /* On AIX, dlopen(NULL) succeeds but dlsym of symbols fails.
+     In this case, fail here to let the preopen loader do the job. */
+#ifndef LTDL_DLOPEN_SELF_WORKS
+  if (!filename)
+    module = NULL;
+  else
+#endif
+    module = dlopen (filename, module_flags);
+
+  if (!module)
+    {
+      DL__SETERROR (CANNOT_OPEN);
+    }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (dlclose (module) != 0)
+    {
+      DL__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = dlsym (module, name);
+
+  if (!address)
+    {
+      DL__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/dyld.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/dyld.c	2008-06-16 01:19:57.765625000 -0500
@@ -0,0 +1,511 @@
+/* loader-dyld.c -- dynamic linking on darwin and OS X
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Peter O'Gorman, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	dyld_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_init  (lt_user_data loader_data);
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_dyld";
+      vtable->sym_prefix	= "_";
+      vtable->dlloader_init	= vl_init;
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_MACH_O_DYLD_H)
+#  if !defined(__APPLE_CC__) && !defined(__MWERKS__) && !defined(__private_extern__)
+  /* Is this correct? Does it still function properly? */
+#    define __private_extern__ extern
+#  endif
+#  include <mach-o/dyld.h>
+#endif
+
+#include <mach-o/getsect.h>
+
+/* We have to put some stuff here that isn't in older dyld.h files */
+#if !defined(ENUM_DYLD_BOOL)
+# define ENUM_DYLD_BOOL
+# undef FALSE
+# undef TRUE
+ enum DYLD_BOOL {
+    FALSE,
+    TRUE
+ };
+#endif
+#if !defined(LC_REQ_DYLD)
+# define LC_REQ_DYLD 0x80000000
+#endif
+#if !defined(LC_LOAD_WEAK_DYLIB)
+# define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)
+#endif
+
+#if !defined(NSADDIMAGE_OPTION_NONE)
+#  define NSADDIMAGE_OPTION_NONE                          0x0
+#endif
+#if !defined(NSADDIMAGE_OPTION_RETURN_ON_ERROR)
+#  define NSADDIMAGE_OPTION_RETURN_ON_ERROR               0x1
+#endif
+#if !defined(NSADDIMAGE_OPTION_WITH_SEARCHING)
+#  define NSADDIMAGE_OPTION_WITH_SEARCHING                0x2
+#endif
+#if !defined(NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED)
+#  define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED         0x4
+#endif
+#if !defined(NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME)
+#  define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8
+#endif
+
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND               0x0
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW           0x1
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY         0x2
+#endif
+#if !defined(NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR)
+#  define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR    0x4
+#endif
+
+#define LT__SYMLOOKUP_OPTS	(NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW \
+				| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR)
+
+#if defined(__BIG_ENDIAN__)
+#  define LT__MAGIC	MH_MAGIC
+#else
+#  define LT__MAGIC	MH_CIGAM
+#endif
+
+#define DYLD__SETMYERROR(errmsg)    LT__SETERRORSTR (dylderror (errmsg))
+#define DYLD__SETERROR(errcode)	    DYLD__SETMYERROR (LT__STRERROR (errcode))
+
+typedef struct mach_header mach_header;
+typedef struct dylib_command dylib_command;
+
+static const char *dylderror (const char *errmsg);
+static const mach_header *lt__nsmodule_get_header (NSModule module);
+static const char *lt__header_get_instnam (const mach_header *mh);
+static const mach_header *lt__match_loadedlib (const char *name);
+static NSSymbol lt__linkedlib_symbol (const char *symname, const mach_header *mh);
+
+static const mach_header *(*lt__addimage)	(const char *image_name,
+						 unsigned long options) = 0;
+static NSSymbol	(*lt__image_symbol)		(const mach_header *image,
+						 const char *symbolName,
+						 unsigned long options) = 0;
+static enum DYLD_BOOL (*lt__image_symbol_p)	(const mach_header *image,
+						 const char *symbolName) = 0;
+static enum DYLD_BOOL (*lt__module_export)	(NSModule module) = 0;
+
+static int dyld_cannot_close				  = 0;
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to initialise this loader.  */
+static int
+vl_init (lt_user_data loader_data)
+{
+  int errors = 0;
+
+  if (! dyld_cannot_close)
+    {
+      if (!_dyld_present ())
+	{
+	  ++errors;
+	}
+      else
+	{
+	  (void) _dyld_func_lookup ("__dyld_NSAddImage",
+				    (unsigned long*) &lt__addimage);
+	  (void) _dyld_func_lookup ("__dyld_NSLookupSymbolInImage",
+				    (unsigned long*)&lt__image_symbol);
+	  (void) _dyld_func_lookup ("__dyld_NSIsSymbolNameDefinedInImage",
+				    (unsigned long*) &lt__image_symbol_p);
+	  (void) _dyld_func_lookup ("__dyld_NSMakePrivateModulePublic",
+				    (unsigned long*) &lt__module_export);
+	  dyld_cannot_close = lt_dladderror ("can't close a dylib");
+	}
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module module = 0;
+  NSObjectFileImage ofi = 0;
+
+  if (!filename)
+    {
+      return (lt_module) -1;
+    }
+
+  switch (NSCreateObjectFileImageFromFile (filename, &ofi))
+    {
+    case NSObjectFileImageSuccess:
+      module = NSLinkModule (ofi, filename, NSLINKMODULE_OPTION_RETURN_ON_ERROR
+			     		    | NSLINKMODULE_OPTION_PRIVATE
+			     		    | NSLINKMODULE_OPTION_BINDNOW);
+      NSDestroyObjectFileImage (ofi);
+
+      if (module)
+	{
+	  lt__module_export (module);
+	}
+      break;
+
+    case NSObjectFileImageInappropriateFile:
+      if (lt__image_symbol_p && lt__image_symbol)
+	{
+	  module = (lt_module) lt__addimage(filename,
+					    NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+	}
+      break;
+
+    case NSObjectFileImageFailure:
+    case NSObjectFileImageArch:
+    case NSObjectFileImageFormat:
+    case NSObjectFileImageAccess:
+      /*NOWORK*/
+      break;
+    }
+
+  if (!module)
+    {
+      DYLD__SETERROR (CANNOT_OPEN);
+    }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (module != (lt_module) -1)
+    {
+      const mach_header *mh = (const mach_header *) module;
+      int flags = 0;
+      if (mh->magic == LT__MAGIC)
+	{
+	  lt_dlseterror (dyld_cannot_close);
+	  ++errors;
+	}
+      else
+	{
+	  /* Currently, if a module contains c++ static destructors and it
+	     is unloaded, we get a segfault in atexit(), due to compiler and
+	     dynamic loader differences of opinion, this works around that.  */
+	  if ((const struct section *) NULL !=
+	      getsectbynamefromheader (lt__nsmodule_get_header (module),
+				       "__DATA", "__mod_term_func"))
+	    {
+	      flags |= NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
+	    }
+#if defined(__ppc__)
+	  flags |= NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
+#endif
+	  if (!NSUnLinkModule (module, flags))
+	    {
+	      DYLD__SETERROR (CANNOT_CLOSE);
+	      ++errors;
+	    }
+	}
+    }
+
+  return errors;
+}
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data loader_data, lt_module module, const char *name)
+{
+  NSSymbol *nssym = 0;
+  const mach_header *mh = (const mach_header *) module;
+  char saveError[256] = "Symbol not found";
+
+  if (module == (lt_module) -1)
+    {
+      void *address, *unused;
+      _dyld_lookup_and_bind (name, (unsigned long*) &address, &unused);
+      return address;
+    }
+
+  if (mh->magic == LT__MAGIC)
+    {
+      if (lt__image_symbol_p && lt__image_symbol)
+	{
+	  if (lt__image_symbol_p (mh, name))
+	    {
+	      nssym = lt__image_symbol (mh, name, LT__SYMLOOKUP_OPTS);
+	    }
+	}
+
+    }
+  else
+    {
+      nssym = NSLookupSymbolInModule (module, name);
+    }
+
+  if (!nssym)
+    {
+      strncpy (saveError, dylderror (LT__STRERROR (SYMBOL_NOT_FOUND)), 255);
+      saveError[255] = 0;
+      if (!mh)
+	{
+	  mh = (mach_header *)lt__nsmodule_get_header (module);
+	}
+      nssym = lt__linkedlib_symbol (name, mh);
+    }
+
+  if (!nssym)
+    {
+      LT__SETERRORSTR (saveError);
+    }
+
+  return nssym ? NSAddressOfSymbol (nssym) : 0;
+}
+
+
+
+
+/* --- HELPER FUNCTIONS --- */
+
+
+/* Return the dyld error string, or the passed in error string if none. */
+static const char *
+dylderror (const char *errmsg)
+{
+  NSLinkEditErrors ler;
+  int lerno;
+  const char *file;
+  const char *errstr;
+
+  NSLinkEditError (&ler, &lerno, &file, &errstr);
+
+  if (! (errstr && *errstr))
+    {
+      errstr = errmsg;
+    }
+
+  return errstr;
+}
+
+/* There should probably be an apple dyld api for this. */
+static const mach_header *
+lt__nsmodule_get_header (NSModule module)
+{
+  int i = _dyld_image_count();
+  const char *modname = NSNameOfModule (module);
+  const mach_header *mh = 0;
+
+  if (!modname)
+    return NULL;
+
+  while (i > 0)
+    {
+      --i;
+      if (strneq (_dyld_get_image_name (i), modname))
+	{
+	  mh = _dyld_get_image_header (i);
+	  break;
+	}
+    }
+
+  return mh;
+}
+
+/* NSAddImage is also used to get the loaded image, but it only works if
+   the lib is installed, for uninstalled libs we need to check the
+   install_names against each other.  Note that this is still broken if
+   DYLD_IMAGE_SUFFIX is set and a different lib was loaded as a result.  */
+static const char *
+lt__header_get_instnam (const mach_header *mh)
+{
+  unsigned long offset = sizeof(mach_header);
+  const char* result   = 0;
+  int j;
+
+  for (j = 0; j < mh->ncmds; j++)
+    {
+      struct load_command *lc;
+
+      lc = (struct load_command*) (((unsigned long) mh) + offset);
+      if (LC_ID_DYLIB == lc->cmd)
+	{
+	  result=(char*)(((dylib_command*) lc)->dylib.name.offset +
+			 (unsigned long) lc);
+	}
+      offset += lc->cmdsize;
+    }
+
+  return result;
+}
+
+static const mach_header *
+lt__match_loadedlib (const char *name)
+{
+  const mach_header *mh	= 0;
+  int i = _dyld_image_count();
+
+  while (i > 0)
+    {
+      const char *id;
+
+      --i;
+      id = lt__header_get_instnam (_dyld_get_image_header (i));
+      if (id && strneq (id, name))
+	{
+	  mh = _dyld_get_image_header (i);
+	  break;
+	}
+    }
+
+  return mh;
+}
+
+/* Safe to assume our mh is good. */
+static NSSymbol
+lt__linkedlib_symbol (const char *symname, const mach_header *mh)
+{
+  NSSymbol symbol = 0;
+
+  if (lt__image_symbol && NSIsSymbolNameDefined (symname))
+    {
+      unsigned long offset = sizeof(mach_header);
+      struct load_command *lc;
+      int j;
+
+      for (j = 0; j < mh->ncmds; j++)
+	{
+	  lc = (struct load_command*) (((unsigned long) mh) + offset);
+	  if ((LC_LOAD_DYLIB == lc->cmd) || (LC_LOAD_WEAK_DYLIB == lc->cmd))
+	    {
+	      unsigned long base = ((dylib_command *) lc)->dylib.name.offset;
+	      char *name = (char *) (base + (unsigned long) lc);
+	      const mach_header *mh1 = lt__match_loadedlib (name);
+
+	      if (!mh1)
+		{
+		  /* Maybe NSAddImage can find it */
+		  mh1 = lt__addimage (name,
+				      NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED
+				      | NSADDIMAGE_OPTION_WITH_SEARCHING
+				      | NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+		}
+
+	      if (mh1)
+		{
+		  symbol = lt__image_symbol (mh1, symname, LT__SYMLOOKUP_OPTS);
+		  if (symbol)
+		    break;
+		}
+	    }
+
+	  offset += lc->cmdsize;
+	}
+    }
+
+  return symbol;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/load_add_on.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/load_add_on.c	2008-06-16 01:19:58.109375000 -0500
@@ -0,0 +1,167 @@
+/* loader-load_add_on.c --  dynamic linking for BeOS
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	load_add_on_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_load_add_on";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#include <kernel/image.h>
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  image_id image = 0;
+
+  if (filename)
+    {
+      image = load_add_on (filename);
+    }
+  else
+    {
+      image_info info;
+      int32 cookie = 0;
+      if (get_next_image_info (0, &cookie, &info) == B_OK)
+	image = load_add_on (info.name);
+    }
+
+  if (image <= 0)
+    {
+      LT__SETERROR (CANNOT_OPEN);
+      image = 0;
+    }
+
+  return (lt_module) image;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (unload_add_on ((image_id) module) != B_OK)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = 0;
+  image_id image = (image_id) module;
+
+  if (get_image_symbol (image, name, B_SYMBOL_TYPE_ANY, address) != B_OK)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+      address = 0;
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/loadlibrary.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/loadlibrary.c	2008-06-16 01:19:58.500000000 -0500
@@ -0,0 +1,244 @@
+/* loader-loadlibrary.c --  dynamic linking for Win32
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+#if defined(__CYGWIN__)
+# include <sys/cygwin.h>
+#endif
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	loadlibrary_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlinterface_id iface_id = 0;
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+      iface_id = lt_dlinterface_register ("ltdl loadlibrary", NULL);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_loadlibrary";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#include <windows.h>
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  lt_module	module	   = 0;
+  char		*ext;
+  char		wpath[MAX_PATH];
+  size_t	len;
+
+  if (!filename)
+    {
+      /* Get the name of main module */
+      *wpath = 0;
+      GetModuleFileName (NULL, wpath, sizeof (wpath));
+      filename = wpath;
+    }
+  else
+    {
+      len = LT_STRLEN (filename);
+
+      if (len >= MAX_PATH)
+        {
+	  LT__SETERROR (CANNOT_OPEN);
+	  return 0;
+	}
+
+#if defined(__CYGWIN__)
+      cygwin_conv_to_full_win32_path (filename, wpath);
+      len = 0;
+#else
+      strcpy(wpath, filename);
+#endif
+
+      ext = strrchr (wpath, '.');
+      if (!ext)
+	{
+	  /* Append a `.' to stop Windows from adding an
+	     implicit `.dll' extension. */
+	  if (!len)
+	    len = LT_STRLEN (wpath);
+
+	  if (len + 1 >= MAX_PATH)
+	    {
+	      LT__SETERROR (CANNOT_OPEN);
+	      return 0;
+	    }
+
+	  wpath[len] = '.';
+	  wpath[len+1] = '\0';
+	}
+    }
+
+  {
+    /* Silence dialog from LoadLibrary on some failures.
+       No way to get the error mode, but to set it,
+       so set it twice to preserve any previous flags. */
+    UINT errormode = SetErrorMode(SEM_FAILCRITICALERRORS);
+    SetErrorMode(errormode | SEM_FAILCRITICALERRORS);
+
+    module = LoadLibrary (wpath);
+
+    /* Restore the error mode. */
+    SetErrorMode(errormode);
+  }
+
+  /* libltdl expects this function to fail if it is unable
+     to physically load the library.  Sadly, LoadLibrary
+     will search the loaded libraries for a match and return
+     one of them if the path search load fails.
+
+     We check whether LoadLibrary is returning a handle to
+     an already loaded module, and simulate failure if we
+     find one. */
+  {
+    lt__handle *        cur        = 0;
+
+    while ((cur = (lt__handle *) lt_dlhandle_iterate (iface_id, (lt_dlhandle) cur)))
+      {
+        if (!cur->module)
+          {
+            cur = 0;
+            break;
+          }
+
+        if (cur->module == module)
+          {
+            break;
+          }
+      }
+
+    if (cur || !module)
+      {
+        LT__SETERROR (CANNOT_OPEN);
+        module = 0;
+      }
+  }
+
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (FreeLibrary((HMODULE) module) == 0)
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = (void *) GetProcAddress ((HMODULE) module, name);
+
+  if (!address)
+    {
+      LT__SETERROR (SYMBOL_NOT_FOUND);
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/preopen.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/preopen.c	2008-06-16 01:20:03.406250000 -0500
@@ -0,0 +1,375 @@
+/* loader-preopen.c -- emulate dynamic linking using preloaded_symbols
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	preopen_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_init  (lt_user_data loader_data);
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = (lt_dlvtable *) lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_preopen";
+      vtable->sym_prefix	= 0;
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_init	= vl_init;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_PREPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+/* Wrapper type to chain together symbol lists of various origins.  */
+typedef struct symlist_chain
+{
+  struct symlist_chain *next;
+  const lt_dlsymlist   *symlist;
+} symlist_chain;
+
+
+static int add_symlist   (const lt_dlsymlist *symlist);
+static int free_symlists (void);
+
+/* The start of the symbol lists chain.  */
+static symlist_chain	       *preloaded_symlists		= 0;
+
+/* A symbol list preloaded before lt_init() was called.  */
+static const	lt_dlsymlist   *default_preloaded_symbols	= 0;
+
+
+/* A function called through the vtable to initialise this loader.  */
+static int
+vl_init (lt_user_data LT__UNUSED loader_data)
+{
+  int errors = 0;
+
+  preloaded_symlists = 0;
+  if (default_preloaded_symbols)
+    {
+      errors = lt_dlpreload (default_preloaded_symbols);
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  free_symlists ();
+  return 0;
+}
+
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  symlist_chain *lists;
+  lt_module	 module = 0;
+
+  if (!preloaded_symlists)
+    {
+      LT__SETERROR (NO_SYMBOLS);
+      goto done;
+    }
+
+  /* Can't use NULL as the reflective symbol header, as NULL is
+     used to mark the end of the entire symbol list.  Self-dlpreopened
+     symbols follow this magic number, chosen to be an unlikely
+     clash with a real module name.  */
+  if (!filename)
+    {
+      filename = "@PROGRAM@";
+    }
+
+  for (lists = preloaded_symlists; lists; lists = lists->next)
+    {
+      const lt_dlsymlist *symbol;
+      for (symbol= lists->symlist; symbol->name; ++symbol)
+	{
+	  if (!symbol->address && streq (symbol->name, filename))
+	    {
+	      /* If the next symbol's name and address is 0, it means
+		 the module just contains the originator and no symbols.
+		 In this case we pretend that we never saw the module and
+	         hope that some other loader will be able to load the module
+	         and have access to its symbols */
+	      const lt_dlsymlist *next_symbol = symbol +1;
+	      if (next_symbol->address && next_symbol->name)
+		{
+	          module = (lt_module) lists->symlist;
+	          goto done;
+		}
+	    }
+	}
+    }
+
+  LT__SETERROR (FILE_NOT_FOUND);
+
+ done:
+  return module;
+}
+
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module LT__UNUSED module)
+{
+  /* Just to silence gcc -Wall */
+  module = 0;
+  return 0;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  lt_dlsymlist	       *symbol = (lt_dlsymlist*) module;
+
+  symbol +=2;			/* Skip header (originator then libname). */
+
+  while (symbol->name)
+    {
+      if (streq (symbol->name, name))
+	{
+	  return symbol->address;
+	}
+
+    ++symbol;
+  }
+
+  LT__SETERROR (SYMBOL_NOT_FOUND);
+
+  return 0;
+}
+
+
+
+/* --- HELPER FUNCTIONS --- */
+
+
+/* The symbol lists themselves are not allocated from the heap, but
+   we can unhook them and free up the chain of links between them.  */
+static int
+free_symlists (void)
+{
+  symlist_chain *lists;
+
+  lists = preloaded_symlists;
+  while (lists)
+    {
+      symlist_chain *next = lists->next;
+      FREE (lists);
+      lists = next;
+    }
+  preloaded_symlists = 0;
+
+  return 0;
+}
+
+/* Add a new symbol list to the global chain.  */
+static int
+add_symlist (const lt_dlsymlist *symlist)
+{
+  symlist_chain *lists;
+  int		 errors   = 0;
+
+  /* Search for duplicate entries:  */
+  for (lists = preloaded_symlists;
+       lists && lists->symlist != symlist; lists = lists->next)
+    /*NOWORK*/;
+
+  /* Don't add the same list twice:  */
+  if (!lists)
+    {
+      symlist_chain *tmp = (symlist_chain *) lt__zalloc (sizeof *tmp);
+
+      if (tmp)
+	{
+	  tmp->symlist = symlist;
+	  tmp->next = preloaded_symlists;
+	  preloaded_symlists = tmp;
+	}
+      else
+	{
+	  ++errors;
+	}
+    }
+
+  return errors;
+}
+
+
+
+/* --- PRELOADING API CALL IMPLEMENTATIONS --- */
+
+
+/* Save a default symbol list for later.  */
+int
+lt_dlpreload_default (const lt_dlsymlist *preloaded)
+{
+  default_preloaded_symbols = preloaded;
+  return 0;
+}
+
+
+/* Add a symbol list to the global chain, or with a NULL argument,
+   revert to just the default list.  */
+int
+lt_dlpreload (const lt_dlsymlist *preloaded)
+{
+  int errors = 0;
+
+  if (preloaded)
+    {
+      errors = add_symlist (preloaded);
+    }
+  else
+    {
+      free_symlists();
+
+      if (default_preloaded_symbols)
+	{
+	  errors = lt_dlpreload (default_preloaded_symbols);
+	}
+    }
+
+  return errors;
+}
+
+
+/* Open all the preloaded modules from the named originator, executing
+   a callback for each one.  If ORIGINATOR is NULL, then call FUNC for
+   each preloaded module from the program itself.  */
+int
+lt_dlpreload_open (const char *originator, lt_dlpreload_callback_func *func)
+{
+  symlist_chain *list;
+  int		 errors = 0;
+  int		 found  = 0;
+
+  /* For each symlist in the chain...  */
+  for (list = preloaded_symlists; list; list = list->next)
+    {
+      /* ...that was preloaded by the requesting ORIGINATOR... */
+      if ((originator && streq (list->symlist->name, originator))
+          || (!originator && streq (list->symlist->name, "@PROGRAM@")))
+	{
+	  const lt_dlsymlist *symbol;
+	  unsigned int idx = 0;
+
+	  ++found;
+
+	  /* ...load the symbols per source compilation unit:
+	     (we preincrement the index to skip over the originator entry)  */
+	  while ((symbol = &list->symlist[++idx])->name != 0)
+	    {
+	      if ((symbol->address == 0)
+		  && (strneq (symbol->name, "@PROGRAM@")))
+		{
+		  lt_dlhandle handle = lt_dlopen (symbol->name);
+		  if (handle == 0)
+		    {
+		      ++errors;
+		    }
+		  else
+		    {
+		      errors += (*func) (handle);
+		    }
+		}
+	    }
+	}
+    }
+
+  if (!found)
+    {
+      LT__SETERROR(CANNOT_OPEN);
+      ++errors;
+    }
+
+  return errors;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/loaders/shl_load.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/loaders/shl_load.c	2008-06-16 01:19:58.906250000 -0500
@@ -0,0 +1,222 @@
+/* loader-shl_load.c --  dynamic linking with shl_load (HP-UX)
+
+   Copyright (C) 1998, 1999, 2000, 2004, 2006,
+                 2007, 2008 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+/* Use the preprocessor to rename non-static symbols to avoid namespace
+   collisions when the loader code is statically linked into libltdl.
+   Use the "<module_name>_LTX_" prefix so that the symbol addresses can
+   be fetched from the preloaded symbol list by lt_dlsym():  */
+#define get_vtable	shl_load_LTX_get_vtable
+
+LT_BEGIN_C_DECLS
+LT_SCOPE lt_dlvtable *get_vtable (lt_user_data loader_data);
+LT_END_C_DECLS
+
+
+/* Boilerplate code to set up the vtable for hooking this loader into
+   libltdl's loader list:  */
+static int	 vl_exit  (lt_user_data loader_data);
+static lt_module vm_open  (lt_user_data loader_data, const char *filename,
+                           lt_dladvise advise);
+static int	 vm_close (lt_user_data loader_data, lt_module module);
+static void *	 vm_sym   (lt_user_data loader_data, lt_module module,
+			  const char *symbolname);
+
+static lt_dlvtable *vtable = 0;
+
+/* Return the vtable for this loader, only the name and sym_prefix
+   attributes (plus the virtual function implementations, obviously)
+   change between loaders.  */
+lt_dlvtable *
+get_vtable (lt_user_data loader_data)
+{
+  if (!vtable)
+    {
+      vtable = lt__zalloc (sizeof *vtable);
+    }
+
+  if (vtable && !vtable->name)
+    {
+      vtable->name		= "lt_shl_load";
+      vtable->module_open	= vm_open;
+      vtable->module_close	= vm_close;
+      vtable->find_sym		= vm_sym;
+      vtable->dlloader_exit	= vl_exit;
+      vtable->dlloader_data	= loader_data;
+      vtable->priority		= LT_DLLOADER_APPEND;
+    }
+
+  if (vtable && (vtable->dlloader_data != loader_data))
+    {
+      LT__SETERROR (INIT_LOADER);
+      return 0;
+    }
+
+  return vtable;
+}
+
+
+
+/* --- IMPLEMENTATION --- */
+
+
+#if defined(HAVE_DL_H)
+#  include <dl.h>
+#endif
+
+/* some flags are missing on some systems, so we provide
+ * harmless defaults.
+ *
+ * Mandatory:
+ * BIND_IMMEDIATE  - Resolve symbol references when the library is loaded.
+ * BIND_DEFERRED   - Delay code symbol resolution until actual reference.
+ *
+ * Optionally:
+ * BIND_FIRST	   - Place the library at the head of the symbol search
+ * 		     order.
+ * BIND_NONFATAL   - The default BIND_IMMEDIATE behavior is to treat all
+ * 		     unsatisfied symbols as fatal.  This flag allows
+ * 		     binding of unsatisfied code symbols to be deferred
+ * 		     until use.
+ *		     [Perl: For certain libraries, like DCE, deferred
+ *		     binding often causes run time problems. Adding
+ *		     BIND_NONFATAL to BIND_IMMEDIATE still allows
+ *		     unresolved references in situations like this.]
+ * BIND_NOSTART	   - Do not call the initializer for the shared library
+ *		     when the library is loaded, nor on a future call to
+ *		     shl_unload().
+ * BIND_VERBOSE	   - Print verbose messages concerning possible
+ *		     unsatisfied symbols.
+ *
+ * hp9000s700/hp9000s800:
+ * BIND_RESTRICTED - Restrict symbols visible by the library to those
+ *		     present at library load time.
+ * DYNAMIC_PATH	   - Allow the loader to dynamically search for the
+ *		     library specified by the path argument.
+ */
+
+#if !defined(DYNAMIC_PATH)
+#  define DYNAMIC_PATH		0
+#endif
+#if !defined(BIND_RESTRICTED)
+#  define BIND_RESTRICTED	0
+#endif
+
+#define	LT_BIND_FLAGS	(BIND_IMMEDIATE | BIND_NONFATAL | DYNAMIC_PATH)
+
+
+/* A function called through the vtable when this loader is no
+   longer needed by the application.  */
+static int
+vl_exit (lt_user_data LT__UNUSED loader_data)
+{
+  vtable = NULL;
+  return 0;
+}
+
+/* A function called through the vtable to open a module with this
+   loader.  Returns an opaque representation of the newly opened
+   module for processing with this loader's other vtable functions.  */
+static lt_module
+vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
+         lt_dladvise LT__UNUSED advise)
+{
+  static shl_t self = (shl_t) 0;
+  lt_module module = shl_load (filename, LT_BIND_FLAGS, 0L);
+
+  /* Since searching for a symbol against a NULL module handle will also
+     look in everything else that was already loaded and exported with
+     the -E compiler flag, we always cache a handle saved before any
+     modules are loaded.  */
+  if (!self)
+    {
+      void *address;
+      shl_findsym (&self, "main", TYPE_UNDEFINED, &address);
+    }
+
+  if (!filename)
+    {
+      module = self;
+    }
+  else
+    {
+      module = shl_load (filename, LT_BIND_FLAGS, 0L);
+
+      if (!module)
+	{
+	  LT__SETERROR (CANNOT_OPEN);
+	}
+    }
+
+  return module;
+}
+
+/* A function called through the vtable when a particular module
+   should be unloaded.  */
+static int
+vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
+{
+  int errors = 0;
+
+  if (module && (shl_unload ((shl_t) (module)) != 0))
+    {
+      LT__SETERROR (CANNOT_CLOSE);
+      ++errors;
+    }
+
+  return errors;
+}
+
+
+/* A function called through the vtable to get the address of
+   a symbol loaded from a particular module.  */
+static void *
+vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
+{
+  void *address = 0;
+
+  /* sys_shl_open should never return a NULL module handle */
+  if (module == (lt_module) 0)
+  {
+    LT__SETERROR (INVALID_HANDLE);
+  }
+  else if (!shl_findsym((shl_t*) &module, name, TYPE_UNDEFINED, &address))
+    {
+      if (!address)
+	{
+	  LT__SETERROR (SYMBOL_NOT_FOUND);
+	}
+    }
+
+  return address;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/lt__alloc.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/lt__alloc.c	2008-06-16 01:20:03.765625000 -0500
@@ -0,0 +1,95 @@
+/* lt__alloc.c -- internal memory management interface
+
+   Copyright (C) 2004, 2006, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+
+#include <stdio.h>
+
+#include "lt__alloc.h"
+
+static void alloc_die_default (void);
+
+void (*lt__alloc_die) (void) = alloc_die_default;
+
+/* Unless overridden, exit on memory failure.  */
+static void
+alloc_die_default (void)
+{
+  fprintf (stderr, "Out of memory.\n");
+  exit (EXIT_FAILURE);
+}
+
+void *
+lt__malloc (size_t n)
+{
+  void *mem;
+
+  if (! (mem = malloc (n)))
+    (*lt__alloc_die) ();
+
+  return mem;
+}
+
+void *
+lt__zalloc (size_t n)
+{
+  void *mem;
+
+  if ((mem = lt__malloc (n)))
+    memset (mem, 0, n);
+
+  return mem;
+}
+
+void *
+lt__realloc (void *mem, size_t n)
+{
+  if (! (mem = realloc (mem, n)))
+    (*lt__alloc_die) ();
+
+  return mem;
+}
+
+void *
+lt__memdup (void const *mem, size_t n)
+{
+  void *newmem;
+
+  if ((newmem = lt__malloc (n)))
+    return memcpy (newmem, mem, n);
+
+  return 0;
+}
+
+char *
+lt__strdup (const char *string)
+{
+  return (char *) lt__memdup (string, strlen (string) +1);
+}
--- origsrc/libtunepimp-0.5.3/libltdl/lt__dirent.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/lt__dirent.c	2008-06-16 01:19:59.375000000 -0500
@@ -0,0 +1,107 @@
+/* lt__dirent.c -- internal directory entry scanning interface
+
+   Copyright (C) 2001, 2004 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2001
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+
+#include <assert.h>
+#include <stddef.h>
+
+#include "lt__dirent.h"
+
+#if defined(__WINDOWS__)
+
+void
+closedir (DIR *entry)
+{
+  assert (entry != (DIR *) NULL);
+  FindClose (entry->hSearch);
+  free ((void *) entry);
+}
+
+
+DIR *
+opendir (const char *path)
+{
+  char file_spec[LT_FILENAME_MAX];
+  DIR *entry;
+
+  assert (path != (char *) 0);
+  if (lt_strlcpy (file_spec, path, sizeof file_spec) >= sizeof file_spec
+      || lt_strlcat (file_spec, "\\", sizeof file_spec) >= sizeof file_spec)
+    return (DIR *) 0;
+  entry = (DIR *) malloc (sizeof(DIR));
+  if (entry != (DIR *) 0)
+    {
+      entry->firsttime = TRUE;
+      entry->hSearch = FindFirstFile (file_spec, &entry->Win32FindData);
+
+      if (entry->hSearch == INVALID_HANDLE_VALUE)
+	{
+	  if (lt_strlcat (file_spec, "\\*.*", sizeof file_spec) < sizeof file_spec)
+	    {
+	      entry->hSearch = FindFirstFile (file_spec, &entry->Win32FindData);
+	    }
+
+	  if (entry->hSearch == INVALID_HANDLE_VALUE)
+	    {
+	      entry = (free (entry), (DIR *) 0);
+	    }
+	}
+    }
+
+  return entry;
+}
+
+
+struct dirent *
+readdir (DIR *entry)
+{
+  int status;
+
+  if (entry == (DIR *) 0)
+    return (struct dirent *) 0;
+
+  if (!entry->firsttime)
+    {
+      status = FindNextFile (entry->hSearch, &entry->Win32FindData);
+      if (status == 0)
+        return (struct dirent *) 0;
+    }
+
+  entry->firsttime = FALSE;
+  if (lt_strlcpy (entry->file_info.d_name, entry->Win32FindData.cFileName,
+	sizeof entry->file_info.d_name) >= sizeof entry->file_info.d_name)
+    return (struct dirent *) 0;
+  entry->file_info.d_namlen = strlen (entry->file_info.d_name);
+
+  return &entry->file_info;
+}
+
+#endif /*defined(__WINDOWS__)*/
--- origsrc/libtunepimp-0.5.3/libltdl/lt__strl.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/lt__strl.c	2008-06-16 01:19:59.796875000 -0500
@@ -0,0 +1,127 @@
+/* lt__strl.c -- size-bounded string copying and concatenation
+
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Written by Bob Friesenhahn, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include <assert.h>
+#include <string.h>
+
+#include "lt__strl.h"
+
+/*
+ lt_strlcat appends the NULL-terminated string src to the end of dst.
+ It will append at most dstsize - strlen(dst) - 1 bytes,
+ NULL-terminating the result. The total length of the string which
+ would have been created given sufficient buffer size (may be longer
+ than dstsize) is returned.  This function substitutes for strlcat()
+ which is available under NetBSD, FreeBSD and Solaris 9.
+
+ Buffer overflow can be checked as follows:
+
+   if (lt_strlcat(dst, src, dstsize) >= dstsize)
+     return -1;
+*/
+#if !defined(HAVE_STRLCAT)
+size_t
+lt_strlcat(char *dst, const char *src, const size_t dstsize)
+{
+  size_t length;
+  char *p;
+  const char *q;
+
+  assert(dst != NULL);
+  assert(src != (const char *) NULL);
+  assert(dstsize >= 1);
+
+  length=strlen(dst);
+
+  /*
+    Copy remaining characters from src while constraining length to
+    size - 1.
+  */
+  for ( p = dst + length, q = src;
+        (*q != 0) && (length < dstsize - 1) ;
+        length++, p++, q++ )
+    *p = *q;
+
+  dst[length]='\0';
+
+  /*
+    Add remaining length of src to length.
+  */
+  while (*q++)
+    length++;
+
+  return length;
+}
+#endif /* !defined(HAVE_STRLCAT) */
+
+/*
+  lt_strlcpy copies up to dstsize - 1 characters from the NULL-terminated
+  string src to dst, NULL-terminating the result. The total length of
+  the string which would have been created given sufficient buffer
+  size (may be longer than dstsize) is returned. This function
+  substitutes for strlcpy() which is available under OpenBSD, FreeBSD
+  and Solaris 9.
+
+  Buffer overflow can be checked as  follows:
+
+    if (lt_strlcpy(dst, src, dstsize) >= dstsize)
+      return -1;
+*/
+#if !defined(HAVE_STRLCPY)
+size_t
+lt_strlcpy(char *dst, const char *src, const size_t dstsize)
+{
+  size_t length=0;
+  char *p;
+  const char *q;
+
+  assert(dst != NULL);
+  assert(src != (const char *) NULL);
+  assert(dstsize >= 1);
+
+  /*
+    Copy src to dst within bounds of size-1.
+  */
+  for ( p=dst, q=src, length=0 ;
+        (*q != 0) && (length < dstsize-1) ;
+        length++, p++, q++ )
+    *p = *q;
+
+  dst[length]='\0';
+
+  /*
+    Add remaining length of src to length.
+  */
+  while (*q++)
+    length++;
+
+  return length;
+}
+#endif /* !defined(HAVE_STRLCPY) */
--- origsrc/libtunepimp-0.5.3/libltdl/lt_dlloader.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/lt_dlloader.c	2008-06-16 01:20:04.093750000 -0500
@@ -0,0 +1,210 @@
+/* lt_dlloader.c -- dynamic library loader interface
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2004
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_dlloader.h"
+
+#define RETURN_SUCCESS 0
+#define RETURN_FAILURE 1
+
+static void *	loader_callback (SList *item, void *userdata);
+
+/* A list of all the dlloaders we know about, each stored as a boxed
+   SList item:  */
+static	SList    *loaders		= 0;
+
+
+/* Return NULL, unless the loader in this ITEM has a matching name,
+   in which case we return the matching item so that its address is
+   passed back out (for possible freeing) by slist_remove.  */
+static void *
+loader_callback (SList *item, void *userdata)
+{
+  const lt_dlvtable *vtable = (const lt_dlvtable *) item->userdata;
+  const char *	    name    = (const char *) userdata;
+
+  assert (vtable);
+
+  return streq (vtable->name, name) ? (void *) item : NULL;
+}
+
+
+/* Hook VTABLE into our global LOADERS list according to its own
+   PRIORITY field value.  */
+int
+lt_dlloader_add (const lt_dlvtable *vtable)
+{
+  SList *item;
+
+  if ((vtable == 0)	/* diagnose invalid vtable fields */
+      || (vtable->module_open == 0)
+      || (vtable->module_close == 0)
+      || (vtable->find_sym == 0)
+      || ((vtable->priority != LT_DLLOADER_PREPEND) &&
+	  (vtable->priority != LT_DLLOADER_APPEND)))
+    {
+      LT__SETERROR (INVALID_LOADER);
+      return RETURN_FAILURE;
+    }
+
+  item = slist_box (vtable);
+  if (!item)
+    {
+      (*lt__alloc_die) ();
+
+      /* Let the caller know something went wrong if lt__alloc_die
+	 doesn't abort.  */
+      return RETURN_FAILURE;
+    }
+
+  if (vtable->priority == LT_DLLOADER_PREPEND)
+    {
+      loaders = slist_cons (item, loaders);
+    }
+  else
+    {
+      assert (vtable->priority == LT_DLLOADER_APPEND);
+      loaders = slist_concat (loaders, item);
+    }
+
+  return RETURN_SUCCESS;
+}
+
+#ifdef LT_DEBUG_LOADERS
+static void *
+loader_dump_callback (SList *item, void *userdata)
+{
+  const lt_dlvtable *vtable = (const lt_dlvtable *) item->userdata;
+  fprintf (stderr, ", %s", (vtable && vtable->name) ? vtable->name : "(null)");
+  return 0;
+}
+
+void
+lt_dlloader_dump (void)
+{
+  fprintf (stderr, "loaders: ");
+  if (!loaders)
+    {
+      fprintf (stderr, "(empty)");
+    }
+  else
+    {
+      const lt_dlvtable *head = (const lt_dlvtable *) loaders->userdata;
+      fprintf (stderr, "%s", (head && head->name) ? head->name : "(null)");
+      if (slist_tail (loaders))
+	slist_foreach (slist_tail (loaders), loader_dump_callback, NULL);
+    }
+  fprintf (stderr, "\n");
+}
+#endif
+
+/* An iterator for the global loader list: if LOADER is NULL, then
+   return the first element, otherwise the following element.  */
+lt_dlloader
+lt_dlloader_next (lt_dlloader loader)
+{
+  SList *item = (SList *) loader;
+  return (lt_dlloader) (item ? item->next : loaders);
+}
+
+
+/* Non-destructive unboxing of a loader.  */
+const lt_dlvtable *
+lt_dlloader_get	(lt_dlloader loader)
+{
+  return (const lt_dlvtable *) (loader ? ((SList *) loader)->userdata : NULL);
+}
+
+
+/* Return the contents of the first item in the global loader list
+   with a matching NAME after removing it from that list.  If there
+   was no match, return NULL; if there is an error, return NULL and
+   set an error for lt_dlerror; do not set an error if only resident
+   modules need this loader; in either case, the loader list is not
+   changed if NULL is returned.  */
+lt_dlvtable *
+lt_dlloader_remove (char *name)
+{
+  const lt_dlvtable *	vtable	= lt_dlloader_find (name);
+  static const char	id_string[] = "lt_dlloader_remove";
+  lt_dlinterface_id	iface;
+  lt_dlhandle		handle = 0;
+  int			in_use = 0;
+  int			in_use_by_resident = 0;
+
+  if (!vtable)
+    {
+      LT__SETERROR (INVALID_LOADER);
+      return 0;
+    }
+
+  /* Fail if there are any open modules which use this loader.  */
+  iface = lt_dlinterface_register (id_string, NULL);
+  while ((handle = lt_dlhandle_iterate (iface, handle)))
+    {
+      lt__handle *cur = (lt__handle *) handle;
+      if (cur->vtable == vtable)
+	{
+	  in_use = 1;
+	  if (lt_dlisresident (handle))
+	    in_use_by_resident = 1;
+	}
+    }
+  lt_dlinterface_free (iface);
+  if (in_use)
+    {
+      if (!in_use_by_resident)
+	LT__SETERROR (REMOVE_LOADER);
+      return 0;
+    }
+
+  /* Call the loader finalisation function.  */
+  if (vtable && vtable->dlloader_exit)
+    {
+      if ((*vtable->dlloader_exit) (vtable->dlloader_data) != 0)
+	{
+	  /* If there is an exit function, and it returns non-zero
+	     then it must set an error, and we will not remove it
+	     from the list.  */
+	  return 0;
+	}
+    }
+
+  /* If we got this far, remove the loader from our global list.  */
+  return (lt_dlvtable *)
+      slist_unbox ((SList *) slist_remove (&loaders, loader_callback, name));
+}
+
+
+const lt_dlvtable *
+lt_dlloader_find (char *name)
+{
+  return lt_dlloader_get (slist_find (loaders, loader_callback, name));
+}
--- origsrc/libtunepimp-0.5.3/libltdl/lt_error.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/lt_error.c	2008-06-16 01:20:04.437500000 -0500
@@ -0,0 +1,110 @@
+/* lt_error.c -- error propogation interface
+
+   Copyright (C) 1999, 2000, 2001, 2004, 2005, 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1999
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include "lt__private.h"
+#include "lt_error.h"
+
+static const char	*last_error	= 0;
+static const char	error_strings[LT_ERROR_MAX][LT_ERROR_LEN_MAX + 1] =
+  {
+#define LT_ERROR(name, diagnostic)	diagnostic,
+    lt_dlerror_table
+#undef LT_ERROR
+  };
+
+static	const char    **user_error_strings	= 0;
+static	int		errorcount		= LT_ERROR_MAX;
+
+int
+lt_dladderror (const char *diagnostic)
+{
+  int		errindex = 0;
+  int		result	 = -1;
+  const char  **temp     = (const char **) 0;
+
+  assert (diagnostic);
+
+  errindex = errorcount - LT_ERROR_MAX;
+  temp = REALLOC (const char *, user_error_strings, 1 + errindex);
+  if (temp)
+    {
+      user_error_strings		= temp;
+      user_error_strings[errindex]	= diagnostic;
+      result				= errorcount++;
+    }
+
+  return result;
+}
+
+int
+lt_dlseterror (int errindex)
+{
+  int		errors	 = 0;
+
+  if (errindex >= errorcount || errindex < 0)
+    {
+      /* Ack!  Error setting the error message! */
+      LT__SETERROR (INVALID_ERRORCODE);
+      ++errors;
+    }
+  else if (errindex < LT_ERROR_MAX)
+    {
+      /* No error setting the error message! */
+      LT__SETERRORSTR (error_strings[errindex]);
+    }
+  else
+    {
+      /* No error setting the error message! */
+      LT__SETERRORSTR (user_error_strings[errindex - LT_ERROR_MAX]);
+    }
+
+  return errors;
+}
+
+const char *
+lt__error_string (int errorcode)
+{
+  assert (errorcode >= 0);
+  assert (errorcode < LT_ERROR_MAX);
+
+  return error_strings[errorcode];
+}
+
+const char *
+lt__get_last_error (void)
+{
+  return last_error;
+}
+
+const char *
+lt__set_last_error (const char *errormsg)
+{
+  return last_error = errormsg;
+}
--- origsrc/libtunepimp-0.5.3/libltdl/ltdl.c	2006-06-19 13:36:49.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/ltdl.c	2008-06-16 01:20:04.828125000 -0500
@@ -1,181 +1,39 @@
 /* ltdl.c -- system independent dlopen wrapper
-   Copyright (C) 1998, 1999, 2000, 2004, 2005  Free Software Foundation, Inc.
-   Originally by Thomas Tanner <tanner@ffii.org>
-   This file is part of GNU Libtool.
 
-This library is free software; you can redistribute it and/or
+   Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
+		 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2 of the License, or (at your option) any later version.
 
 As a special exception to the GNU Lesser General Public License,
 if you distribute this file as part of a program or library that
-is built using GNU libtool, you may include it under the same
-distribution terms that you use for the rest of that program.
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
 
-This library is distributed in the hope that it will be useful,
+GNU Libltdl is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301  USA
-
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
 
-#if HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#if HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-
-#if HAVE_STDIO_H
-#  include <stdio.h>
-#endif
-
-/* Include the header defining malloc.  On K&R C compilers,
-   that's <malloc.h>, on ANSI C and ISO C compilers, that's <stdlib.h>.  */
-#if HAVE_STDLIB_H
-#  include <stdlib.h>
-#else
-#  if HAVE_MALLOC_H
-#    include <malloc.h>
-#  endif
-#endif
-
-#if HAVE_STRING_H
-#  include <string.h>
-#else
-#  if HAVE_STRINGS_H
-#    include <strings.h>
-#  endif
-#endif
-
-#if HAVE_CTYPE_H
-#  include <ctype.h>
-#endif
-
-#if HAVE_MEMORY_H
-#  include <memory.h>
-#endif
-
-#if HAVE_ERRNO_H
-#  include <errno.h>
-#endif
-
-
-#ifndef __WINDOWS__
-#  ifdef __WIN32__
-#    define __WINDOWS__
-#  endif
-#endif
-
-
-#undef LT_USE_POSIX_DIRENT
-#ifdef HAVE_CLOSEDIR
-#  ifdef HAVE_OPENDIR
-#    ifdef HAVE_READDIR
-#      ifdef HAVE_DIRENT_H
-#        define LT_USE_POSIX_DIRENT
-#      endif /* HAVE_DIRENT_H */
-#    endif /* HAVE_READDIR */
-#  endif /* HAVE_OPENDIR */
-#endif /* HAVE_CLOSEDIR */
-
-
-#undef LT_USE_WINDOWS_DIRENT_EMULATION
-#ifndef LT_USE_POSIX_DIRENT
-#  ifdef __WINDOWS__
-#    define LT_USE_WINDOWS_DIRENT_EMULATION
-#  endif /* __WINDOWS__ */
-#endif /* LT_USE_POSIX_DIRENT */
-
-
-#ifdef LT_USE_POSIX_DIRENT
-#  include <dirent.h>
-#  define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
-#else
-#  ifdef LT_USE_WINDOWS_DIRENT_EMULATION
-#    define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
-#  else
-#    define dirent direct
-#    define LT_D_NAMLEN(dirent) ((dirent)->d_namlen)
-#    if HAVE_SYS_NDIR_H
-#      include <sys/ndir.h>
-#    endif
-#    if HAVE_SYS_DIR_H
-#      include <sys/dir.h>
-#    endif
-#    if HAVE_NDIR_H
-#      include <ndir.h>
-#    endif
-#  endif
-#endif
-
-#if HAVE_ARGZ_H
-#  include <argz.h>
-#endif
-
-#if HAVE_ASSERT_H
-#  include <assert.h>
-#else
-#  define assert(arg)	((void) 0)
-#endif
-
-#include "ltdl.h"
-
-#if WITH_DMALLOC
-#  include <dmalloc.h>
-#endif
-
+#include "lt__private.h"
+#include "lt_system.h"
+#include "lt_dlloader.h"
 
 
-
-/* --- WINDOWS SUPPORT --- */
-
-
-#ifdef DLL_EXPORT
-#  define LT_GLOBAL_DATA	__declspec(dllexport)
-#else
-#  define LT_GLOBAL_DATA
-#endif
-
-/* fopen() mode flags for reading a text file */
-#undef	LT_READTEXT_MODE
-#ifdef __WINDOWS__
-#  define LT_READTEXT_MODE "rt"
-#else
-#  define LT_READTEXT_MODE "r"
-#endif
-
-#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
-
-#include <windows.h>
-
-#define dirent lt_dirent
-#define DIR lt_DIR
-
-struct dirent
-{
-  char d_name[2048];
-  int  d_namlen;
-};
-
-typedef struct _DIR
-{
-  HANDLE hSearch;
-  WIN32_FIND_DATA Win32FindData;
-  BOOL firsttime;
-  struct dirent file_info;
-} DIR;
-
-#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
-
-
 /* --- MANIFEST CONSTANTS --- */
 
 
@@ -184,11 +42,11 @@
 #define LTDL_SEARCHPATH_VAR	"LTDL_LIBRARY_PATH"
 
 /* Standard libtool archive file extension.  */
-#undef  LTDL_ARCHIVE_EXT
-#define LTDL_ARCHIVE_EXT	".la"
+#undef  LT_ARCHIVE_EXT
+#define LT_ARCHIVE_EXT	".la"
 
 /* max. filename length */
-#ifndef LT_FILENAME_MAX
+#if !defined(LT_FILENAME_MAX)
 #  define LT_FILENAME_MAX	1024
 #endif
 
@@ -200,2104 +58,205 @@
 #undef	LT_SYMBOL_OVERHEAD
 #define LT_SYMBOL_OVERHEAD	5
 
+/* Various boolean flags can be stored in the flags field of an
+   lt_dlhandle... */
+#define LT_DLIS_RESIDENT(handle)  (((lt__handle*)handle)->info.is_resident)
+#define LT_DLIS_SYMGLOBAL(handle) (((lt__handle*)handle)->info.is_symglobal)
+#define LT_DLIS_SYMLOCAL(handle)  (((lt__handle*)handle)->info.is_symlocal)
 
 
-
-/* --- MEMORY HANDLING --- */
-
-
-/* These are the functions used internally.  In addition to making
-   use of the associated function pointers above, they also perform
-   error handling.  */
-static char   *lt_estrdup	LT_PARAMS((const char *str));
-static lt_ptr lt_emalloc	LT_PARAMS((size_t size));
-static lt_ptr lt_erealloc	LT_PARAMS((lt_ptr addr, size_t size));
-
-/* static lt_ptr rpl_realloc	LT_PARAMS((lt_ptr ptr, size_t size)); */
-#define rpl_realloc realloc
-
-/* These are the pointers that can be changed by the caller:  */
-LT_GLOBAL_DATA lt_ptr (*lt_dlmalloc)	LT_PARAMS((size_t size))
- 			= (lt_ptr (*) LT_PARAMS((size_t))) malloc;
-LT_GLOBAL_DATA lt_ptr (*lt_dlrealloc)	LT_PARAMS((lt_ptr ptr, size_t size))
- 			= (lt_ptr (*) LT_PARAMS((lt_ptr, size_t))) rpl_realloc;
-LT_GLOBAL_DATA void   (*lt_dlfree)	LT_PARAMS((lt_ptr ptr))
- 			= (void (*) LT_PARAMS((lt_ptr))) free;
-
-/* The following macros reduce the amount of typing needed to cast
-   assigned memory.  */
-#if WITH_DMALLOC
-
-#define LT_DLMALLOC(tp, n)	((tp *) xmalloc ((n) * sizeof(tp)))
-#define LT_DLREALLOC(tp, p, n)	((tp *) xrealloc ((p), (n) * sizeof(tp)))
-#define LT_DLFREE(p)						\
-	LT_STMT_START { if (p) (p) = (xfree (p), (lt_ptr) 0); } LT_STMT_END
-
-#define LT_EMALLOC(tp, n)	((tp *) xmalloc ((n) * sizeof(tp)))
-#define LT_EREALLOC(tp, p, n)	((tp *) xrealloc ((p), (n) * sizeof(tp)))
-
-#else
-
-#define LT_DLMALLOC(tp, n)	((tp *) lt_dlmalloc ((n) * sizeof(tp)))
-#define LT_DLREALLOC(tp, p, n)	((tp *) lt_dlrealloc ((p), (n) * sizeof(tp)))
-#define LT_DLFREE(p)						\
-	LT_STMT_START { if (p) (p) = (lt_dlfree (p), (lt_ptr) 0); } LT_STMT_END
-
-#define LT_EMALLOC(tp, n)	((tp *) lt_emalloc ((n) * sizeof(tp)))
-#define LT_EREALLOC(tp, p, n)	((tp *) lt_erealloc ((p), (n) * sizeof(tp)))
-
-#endif
-
-#define LT_DLMEM_REASSIGN(p, q)			LT_STMT_START {	\
-	if ((p) != (q)) { if (p) lt_dlfree (p); (p) = (q); (q) = 0; }	\
-						} LT_STMT_END
-
-
-/* --- REPLACEMENT FUNCTIONS --- */
-
-
-#undef strdup
-#define strdup rpl_strdup
-
-static char *strdup LT_PARAMS((const char *str));
-
-static char *
-strdup(str)
-     const char *str;
-{
-  char *tmp = 0;
-
-  if (str)
-    {
-      tmp = LT_DLMALLOC (char, 1+ strlen (str));
-      if (tmp)
-	{
-	  strcpy(tmp, str);
-	}
-    }
-
-  return tmp;
-}
-
-
-#if ! HAVE_STRCMP
-
-#undef strcmp
-#define strcmp rpl_strcmp
-
-static int strcmp LT_PARAMS((const char *str1, const char *str2));
-
-static int
-strcmp (str1, str2)
-     const char *str1;
-     const char *str2;
-{
-  if (str1 == str2)
-    return 0;
-  if (str1 == 0)
-    return -1;
-  if (str2 == 0)
-    return 1;
-
-  for (;*str1 && *str2; ++str1, ++str2)
-    {
-      if (*str1 != *str2)
-	break;
-    }
-
-  return (int)(*str1 - *str2);
-}
+static	const char	objdir[]		= LT_OBJDIR;
+static	const char	archive_ext[]		= LT_ARCHIVE_EXT;
+#if defined(LT_MODULE_EXT)
+static	const char	shlib_ext[]		= LT_MODULE_EXT;
 #endif
-
-
-#if ! HAVE_STRCHR
-
-#  if HAVE_INDEX
-#    define strchr index
-#  else
-#    define strchr rpl_strchr
-
-static const char *strchr LT_PARAMS((const char *str, int ch));
-
-static const char*
-strchr(str, ch)
-     const char *str;
-     int ch;
-{
-  const char *p;
-
-  for (p = str; *p != (char)ch && *p != LT_EOS_CHAR; ++p)
-    /*NOWORK*/;
-
-  return (*p == (char)ch) ? p : 0;
-}
-
-#  endif
-#endif /* !HAVE_STRCHR */
-
-
-#if ! HAVE_STRRCHR
-
-#  if HAVE_RINDEX
-#    define strrchr rindex
-#  else
-#    define strrchr rpl_strrchr
-
-static const char *strrchr LT_PARAMS((const char *str, int ch));
-
-static const char*
-strrchr(str, ch)
-     const char *str;
-     int ch;
-{
-  const char *p, *q = 0;
-
-  for (p = str; *p != LT_EOS_CHAR; ++p)
-    {
-      if (*p == (char) ch)
-	{
-	  q = p;
-	}
-    }
-
-  return q;
-}
-
-# endif
+#if defined(LT_DLSEARCH_PATH)
+static	const char	sys_dlsearch_path[]	= LT_DLSEARCH_PATH;
 #endif
 
-/* NOTE:  Neither bcopy nor the memcpy implementation below can
-          reliably handle copying in overlapping areas of memory.  Use
-          memmove (for which there is a fallback implmentation below)
-	  if you need that behaviour.  */
-#if ! HAVE_MEMCPY
-
-#  if HAVE_BCOPY
-#    define memcpy(dest, src, size)	bcopy (src, dest, size)
-#  else
-#    define memcpy rpl_memcpy
-
-static lt_ptr memcpy LT_PARAMS((lt_ptr dest, const lt_ptr src, size_t size));
-
-static lt_ptr
-memcpy (dest, src, size)
-     lt_ptr dest;
-     const lt_ptr src;
-     size_t size;
-{
-  const char *	s = src;
-  char *	d = dest;
-  size_t	i = 0;
-
-  for (i = 0; i < size; ++i)
-    {
-      d[i] = s[i];
-    }
-
-  return dest;
-}
-
-#  endif /* !HAVE_BCOPY */
-#endif   /* !HAVE_MEMCPY */
-
-#if ! HAVE_MEMMOVE
-#  define memmove rpl_memmove
-
-static lt_ptr memmove LT_PARAMS((lt_ptr dest, const lt_ptr src, size_t size));
-
-static lt_ptr
-memmove (dest, src, size)
-     lt_ptr dest;
-     const lt_ptr src;
-     size_t size;
-{
-  const char *	s = src;
-  char *	d = dest;
-  size_t	i;
-
-  if (d < s)
-    for (i = 0; i < size; ++i)
-      {
-	d[i] = s[i];
-      }
-  else if (d > s && size > 0)
-    for (i = size -1; ; --i)
-      {
-	d[i] = s[i];
-	if (i == 0)
-	  break;
-      }
-
-  return dest;
-}
 
-#endif /* !HAVE_MEMMOVE */
 
-#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+
+/* --- DYNAMIC MODULE LOADING --- */
 
-static void closedir LT_PARAMS((DIR *entry));
 
-static void
-closedir(entry)
-  DIR *entry;
-{
-  assert(entry != (DIR *) NULL);
-  FindClose(entry->hSearch);
-  lt_dlfree((lt_ptr)entry);
-}
+/* The type of a function used at each iteration of  foreach_dirinpath().  */
+typedef int	foreach_callback_func (char *filename, void *data1,
+				       void *data2);
+/* foreachfile_callback itself calls a function of this type: */
+typedef int	file_worker_func      (const char *filename, void *data);
+
+
+static	int	foreach_dirinpath     (const char *search_path,
+				       const char *base_name,
+				       foreach_callback_func *func,
+				       void *data1, void *data2);
+static	int	find_file_callback    (char *filename, void *data1,
+				       void *data2);
+static	int	find_handle_callback  (char *filename, void *data,
+				       void *ignored);
+static	int	foreachfile_callback  (char *filename, void *data1,
+				       void *data2);
+
+
+static	int     canonicalize_path     (const char *path, char **pcanonical);
+static	int	argzize_path	      (const char *path,
+				       char **pargz, size_t *pargz_len);
+static	FILE   *find_file	      (const char *search_path,
+				       const char *base_name, char **pdir);
+static	lt_dlhandle *find_handle      (const char *search_path,
+				       const char *base_name,
+				       lt_dlhandle *handle,
+				       lt_dladvise advise);
+static	int	find_module	      (lt_dlhandle *handle, const char *dir,
+				       const char *libdir, const char *dlname,
+				       const char *old_name, int installed,
+				       lt_dladvise advise);
+static  int     has_library_ext       (const char *filename);
+static	int	load_deplibs	      (lt_dlhandle handle,  char *deplibs);
+static	int	trim		      (char **dest, const char *str);
+static	int	try_dlopen	      (lt_dlhandle *handle,
+				       const char *filename, const char *ext,
+				       lt_dladvise advise);
+static	int	tryall_dlopen	      (lt_dlhandle *handle,
+				       const char *filename,
+				       lt_dladvise padvise,
+				       const lt_dlvtable *vtable);
+static	int	unload_deplibs	      (lt_dlhandle handle);
+static	int	lt_argz_insert	      (char **pargz, size_t *pargz_len,
+				       char *before, const char *entry);
+static	int	lt_argz_insertinorder (char **pargz, size_t *pargz_len,
+				       const char *entry);
+static	int	lt_argz_insertdir     (char **pargz, size_t *pargz_len,
+				       const char *dirnam, struct dirent *dp);
+static	int	lt_dlpath_insertdir   (char **ppath, char *before,
+				       const char *dir);
+static	int	list_files_by_dir     (const char *dirnam,
+				       char **pargz, size_t *pargz_len);
+static	int	file_not_found	      (void);
+
+#ifdef HAVE_LIBDLLOADER
+static	int	loader_init_callback  (lt_dlhandle handle);
+#endif /* HAVE_LIBDLLOADER */
 
+static	int	loader_init	      (lt_get_vtable *vtable_func,
+				       lt_user_data data);
 
-static DIR * opendir LT_PARAMS((const char *path));
+static	char	       *user_search_path= 0;
+static	lt_dlhandle	handles	= 0;
+static	int		initialized	= 0;
 
-static DIR*
-opendir (path)
-  const char *path;
+/* Our memory failure callback sets the error message to be passed back
+   up to the client, so we must be careful to return from mallocation
+   callers if allocation fails (as this callback returns!!).  */
+void
+lt__alloc_die_callback (void)
 {
-  char file_specification[LT_FILENAME_MAX];
-  DIR *entry;
-
-  assert(path != (char *) NULL);
-  /* allow space for: path + '\\' '\\' '*' '.' '*' + '\0' */
-  (void) strncpy (file_specification, path, LT_FILENAME_MAX-6);
-  file_specification[LT_FILENAME_MAX-6] = LT_EOS_CHAR;
-  (void) strcat(file_specification,"\\");
-  entry = LT_DLMALLOC (DIR,sizeof(DIR));
-  if (entry != (DIR *) 0)
-    {
-      entry->firsttime = TRUE;
-      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
-    }
-  if (entry->hSearch == INVALID_HANDLE_VALUE)
-    {
-      (void) strcat(file_specification,"\\*.*");
-      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
-      if (entry->hSearch == INVALID_HANDLE_VALUE)
-        {
-          LT_DLFREE (entry);
-          return (DIR *) 0;
-        }
-    }
-  return(entry);
+  LT__SETERROR (NO_MEMORY);
 }
 
-
-static struct dirent *readdir LT_PARAMS((DIR *entry));
-
-static struct dirent *readdir(entry)
-  DIR *entry;
+#ifdef HAVE_LIBDLLOADER
+/* This function is called to initialise each preloaded module loader,
+   and hook it into the list of loaders to be used when attempting to
+   dlopen an application module.  */
+static int
+loader_init_callback (lt_dlhandle handle)
 {
-  int
-    status;
-
-  if (entry == (DIR *) 0)
-    return((struct dirent *) 0);
-  if (!entry->firsttime)
-    {
-      status = FindNextFile(entry->hSearch,&entry->Win32FindData);
-      if (status == 0)
-        return((struct dirent *) 0);
-    }
-  entry->firsttime = FALSE;
-  (void) strncpy(entry->file_info.d_name,entry->Win32FindData.cFileName,
-    LT_FILENAME_MAX-1);
-  entry->file_info.d_name[LT_FILENAME_MAX - 1] = LT_EOS_CHAR;
-  entry->file_info.d_namlen = strlen(entry->file_info.d_name);
-  return(&entry->file_info);
+  lt_get_vtable *vtable_func = (lt_get_vtable *) lt_dlsym (handle, "get_vtable");
+  return loader_init (vtable_func, 0);
 }
+#endif /* HAVE_LIBDLLOADER */
 
-#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
-
-/* According to Alexandre Oliva <oliva@lsd.ic.unicamp.br>,
-    ``realloc is not entirely portable''
-   In any case we want to use the allocator supplied by the user without
-   burdening them with an lt_dlrealloc function pointer to maintain.
-   Instead implement our own version (with known boundary conditions)
-   using lt_dlmalloc and lt_dlfree. */
-
-/* #undef realloc
-   #define realloc rpl_realloc
-*/
-#if 0
-  /* You can't (re)define realloc unless you also (re)define malloc.
-     Right now, this code uses the size of the *destination* to decide
-     how much to copy.  That's not right, but you can't know the size
-     of the source unless you know enough about, or wrote malloc.  So
-     this code is disabled... */
-
-static lt_ptr
-realloc (ptr, size)
-     lt_ptr ptr;
-     size_t size;
+static int
+loader_init (lt_get_vtable *vtable_func, lt_user_data data)
 {
-  if (size == 0)
-    {
-      /* For zero or less bytes, free the original memory */
-      if (ptr != 0)
-	{
-	  lt_dlfree (ptr);
-	}
+  const lt_dlvtable *vtable = 0;
+  int errors = 0;
 
-      return (lt_ptr) 0;
-    }
-  else if (ptr == 0)
-    {
-      /* Allow reallocation of a NULL pointer.  */
-      return lt_dlmalloc (size);
-    }
-  else
+  if (vtable_func)
     {
-      /* Allocate a new block, copy and free the old block.  */
-      lt_ptr mem = lt_dlmalloc (size);
-
-      if (mem)
-	{
-	  memcpy (mem, ptr, size);
-	  lt_dlfree (ptr);
-	}
-
-      /* Note that the contents of PTR are not damaged if there is
-	 insufficient memory to realloc.  */
-      return mem;
+      vtable = (*vtable_func) (data);
     }
-}
-#endif
-
-
-#if ! HAVE_ARGZ_APPEND
-#  define argz_append rpl_argz_append
-
-static error_t argz_append LT_PARAMS((char **pargz, size_t *pargz_len,
-					const char *buf, size_t buf_len));
-
-static error_t
-argz_append (pargz, pargz_len, buf, buf_len)
-     char **pargz;
-     size_t *pargz_len;
-     const char *buf;
-     size_t buf_len;
-{
-  size_t argz_len;
-  char  *argz;
-
-  assert (pargz);
-  assert (pargz_len);
-  assert ((*pargz && *pargz_len) || (!*pargz && !*pargz_len));
-
-  /* If nothing needs to be appended, no more work is required.  */
-  if (buf_len == 0)
-    return 0;
-
-  /* Ensure there is enough room to append BUF_LEN.  */
-  argz_len = *pargz_len + buf_len;
-  argz = LT_DLREALLOC (char, *pargz, argz_len);
-  if (!argz)
-    return ENOMEM;
-
-  /* Copy characters from BUF after terminating '\0' in ARGZ.  */
-  memcpy (argz + *pargz_len, buf, buf_len);
-
-  /* Assign new values.  */
-  *pargz = argz;
-  *pargz_len = argz_len;
-
-  return 0;
-}
-#endif /* !HAVE_ARGZ_APPEND */
 
+  /* lt_dlloader_add will LT__SETERROR if it fails.  */
+  errors += lt_dlloader_add (vtable);
 
-#if ! HAVE_ARGZ_CREATE_SEP
-#  define argz_create_sep rpl_argz_create_sep
+  assert (errors || vtable);
 
-static error_t argz_create_sep LT_PARAMS((const char *str, int delim,
-					    char **pargz, size_t *pargz_len));
-
-static error_t
-argz_create_sep (str, delim, pargz, pargz_len)
-     const char *str;
-     int delim;
-     char **pargz;
-     size_t *pargz_len;
-{
-  size_t argz_len;
-  char *argz = 0;
-
-  assert (str);
-  assert (pargz);
-  assert (pargz_len);
-
-  /* Make a copy of STR, but replacing each occurrence of
-     DELIM with '\0'.  */
-  argz_len = 1+ LT_STRLEN (str);
-  if (argz_len)
+  if ((!errors) && vtable->dlloader_init)
     {
-      const char *p;
-      char *q;
-
-      argz = LT_DLMALLOC (char, argz_len);
-      if (!argz)
-	return ENOMEM;
-
-      for (p = str, q = argz; *p != LT_EOS_CHAR; ++p)
+      if ((*vtable->dlloader_init) (vtable->dlloader_data))
 	{
-	  if (*p == delim)
-	    {
-	      /* Ignore leading delimiters, and fold consecutive
-		 delimiters in STR into a single '\0' in ARGZ.  */
-	      if ((q > argz) && (q[-1] != LT_EOS_CHAR))
-		*q++ = LT_EOS_CHAR;
-	      else
-		--argz_len;
-	    }
-	  else
-	    *q++ = *p;
+	  LT__SETERROR (INIT_LOADER);
+	  ++errors;
 	}
-      /* Copy terminating LT_EOS_CHAR.  */
-      *q = *p;
     }
 
-  /* If ARGZ_LEN has shrunk to nothing, release ARGZ's memory.  */
-  if (!argz_len)
-    LT_DLFREE (argz);
-
-  /* Assign new values.  */
-  *pargz = argz;
-  *pargz_len = argz_len;
-
-  return 0;
-}
-#endif /* !HAVE_ARGZ_CREATE_SEP */
-
-
-#if ! HAVE_ARGZ_INSERT
-#  define argz_insert rpl_argz_insert
-
-static error_t argz_insert LT_PARAMS((char **pargz, size_t *pargz_len,
-					char *before, const char *entry));
-
-static error_t
-argz_insert (pargz, pargz_len, before, entry)
-     char **pargz;
-     size_t *pargz_len;
-     char *before;
-     const char *entry;
-{
-  assert (pargz);
-  assert (pargz_len);
-  assert (entry && *entry);
-
-  /* No BEFORE address indicates ENTRY should be inserted after the
-     current last element.  */
-  if (!before)
-    return argz_append (pargz, pargz_len, entry, 1+ LT_STRLEN (entry));
-
-  /* This probably indicates a programmer error, but to preserve
-     semantics, scan back to the start of an entry if BEFORE points
-     into the middle of it.  */
-  while ((before > *pargz) && (before[-1] != LT_EOS_CHAR))
-    --before;
-
-  {
-    size_t entry_len	= 1+ LT_STRLEN (entry);
-    size_t argz_len	= *pargz_len + entry_len;
-    size_t offset	= before - *pargz;
-    char   *argz	= LT_DLREALLOC (char, *pargz, argz_len);
-
-    if (!argz)
-      return ENOMEM;
-
-    /* Make BEFORE point to the equivalent offset in ARGZ that it
-       used to have in *PARGZ incase realloc() moved the block.  */
-    before = argz + offset;
-
-    /* Move the ARGZ entries starting at BEFORE up into the new
-       space at the end -- making room to copy ENTRY into the
-       resulting gap.  */
-    memmove (before + entry_len, before, *pargz_len - offset);
-    memcpy  (before, entry, entry_len);
-
-    /* Assign new values.  */
-    *pargz = argz;
-    *pargz_len = argz_len;
-  }
-
-  return 0;
+  return errors;
 }
-#endif /* !HAVE_ARGZ_INSERT */
 
+/* Bootstrap the loader loading with the preopening loader.  */
+#define get_vtable		preopen_LTX_get_vtable
+#define preloaded_symbols	LT_CONC3(lt_, LTDLOPEN, _LTX_preloaded_symbols)
+
+LT_BEGIN_C_DECLS
+LT_SCOPE const lt_dlvtable *	get_vtable (lt_user_data data);
+LT_END_C_DECLS
+#ifdef HAVE_LIBDLLOADER
+extern lt_dlsymlist		preloaded_symbols;
+#endif
 
-#if ! HAVE_ARGZ_NEXT
-#  define argz_next rpl_argz_next
-
-static char *argz_next LT_PARAMS((char *argz, size_t argz_len,
-				    const char *entry));
-
-static char *
-argz_next (argz, argz_len, entry)
-     char *argz;
-     size_t argz_len;
-     const char *entry;
+/* Initialize libltdl. */
+int
+lt_dlinit (void)
 {
-  assert ((argz && argz_len) || (!argz && !argz_len));
-
-  if (entry)
-    {
-      /* Either ARGZ/ARGZ_LEN is empty, or ENTRY points into an address
-	 within the ARGZ vector.  */
-      assert ((!argz && !argz_len)
-	      || ((argz <= entry) && (entry < (argz + argz_len))));
-
-      /* Move to the char immediately after the terminating
-	 '\0' of ENTRY.  */
-      entry = 1+ strchr (entry, LT_EOS_CHAR);
+  int	errors	= 0;
 
-      /* Return either the new ENTRY, or else NULL if ARGZ is
-	 exhausted.  */
-      return (entry >= argz + argz_len) ? 0 : (char *) entry;
-    }
-  else
+  /* Initialize only at first call. */
+  if (++initialized == 1)
     {
-      /* This should probably be flagged as a programmer error,
-	 since starting an argz_next loop with the iterator set
-	 to ARGZ is safer.  To preserve semantics, handle the NULL
-	 case by returning the start of ARGZ (if any).  */
-      if (argz_len > 0)
-	return argz;
-      else
-	return 0;
-    }
-}
-#endif /* !HAVE_ARGZ_NEXT */
+      lt__alloc_die	= lt__alloc_die_callback;
+      handles		= 0;
+      user_search_path	= 0; /* empty search path */
 
+      /* First set up the statically loaded preload module loader, so
+	 we can use it to preopen the other loaders we linked in at
+	 compile time.  */
+      errors += loader_init (get_vtable, 0);
 
-
-#if ! HAVE_ARGZ_STRINGIFY
-#  define argz_stringify rpl_argz_stringify
-
-static void argz_stringify LT_PARAMS((char *argz, size_t argz_len,
-				       int sep));
-
-static void
-argz_stringify (argz, argz_len, sep)
-     char *argz;
-     size_t argz_len;
-     int sep;
-{
-  assert ((argz && argz_len) || (!argz && !argz_len));
-
-  if (sep)
-    {
-      --argz_len;		/* don't stringify the terminating EOS */
-      while (--argz_len > 0)
+      /* Now open all the preloaded module loaders, so the application
+	 can use _them_ to lt_dlopen its own modules.  */
+#ifdef HAVE_LIBDLLOADER
+      if (!errors)
 	{
-	  if (argz[argz_len] == LT_EOS_CHAR)
-	    argz[argz_len] = sep;
-	}
-    }
-}
-#endif /* !HAVE_ARGZ_STRINGIFY */
-
-
-
-
-/* --- TYPE DEFINITIONS -- */
-
-
-/* This type is used for the array of caller data sets in each handler. */
-typedef struct {
-  lt_dlcaller_id	key;
-  lt_ptr		data;
-} lt_caller_data;
-
-
-
-
-/* --- OPAQUE STRUCTURES DECLARED IN LTDL.H --- */
-
-
-/* Extract the diagnostic strings from the error table macro in the same
-   order as the enumerated indices in ltdl.h. */
-
-static const char *lt_dlerror_strings[] =
-  {
-#define LT_ERROR(name, diagnostic)	(diagnostic),
-    lt_dlerror_table
-#undef LT_ERROR
-
-    0
-  };
-
-/* This structure is used for the list of registered loaders. */
-struct lt_dlloader {
-  struct lt_dlloader   *next;
-  const char	       *loader_name;	/* identifying name for each loader */
-  const char	       *sym_prefix;	/* prefix for symbols */
-  lt_module_open       *module_open;
-  lt_module_close      *module_close;
-  lt_find_sym	       *find_sym;
-  lt_dlloader_exit     *dlloader_exit;
-  lt_user_data		dlloader_data;
-};
-
-struct lt_dlhandle_struct {
-  struct lt_dlhandle_struct   *next;
-  lt_dlloader	       *loader;		/* dlopening interface */
-  lt_dlinfo		info;
-  int			depcount;	/* number of dependencies */
-  lt_dlhandle	       *deplibs;	/* dependencies */
-  lt_module		module;		/* system module handle */
-  lt_ptr		system;		/* system specific data */
-  lt_caller_data       *caller_data;	/* per caller associated data */
-  int			flags;		/* various boolean stats */
-};
-
-/* Various boolean flags can be stored in the flags field of an
-   lt_dlhandle_struct... */
-#define LT_DLGET_FLAG(handle, flag) (((handle)->flags & (flag)) == (flag))
-#define LT_DLSET_FLAG(handle, flag) ((handle)->flags |= (flag))
-
-#define LT_DLRESIDENT_FLAG	    (0x01 << 0)
-/* ...add more flags here... */
-
-#define LT_DLIS_RESIDENT(handle)    LT_DLGET_FLAG(handle, LT_DLRESIDENT_FLAG)
-
-
-#define LT_DLSTRERROR(name)	lt_dlerror_strings[LT_CONC(LT_ERROR_,name)]
-
-static	const char	objdir[]		= LTDL_OBJDIR;
-static	const char	archive_ext[]		= LTDL_ARCHIVE_EXT;
-#ifdef	LTDL_SHLIB_EXT
-static	const char	shlib_ext[]		= LTDL_SHLIB_EXT;
-#endif
-#ifdef	LTDL_SYSSEARCHPATH
-static	const char	sys_search_path[]	= LTDL_SYSSEARCHPATH;
-#endif
-
-
-
-
-/* --- MUTEX LOCKING --- */
-
-
-/* Macros to make it easier to run the lock functions only if they have
-   been registered.  The reason for the complicated lock macro is to
-   ensure that the stored error message from the last error is not
-   accidentally erased if the current function doesn't generate an
-   error of its own.  */
-#define LT_DLMUTEX_LOCK()			LT_STMT_START {	\
-	if (lt_dlmutex_lock_func) (*lt_dlmutex_lock_func)();	\
-						} LT_STMT_END
-#define LT_DLMUTEX_UNLOCK()			LT_STMT_START { \
-	if (lt_dlmutex_unlock_func) (*lt_dlmutex_unlock_func)();\
-						} LT_STMT_END
-#define LT_DLMUTEX_SETERROR(errormsg)		LT_STMT_START {	\
-	if (lt_dlmutex_seterror_func)				\
-		(*lt_dlmutex_seterror_func) (errormsg);		\
-	else 	lt_dllast_error = (errormsg);	} LT_STMT_END
-#define LT_DLMUTEX_GETERROR(errormsg)		LT_STMT_START {	\
-	if (lt_dlmutex_seterror_func)				\
-		(errormsg) = (*lt_dlmutex_geterror_func) ();	\
-	else	(errormsg) = lt_dllast_error;	} LT_STMT_END
-
-/* The mutex functions stored here are global, and are necessarily the
-   same for all threads that wish to share access to libltdl.  */
-static	lt_dlmutex_lock	    *lt_dlmutex_lock_func     = 0;
-static	lt_dlmutex_unlock   *lt_dlmutex_unlock_func   = 0;
-static	lt_dlmutex_seterror *lt_dlmutex_seterror_func = 0;
-static	lt_dlmutex_geterror *lt_dlmutex_geterror_func = 0;
-static	const char	    *lt_dllast_error	      = 0;
-
-
-/* Either set or reset the mutex functions.  Either all the arguments must
-   be valid functions, or else all can be NULL to turn off locking entirely.
-   The registered functions should be manipulating a static global lock
-   from the lock() and unlock() callbacks, which needs to be reentrant.  */
-int
-lt_dlmutex_register (lock, unlock, seterror, geterror)
-     lt_dlmutex_lock *lock;
-     lt_dlmutex_unlock *unlock;
-     lt_dlmutex_seterror *seterror;
-     lt_dlmutex_geterror *geterror;
-{
-  lt_dlmutex_unlock *old_unlock = unlock;
-  int		     errors	= 0;
-
-  /* Lock using the old lock() callback, if any.  */
-  LT_DLMUTEX_LOCK ();
-
-  if ((lock && unlock && seterror && geterror)
-      || !(lock || unlock || seterror || geterror))
-    {
-      lt_dlmutex_lock_func     = lock;
-      lt_dlmutex_unlock_func   = unlock;
-      lt_dlmutex_geterror_func = geterror;
-    }
-  else
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_MUTEX_ARGS));
-      ++errors;
-    }
-
-  /* Use the old unlock() callback we saved earlier, if any.  Otherwise
-     record any errors using internal storage.  */
-  if (old_unlock)
-    (*old_unlock) ();
-
-  /* Return the number of errors encountered during the execution of
-     this function.  */
-  return errors;
-}
-
-
-
-
-/* --- ERROR HANDLING --- */
-
-
-static	const char    **user_error_strings	= 0;
-static	int		errorcount		= LT_ERROR_MAX;
-
-int
-lt_dladderror (diagnostic)
-     const char *diagnostic;
-{
-  int		errindex = 0;
-  int		result	 = -1;
-  const char  **temp     = (const char **) 0;
-
-  assert (diagnostic);
-
-  LT_DLMUTEX_LOCK ();
-
-  errindex = errorcount - LT_ERROR_MAX;
-  temp = LT_EREALLOC (const char *, user_error_strings, 1 + errindex);
-  if (temp)
-    {
-      user_error_strings		= temp;
-      user_error_strings[errindex]	= diagnostic;
-      result				= errorcount++;
-    }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return result;
-}
-
-int
-lt_dlseterror (errindex)
-     int errindex;
-{
-  int		errors	 = 0;
-
-  LT_DLMUTEX_LOCK ();
-
-  if (errindex >= errorcount || errindex < 0)
-    {
-      /* Ack!  Error setting the error message! */
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_ERRORCODE));
-      ++errors;
-    }
-  else if (errindex < LT_ERROR_MAX)
-    {
-      /* No error setting the error message! */
-      LT_DLMUTEX_SETERROR (lt_dlerror_strings[errindex]);
-    }
-  else
-    {
-      /* No error setting the error message! */
-      LT_DLMUTEX_SETERROR (user_error_strings[errindex - LT_ERROR_MAX]);
-    }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
-}
-
-static lt_ptr
-lt_emalloc (size)
-     size_t size;
-{
-  lt_ptr mem = lt_dlmalloc (size);
-  if (size && !mem)
-    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-  return mem;
-}
-
-static lt_ptr
-lt_erealloc (addr, size)
-     lt_ptr addr;
-     size_t size;
-{
-  lt_ptr mem = lt_dlrealloc (addr, size);
-  if (size && !mem)
-    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-  return mem;
-}
-
-static char *
-lt_estrdup (str)
-     const char *str;
-{
-  char *copy = strdup (str);
-  if (LT_STRLEN (str) && !copy)
-    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-  return copy;
-}
-
-
-
-
-/* --- DLOPEN() INTERFACE LOADER --- */
-
-
-#if HAVE_LIBDL
-
-/* dynamic linking with dlopen/dlsym */
-
-#if HAVE_DLFCN_H
-#  include <dlfcn.h>
-#endif
-
-#if HAVE_SYS_DL_H
-#  include <sys/dl.h>
-#endif
-
-/* We may have to define LT_LAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_LAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_LAZY_OR_NOW	RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_LAZY_OR_NOW	DL_LAZY
-#    endif
-#  endif /* !RTLD_LAZY */
-#endif
-#ifndef LT_LAZY_OR_NOW
-#  ifdef RTLD_NOW
-#    define LT_LAZY_OR_NOW	RTLD_NOW
-#  else
-#    ifdef DL_NOW
-#      define LT_LAZY_OR_NOW	DL_NOW
-#    endif
-#  endif /* !RTLD_NOW */
-#endif
-#ifndef LT_LAZY_OR_NOW
-#  define LT_LAZY_OR_NOW	0
-#endif /* !LT_LAZY_OR_NOW */
-
-#if HAVE_DLERROR
-#  define DLERROR(arg)	dlerror ()
-#else
-#  define DLERROR(arg)	LT_DLSTRERROR (arg)
-#endif
-
-static lt_module
-sys_dl_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  lt_module   module   = dlopen (filename, LT_LAZY_OR_NOW);
-
-  if (!module)
-    {
-      LT_DLMUTEX_SETERROR (DLERROR (CANNOT_OPEN));
-    }
-
-  return module;
-}
-
-static int
-sys_dl_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  int errors = 0;
-
-  if (dlclose (module) != 0)
-    {
-      LT_DLMUTEX_SETERROR (DLERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-
-  return errors;
-}
-
-static lt_ptr
-sys_dl_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_ptr address = dlsym (module, symbol);
-
-  if (!address)
-    {
-      LT_DLMUTEX_SETERROR (DLERROR (SYMBOL_NOT_FOUND));
-    }
-
-  return address;
-}
-
-static struct lt_user_dlloader sys_dl =
-  {
-#  ifdef NEED_USCORE
-    "_",
-#  else
-    0,
-#  endif
-    sys_dl_open, sys_dl_close, sys_dl_sym, 0, 0 };
-
-
-#endif /* HAVE_LIBDL */
-
-
-
-/* --- SHL_LOAD() INTERFACE LOADER --- */
-
-#if HAVE_SHL_LOAD
-
-/* dynamic linking with shl_load (HP-UX) (comments from gmodule) */
-
-#ifdef HAVE_DL_H
-#  include <dl.h>
-#endif
-
-/* some flags are missing on some systems, so we provide
- * harmless defaults.
- *
- * Mandatory:
- * BIND_IMMEDIATE  - Resolve symbol references when the library is loaded.
- * BIND_DEFERRED   - Delay code symbol resolution until actual reference.
- *
- * Optionally:
- * BIND_FIRST	   - Place the library at the head of the symbol search
- * 		     order.
- * BIND_NONFATAL   - The default BIND_IMMEDIATE behavior is to treat all
- * 		     unsatisfied symbols as fatal.  This flag allows
- * 		     binding of unsatisfied code symbols to be deferred
- * 		     until use.
- *		     [Perl: For certain libraries, like DCE, deferred
- *		     binding often causes run time problems. Adding
- *		     BIND_NONFATAL to BIND_IMMEDIATE still allows
- *		     unresolved references in situations like this.]
- * BIND_NOSTART	   - Do not call the initializer for the shared library
- *		     when the library is loaded, nor on a future call to
- *		     shl_unload().
- * BIND_VERBOSE	   - Print verbose messages concerning possible
- *		     unsatisfied symbols.
- *
- * hp9000s700/hp9000s800:
- * BIND_RESTRICTED - Restrict symbols visible by the library to those
- *		     present at library load time.
- * DYNAMIC_PATH	   - Allow the loader to dynamically search for the
- *		     library specified by the path argument.
- */
-
-#ifndef	DYNAMIC_PATH
-#  define DYNAMIC_PATH		0
-#endif
-#ifndef	BIND_RESTRICTED
-#  define BIND_RESTRICTED	0
-#endif
-
-#define	LT_BIND_FLAGS	(BIND_IMMEDIATE | BIND_NONFATAL | DYNAMIC_PATH)
-
-static lt_module
-sys_shl_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  static shl_t self = (shl_t) 0;
-  lt_module module = shl_load (filename, LT_BIND_FLAGS, 0L);
-
-  /* Since searching for a symbol against a NULL module handle will also
-     look in everything else that was already loaded and exported with
-     the -E compiler flag, we always cache a handle saved before any
-     modules are loaded.  */
-  if (!self)
-    {
-      lt_ptr address;
-      shl_findsym (&self, "main", TYPE_UNDEFINED, &address);
-    }
-
-  if (!filename)
-    {
-      module = self;
-    }
-  else
-    {
-      module = shl_load (filename, LT_BIND_FLAGS, 0L);
-
-      if (!module)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-	}
-    }
-
-  return module;
-}
-
-static int
-sys_shl_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  int errors = 0;
-
-  if (module && (shl_unload ((shl_t) (module)) != 0))
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-
-  return errors;
-}
-
-static lt_ptr
-sys_shl_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_ptr address = 0;
-
-  /* sys_shl_open should never return a NULL module handle */
-  if (module == (lt_module) 0)
-  {
-    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
-  }
-  else if (!shl_findsym((shl_t*) &module, symbol, TYPE_UNDEFINED, &address))
-    {
-      if (!address)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-	}
-    }
-
-  return address;
-}
-
-static struct lt_user_dlloader sys_shl = {
-  0, sys_shl_open, sys_shl_close, sys_shl_sym, 0, 0
-};
-
-#endif /* HAVE_SHL_LOAD */
-
-
-
-
-/* --- LOADLIBRARY() INTERFACE LOADER --- */
-
-#ifdef __WINDOWS__
-
-/* dynamic linking for Win32 */
-
-#include <windows.h>
-
-/* Forward declaration; required to implement handle search below. */
-static lt_dlhandle handles;
-
-static lt_module
-sys_wll_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  lt_dlhandle	cur;
-  lt_module	module	   = 0;
-  const char   *errormsg   = 0;
-  char	       *searchname = 0;
-  char	       *ext;
-  char		self_name_buf[MAX_PATH];
-
-  if (!filename)
-    {
-      /* Get the name of main module */
-      *self_name_buf = 0;
-      GetModuleFileName (NULL, self_name_buf, sizeof (self_name_buf));
-      filename = ext = self_name_buf;
-    }
-  else
-    {
-      ext = strrchr (filename, '.');
-    }
-
-  if (ext)
-    {
-      /* FILENAME already has an extension. */
-      searchname = lt_estrdup (filename);
-    }
-  else
-    {
-      /* Append a `.' to stop Windows from adding an
-	 implicit `.dll' extension. */
-      searchname = LT_EMALLOC (char, 2+ LT_STRLEN (filename));
-      if (searchname)
-	sprintf (searchname, "%s.", filename);
-    }
-  if (!searchname)
-    return 0;
-
-  {
-    /* Silence dialog from LoadLibrary on some failures.
-       No way to get the error mode, but to set it,
-       so set it twice to preserve any previous flags. */
-    UINT errormode = SetErrorMode(SEM_FAILCRITICALERRORS);
-    SetErrorMode(errormode | SEM_FAILCRITICALERRORS);
-
-#if defined(__CYGWIN__)
-    {
-      char wpath[MAX_PATH];
-      cygwin_conv_to_full_win32_path (searchname, wpath);
-      module = LoadLibrary (wpath);
-    }
-#else
-    module = LoadLibrary (searchname);
-#endif
-
-    /* Restore the error mode. */
-    SetErrorMode(errormode);
-  }
-
-  LT_DLFREE (searchname);
-
-  /* libltdl expects this function to fail if it is unable
-     to physically load the library.  Sadly, LoadLibrary
-     will search the loaded libraries for a match and return
-     one of them if the path search load fails.
-
-     We check whether LoadLibrary is returning a handle to
-     an already loaded module, and simulate failure if we
-     find one. */
-  LT_DLMUTEX_LOCK ();
-  cur = handles;
-  while (cur)
-    {
-      if (!cur->module)
-	{
-	  cur = 0;
-	  break;
-	}
-
-      if (cur->module == module)
-	{
-	  break;
-	}
-
-      cur = cur->next;
-  }
-  LT_DLMUTEX_UNLOCK ();
-
-  if (cur || !module)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-      module = 0;
-    }
-
-  return module;
-}
-
-static int
-sys_wll_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  int	      errors   = 0;
-
-  if (FreeLibrary(module) == 0)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-
-  return errors;
-}
-
-static lt_ptr
-sys_wll_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_ptr      address  = GetProcAddress (module, symbol);
-
-  if (!address)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-    }
-
-  return address;
-}
-
-static struct lt_user_dlloader sys_wll = {
-  0, sys_wll_open, sys_wll_close, sys_wll_sym, 0, 0
-};
-
-#endif /* __WINDOWS__ */
-
-
-
-
-/* --- LOAD_ADD_ON() INTERFACE LOADER --- */
-
-
-#ifdef __BEOS__
-
-/* dynamic linking for BeOS */
-
-#include <kernel/image.h>
-
-static lt_module
-sys_bedl_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  image_id image = 0;
-
-  if (filename)
-    {
-      image = load_add_on (filename);
-    }
-  else
-    {
-      image_info info;
-      int32 cookie = 0;
-      if (get_next_image_info (0, &cookie, &info) == B_OK)
-	image = load_add_on (info.name);
-    }
-
-  if (image <= 0)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-      image = 0;
-    }
-
-  return (lt_module) image;
-}
-
-static int
-sys_bedl_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  int errors = 0;
-
-  if (unload_add_on ((image_id) module) != B_OK)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-
-  return errors;
-}
-
-static lt_ptr
-sys_bedl_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_ptr address = 0;
-  image_id image = (image_id) module;
-
-  if (get_image_symbol (image, symbol, B_SYMBOL_TYPE_ANY, address) != B_OK)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-      address = 0;
-    }
-
-  return address;
-}
-
-static struct lt_user_dlloader sys_bedl = {
-  0, sys_bedl_open, sys_bedl_close, sys_bedl_sym, 0, 0
-};
-
-#endif /* __BEOS__ */
-
-
-
-
-/* --- DLD_LINK() INTERFACE LOADER --- */
-
-
-#if HAVE_DLD
-
-/* dynamic linking with dld */
-
-#if HAVE_DLD_H
-#include <dld.h>
-#endif
-
-static lt_module
-sys_dld_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  lt_module module = strdup (filename);
-
-  if (dld_link (filename) != 0)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-      LT_DLFREE (module);
-      module = 0;
-    }
-
-  return module;
-}
-
-static int
-sys_dld_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  int errors = 0;
-
-  if (dld_unlink_by_file ((char*)(module), 1) != 0)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-  else
-    {
-      LT_DLFREE (module);
-    }
-
-  return errors;
-}
-
-static lt_ptr
-sys_dld_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_ptr address = dld_get_func (symbol);
-
-  if (!address)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-    }
-
-  return address;
-}
-
-static struct lt_user_dlloader sys_dld = {
-  0, sys_dld_open, sys_dld_close, sys_dld_sym, 0, 0
-};
-
-#endif /* HAVE_DLD */
-
-/* --- DYLD() MACOSX/DARWIN INTERFACE LOADER --- */
-#if HAVE_DYLD
-
-
-#if HAVE_MACH_O_DYLD_H
-#if !defined(__APPLE_CC__) && !defined(__MWERKS__) && !defined(__private_extern__)
-/* Is this correct? Does it still function properly? */
-#define __private_extern__ extern
-#endif
-# include <mach-o/dyld.h>
-#endif
-#include <mach-o/getsect.h>
-
-/* We have to put some stuff here that isn't in older dyld.h files */
-#ifndef ENUM_DYLD_BOOL
-# define ENUM_DYLD_BOOL
-# undef FALSE
-# undef TRUE
- enum DYLD_BOOL {
-    FALSE,
-    TRUE
- };
-#endif
-#ifndef LC_REQ_DYLD
-# define LC_REQ_DYLD 0x80000000
-#endif
-#ifndef LC_LOAD_WEAK_DYLIB
-# define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)
-#endif
-static const struct mach_header * (*ltdl_NSAddImage)(const char *image_name, unsigned long options) = 0;
-static NSSymbol (*ltdl_NSLookupSymbolInImage)(const struct mach_header *image,const char *symbolName, unsigned long options) = 0;
-static enum DYLD_BOOL (*ltdl_NSIsSymbolNameDefinedInImage)(const struct mach_header *image, const char *symbolName) = 0;
-static enum DYLD_BOOL (*ltdl_NSMakePrivateModulePublic)(NSModule module) = 0;
-
-#ifndef NSADDIMAGE_OPTION_NONE
-#define NSADDIMAGE_OPTION_NONE                          0x0
-#endif
-#ifndef NSADDIMAGE_OPTION_RETURN_ON_ERROR
-#define NSADDIMAGE_OPTION_RETURN_ON_ERROR               0x1
-#endif
-#ifndef NSADDIMAGE_OPTION_WITH_SEARCHING
-#define NSADDIMAGE_OPTION_WITH_SEARCHING                0x2
-#endif
-#ifndef NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED
-#define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED         0x4
-#endif
-#ifndef NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME
-#define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8
-#endif
-#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND
-#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND            0x0
-#endif
-#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
-#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW        0x1
-#endif
-#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY
-#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY      0x2
-#endif
-#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
-#define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4
-#endif
-
-
-static const char *
-lt_int_dyld_error(othererror)
-	char* othererror;
-{
-/* return the dyld error string, or the passed in error string if none */
-	NSLinkEditErrors ler;
-	int lerno;
-	const char *errstr;
-	const char *file;
-	NSLinkEditError(&ler,&lerno,&file,&errstr);
-	if (!errstr || !strlen(errstr)) errstr = othererror;
-	return errstr;
-}
-
-static const struct mach_header *
-lt_int_dyld_get_mach_header_from_nsmodule(module)
-	NSModule module;
-{
-/* There should probably be an apple dyld api for this */
-	int i=_dyld_image_count();
-	int j;
-	const char *modname=NSNameOfModule(module);
-	const struct mach_header *mh=NULL;
-	if (!modname) return NULL;
-	for (j = 0; j < i; j++)
-	{
-		if (!strcmp(_dyld_get_image_name(j),modname))
-		{
-			mh=_dyld_get_image_header(j);
-			break;
-		}
-	}
-	return mh;
-}
-
-static const char* lt_int_dyld_lib_install_name(mh)
-	const struct mach_header *mh;
-{
-/* NSAddImage is also used to get the loaded image, but it only works if the lib
-   is installed, for uninstalled libs we need to check the install_names against
-   each other. Note that this is still broken if DYLD_IMAGE_SUFFIX is set and a
-   different lib was loaded as a result
-*/
-	int j;
-	struct load_command *lc;
-	unsigned long offset = sizeof(struct mach_header);
-	const char* retStr=NULL;
-	for (j = 0; j < mh->ncmds; j++)
-	{
-		lc = (struct load_command*)(((unsigned long)mh) + offset);
-		if (LC_ID_DYLIB == lc->cmd)
-		{
-			retStr=(char*)(((struct dylib_command*)lc)->dylib.name.offset +
-									(unsigned long)lc);
-		}
-		offset += lc->cmdsize;
-	}
-	return retStr;
-}
-
-static const struct mach_header *
-lt_int_dyld_match_loaded_lib_by_install_name(const char *name)
-{
-	int i=_dyld_image_count();
-	int j;
-	const struct mach_header *mh=NULL;
-	const char *id=NULL;
-	for (j = 0; j < i; j++)
-	{
-		id=lt_int_dyld_lib_install_name(_dyld_get_image_header(j));
-		if ((id) && (!strcmp(id,name)))
-		{
-			mh=_dyld_get_image_header(j);
-			break;
-		}
-	}
-	return mh;
-}
-
-static NSSymbol
-lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh)
-	const char *symbol;
-	const struct mach_header *mh;
-{
-	/* Safe to assume our mh is good */
-	int j;
-	struct load_command *lc;
-	unsigned long offset = sizeof(struct mach_header);
-	NSSymbol retSym = 0;
-	const struct mach_header *mh1;
-	if ((ltdl_NSLookupSymbolInImage) && NSIsSymbolNameDefined(symbol) )
-	{
-		for (j = 0; j < mh->ncmds; j++)
-		{
-			lc = (struct load_command*)(((unsigned long)mh) + offset);
-			if ((LC_LOAD_DYLIB == lc->cmd) || (LC_LOAD_WEAK_DYLIB == lc->cmd))
-			{
-				mh1=lt_int_dyld_match_loaded_lib_by_install_name((char*)(((struct dylib_command*)lc)->dylib.name.offset +
-										(unsigned long)lc));
-				if (!mh1)
-				{
-					/* Maybe NSAddImage can find it */
-					mh1=ltdl_NSAddImage((char*)(((struct dylib_command*)lc)->dylib.name.offset +
-										(unsigned long)lc),
-										NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED +
-										NSADDIMAGE_OPTION_WITH_SEARCHING +
-										NSADDIMAGE_OPTION_RETURN_ON_ERROR );
-				}
-				if (mh1)
-				{
-					retSym = ltdl_NSLookupSymbolInImage(mh1,
-											symbol,
-											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
-											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
-											);
-					if (retSym) break;
-				}
-			}
-			offset += lc->cmdsize;
-		}
-	}
-	return retSym;
-}
-
-static int
-sys_dyld_init()
-{
-	int retCode = 0;
-	int err = 0;
-	if (!_dyld_present()) {
-		retCode=1;
-	}
-	else {
-      err = _dyld_func_lookup("__dyld_NSAddImage",(unsigned long*)&ltdl_NSAddImage);
-      err = _dyld_func_lookup("__dyld_NSLookupSymbolInImage",(unsigned long*)&ltdl_NSLookupSymbolInImage);
-      err = _dyld_func_lookup("__dyld_NSIsSymbolNameDefinedInImage",(unsigned long*)&ltdl_NSIsSymbolNameDefinedInImage);
-      err = _dyld_func_lookup("__dyld_NSMakePrivateModulePublic",(unsigned long*)&ltdl_NSMakePrivateModulePublic);
-    }
- return retCode;
-}
-
-static lt_module
-sys_dyld_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-	lt_module   module   = 0;
-	NSObjectFileImage ofi = 0;
-	NSObjectFileImageReturnCode ofirc;
-
-  	if (!filename)
-  		return (lt_module)-1;
-	ofirc = NSCreateObjectFileImageFromFile(filename, &ofi);
-	switch (ofirc)
-	{
-		case NSObjectFileImageSuccess:
-			module = NSLinkModule(ofi, filename,
-						NSLINKMODULE_OPTION_RETURN_ON_ERROR
-						 | NSLINKMODULE_OPTION_PRIVATE
-						 | NSLINKMODULE_OPTION_BINDNOW);
-			NSDestroyObjectFileImage(ofi);
-			if (module)
-				ltdl_NSMakePrivateModulePublic(module);
-			break;
-		case NSObjectFileImageInappropriateFile:
-		    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
-		    {
-				module = (lt_module)ltdl_NSAddImage(filename, NSADDIMAGE_OPTION_RETURN_ON_ERROR);
-				break;
-			}
-		default:
-			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
-			return 0;
-	}
-	if (!module) LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
-  return module;
-}
-
-static int
-sys_dyld_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-	int retCode = 0;
-	int flags = 0;
-	if (module == (lt_module)-1) return 0;
-#ifdef __BIG_ENDIAN__
-  	if (((struct mach_header *)module)->magic == MH_MAGIC)
-#else
-    if (((struct mach_header *)module)->magic == MH_CIGAM)
-#endif
-	{
-	  LT_DLMUTEX_SETERROR("Can not close a dylib");
-	  retCode = 1;
-	}
-	else
-	{
-#if 1
-/* Currently, if a module contains c++ static destructors and it is unloaded, we
-   get a segfault in atexit(), due to compiler and dynamic loader differences of
-   opinion, this works around that.
-*/
-		if ((const struct section *)NULL !=
-		   getsectbynamefromheader(lt_int_dyld_get_mach_header_from_nsmodule(module),
-		   "__DATA","__mod_term_func"))
-		{
-			flags += NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
-		}
-#endif
-#ifdef __ppc__
-			flags += NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
-#endif
-		if (!NSUnLinkModule(module,flags))
-		{
-			retCode=1;
-			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_CLOSE)));
-		}
-	}
-
- return retCode;
-}
-
-static lt_ptr
-sys_dyld_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-	lt_ptr address = 0;
-  	NSSymbol *nssym = 0;
-  	void *unused;
-  	const struct mach_header *mh=NULL;
-  	char saveError[256] = "Symbol not found";
-  	if (module == (lt_module)-1)
-  	{
-  		_dyld_lookup_and_bind(symbol,(unsigned long*)&address,&unused);
-  		return address;
-  	}
-#ifdef __BIG_ENDIAN__
-  	if (((struct mach_header *)module)->magic == MH_MAGIC)
-#else
-    if (((struct mach_header *)module)->magic == MH_CIGAM)
-#endif
-  	{
-  	    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
-  	    {
-  	    	mh=module;
-			if (ltdl_NSIsSymbolNameDefinedInImage((struct mach_header*)module,symbol))
-			{
-				nssym = ltdl_NSLookupSymbolInImage((struct mach_header*)module,
-											symbol,
-											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
-											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
-											);
-			}
-	    }
-
-  	}
-  else {
-	nssym = NSLookupSymbolInModule(module, symbol);
-	}
-	if (!nssym)
-	{
-		strncpy(saveError, lt_int_dyld_error(LT_DLSTRERROR(SYMBOL_NOT_FOUND)), 255);
-		saveError[255] = 0;
-		if (!mh) mh=lt_int_dyld_get_mach_header_from_nsmodule(module);
-		nssym = lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh);
-	}
-	if (!nssym)
-	{
-		LT_DLMUTEX_SETERROR (saveError);
-		return NULL;
-	}
-	return NSAddressOfSymbol(nssym);
-}
-
-static struct lt_user_dlloader sys_dyld =
-  { "_", sys_dyld_open, sys_dyld_close, sys_dyld_sym, 0, 0 };
-
-
-#endif /* HAVE_DYLD */
-
-
-/* --- DLPREOPEN() INTERFACE LOADER --- */
-
-
-/* emulate dynamic linking using preloaded_symbols */
-
-typedef struct lt_dlsymlists_t
-{
-  struct lt_dlsymlists_t       *next;
-  const lt_dlsymlist	       *syms;
-} lt_dlsymlists_t;
-
-static	const lt_dlsymlist     *default_preloaded_symbols	= 0;
-static	lt_dlsymlists_t	       *preloaded_symbols		= 0;
-
-static int
-presym_init (loader_data)
-     lt_user_data loader_data;
-{
-  int errors = 0;
-
-  LT_DLMUTEX_LOCK ();
-
-  preloaded_symbols = 0;
-  if (default_preloaded_symbols)
-    {
-      errors = lt_dlpreload (default_preloaded_symbols);
-    }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
-}
-
-static int
-presym_free_symlists ()
-{
-  lt_dlsymlists_t *lists;
-
-  LT_DLMUTEX_LOCK ();
-
-  lists = preloaded_symbols;
-  while (lists)
-    {
-      lt_dlsymlists_t	*tmp = lists;
-
-      lists = lists->next;
-      LT_DLFREE (tmp);
-    }
-  preloaded_symbols = 0;
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return 0;
-}
-
-static int
-presym_exit (loader_data)
-     lt_user_data loader_data;
-{
-  presym_free_symlists ();
-  return 0;
-}
-
-static int
-presym_add_symlist (preloaded)
-     const lt_dlsymlist *preloaded;
-{
-  lt_dlsymlists_t *tmp;
-  lt_dlsymlists_t *lists;
-  int		   errors   = 0;
-
-  LT_DLMUTEX_LOCK ();
-
-  lists = preloaded_symbols;
-  while (lists)
-    {
-      if (lists->syms == preloaded)
-	{
-	  goto done;
-	}
-      lists = lists->next;
-    }
-
-  tmp = LT_EMALLOC (lt_dlsymlists_t, 1);
-  if (tmp)
-    {
-      memset (tmp, 0, sizeof(lt_dlsymlists_t));
-      tmp->syms = preloaded;
-      tmp->next = preloaded_symbols;
-      preloaded_symbols = tmp;
-    }
-  else
-    {
-      ++errors;
-    }
-
- done:
-  LT_DLMUTEX_UNLOCK ();
-  return errors;
-}
-
-static lt_module
-presym_open (loader_data, filename)
-     lt_user_data loader_data;
-     const char *filename;
-{
-  lt_dlsymlists_t *lists;
-  lt_module	   module = (lt_module) 0;
-
-  LT_DLMUTEX_LOCK ();
-  lists = preloaded_symbols;
-
-  if (!lists)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_SYMBOLS));
-      goto done;
-    }
-
-  /* Can't use NULL as the reflective symbol header, as NULL is
-     used to mark the end of the entire symbol list.  Self-dlpreopened
-     symbols follow this magic number, chosen to be an unlikely
-     clash with a real module name.  */
-  if (!filename)
-    {
-      filename = "@PROGRAM@";
-    }
-
-  while (lists)
-    {
-      const lt_dlsymlist *syms = lists->syms;
-
-      while (syms->name)
-	{
-	  if (!syms->address && strcmp(syms->name, filename) == 0)
-	    {
-	      module = (lt_module) syms;
-	      goto done;
-	    }
-	  ++syms;
-	}
-
-      lists = lists->next;
-    }
-
-  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-
- done:
-  LT_DLMUTEX_UNLOCK ();
-  return module;
-}
-
-static int
-presym_close (loader_data, module)
-     lt_user_data loader_data;
-     lt_module module;
-{
-  /* Just to silence gcc -Wall */
-  module = 0;
-  return 0;
-}
-
-static lt_ptr
-presym_sym (loader_data, module, symbol)
-     lt_user_data loader_data;
-     lt_module module;
-     const char *symbol;
-{
-  lt_dlsymlist *syms = (lt_dlsymlist*) module;
-
-  ++syms;
-  while (syms->address)
-    {
-      if (strcmp(syms->name, symbol) == 0)
-	{
-	  return syms->address;
-	}
-
-    ++syms;
-  }
-
-  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-
-  return 0;
-}
-
-static struct lt_user_dlloader presym = {
-  0, presym_open, presym_close, presym_sym, presym_exit, 0
-};
-
-
-
-
-
-/* --- DYNAMIC MODULE LOADING --- */
-
-
-/* The type of a function used at each iteration of  foreach_dirinpath().  */
-typedef int	foreach_callback_func LT_PARAMS((char *filename, lt_ptr data1,
-						 lt_ptr data2));
-
-static	int	foreach_dirinpath     LT_PARAMS((const char *search_path,
-						 const char *base_name,
-						 foreach_callback_func *func,
-						 lt_ptr data1, lt_ptr data2));
-
-static	int	find_file_callback    LT_PARAMS((char *filename, lt_ptr data,
-						 lt_ptr ignored));
-static	int	find_handle_callback  LT_PARAMS((char *filename, lt_ptr data,
-						 lt_ptr ignored));
-static	int	foreachfile_callback  LT_PARAMS((char *filename, lt_ptr data1,
-						 lt_ptr data2));
-
-
-static	int     canonicalize_path     LT_PARAMS((const char *path,
-						 char **pcanonical));
-static	int	argzize_path 	      LT_PARAMS((const char *path,
-						 char **pargz,
-						 size_t *pargz_len));
-static	FILE   *find_file	      LT_PARAMS((const char *search_path,
-						 const char *base_name,
-						 char **pdir));
-static	lt_dlhandle *find_handle      LT_PARAMS((const char *search_path,
-						 const char *base_name,
-						 lt_dlhandle *handle));
-static	int	find_module	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *dir,
-						 const char *libdir,
-						 const char *dlname,
-						 const char *old_name,
-						 int installed));
-static	int	free_vars	      LT_PARAMS((char *dlname, char *oldname,
-						 char *libdir, char *deplibs));
-static	int	load_deplibs	      LT_PARAMS((lt_dlhandle handle,
-						 char *deplibs));
-static	int	trim		      LT_PARAMS((char **dest,
-						 const char *str));
-static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *filename));
-static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *filename));
-static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
-static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
-						 size_t *pargz_len,
-						 char *before,
-						 const char *entry));
-static	int	lt_argz_insertinorder LT_PARAMS((char **pargz,
-						 size_t *pargz_len,
-						 const char *entry));
-static	int	lt_argz_insertdir     LT_PARAMS((char **pargz,
-						 size_t *pargz_len,
-						 const char *dirnam,
-						 struct dirent *dp));
-static	int	lt_dlpath_insertdir   LT_PARAMS((char **ppath,
-						 char *before,
-						 const char *dir));
-static	int	list_files_by_dir     LT_PARAMS((const char *dirnam,
-						 char **pargz,
-						 size_t *pargz_len));
-static	int	file_not_found	      LT_PARAMS((void));
-
-static	char	       *user_search_path= 0;
-static	lt_dlloader    *loaders		= 0;
-static	lt_dlhandle	handles 	= 0;
-static	int		initialized 	= 0;
-
-/* Initialize libltdl. */
-int
-lt_dlinit ()
-{
-  int	      errors   = 0;
-
-  LT_DLMUTEX_LOCK ();
-
-  /* Initialize only at first call. */
-  if (++initialized == 1)
-    {
-      handles = 0;
-      user_search_path = 0; /* empty search path */
-
-#if HAVE_LIBDL
-      errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dl, "dlopen");
-#endif
-#if HAVE_SHL_LOAD
-      errors += lt_dlloader_add (lt_dlloader_next (0), &sys_shl, "dlopen");
-#endif
-#ifdef __WINDOWS__
-      errors += lt_dlloader_add (lt_dlloader_next (0), &sys_wll, "dlopen");
-#endif
-#ifdef __BEOS__
-      errors += lt_dlloader_add (lt_dlloader_next (0), &sys_bedl, "dlopen");
-#endif
-#if HAVE_DLD
-      errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dld, "dld");
-#endif
-#if HAVE_DYLD
-       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dyld, "dyld");
-       errors += sys_dyld_init();
-#endif
-      errors += lt_dlloader_add (lt_dlloader_next (0), &presym, "dlpreload");
-
-      if (presym_init (presym.dlloader_data))
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INIT_LOADER));
-	  ++errors;
-	}
-      else if (errors != 0)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (DLOPEN_NOT_SUPPORTED));
-	  ++errors;
-	}
-    }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
-}
-
-int
-lt_dlpreload (preloaded)
-     const lt_dlsymlist *preloaded;
-{
-  int errors = 0;
-
-  if (preloaded)
-    {
-      errors = presym_add_symlist (preloaded);
-    }
-  else
-    {
-      presym_free_symlists();
+	  errors += lt_dlpreload (&preloaded_symbols);
+	}
 
-      LT_DLMUTEX_LOCK ();
-      if (default_preloaded_symbols)
+      if (!errors)
 	{
-	  errors = lt_dlpreload (default_preloaded_symbols);
+	  errors += lt_dlpreload_open (LT_STR(LTDLOPEN), loader_init_callback);
 	}
-      LT_DLMUTEX_UNLOCK ();
+#endif /* HAVE_LIBDLLOADER */
     }
 
-  return errors;
-}
+#ifdef LT_DEBUG_LOADERS
+  lt_dlloader_dump();
+#endif
 
-int
-lt_dlpreload_default (preloaded)
-     const lt_dlsymlist *preloaded;
-{
-  LT_DLMUTEX_LOCK ();
-  default_preloaded_symbols = preloaded;
-  LT_DLMUTEX_UNLOCK ();
-  return 0;
+  return errors;
 }
 
 int
-lt_dlexit ()
+lt_dlexit (void)
 {
   /* shut down libltdl */
-  lt_dlloader *loader;
+  lt_dlloader *loader   = 0;
+  lt__handle  *handle   = (lt__handle *) handles;
   int	       errors   = 0;
 
-  LT_DLMUTEX_LOCK ();
-  loader = loaders;
-
   if (!initialized)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SHUTDOWN));
+      LT__SETERROR (SHUTDOWN);
       ++errors;
       goto done;
     }
@@ -2309,26 +268,40 @@
 
       while (handles && LT_DLIS_RESIDENT (handles))
 	{
-	  handles = handles->next;
+	  handles = ((lt__handle *) handles)->next;
 	}
 
       /* close all modules */
-      for (level = 1; handles; ++level)
+      for (level = 1; handle; ++level)
 	{
-	  lt_dlhandle cur = handles;
+	  lt__handle *cur = (lt__handle *) handles;
 	  int saw_nonresident = 0;
 
 	  while (cur)
 	    {
-	      lt_dlhandle tmp = cur;
+	      lt__handle *tmp = cur;
 	      cur = cur->next;
 	      if (!LT_DLIS_RESIDENT (tmp))
-		saw_nonresident = 1;
-	      if (!LT_DLIS_RESIDENT (tmp) && tmp->info.ref_count <= level)
 		{
-		  if (lt_dlclose (tmp))
+		  saw_nonresident = 1;
+		  if (tmp->info.ref_count <= level)
 		    {
-		      ++errors;
+		      if (lt_dlclose (tmp))
+			{
+			  ++errors;
+			}
+		      /* Make sure that the handle pointed to by 'cur' still exists.
+			 lt_dlclose recursively closes dependent libraries which removes
+			 them from the linked list.  One of these might be the one
+			 pointed to by 'cur'.  */
+		      if (cur)
+			{
+			  for (tmp = (lt__handle *) handles; tmp; tmp = tmp->next)
+			    if (tmp == cur)
+			      break;
+			  if (! tmp)
+			    cur = (lt__handle *) handles;
+			}
 		    }
 		}
 	    }
@@ -2337,68 +310,81 @@
 	    break;
 	}
 
+      /* When removing loaders, we can only find out failure by testing
+	 the error string, so avoid a spurious one from an earlier
+	 failed command. */
+      if (!errors)
+	LT__SETERRORSTR (0);
+
       /* close all loaders */
-      while (loader)
+      for (loader = (lt_dlloader *) lt_dlloader_next (NULL); loader;)
 	{
-	  lt_dlloader *next = loader->next;
-	  lt_user_data data = loader->dlloader_data;
-	  if (loader->dlloader_exit && loader->dlloader_exit (data))
+	  lt_dlloader *next   = (lt_dlloader *) lt_dlloader_next (loader);
+	  lt_dlvtable *vtable = (lt_dlvtable *) lt_dlloader_get (loader);
+
+	  if ((vtable = lt_dlloader_remove ((char *) vtable->name)))
 	    {
-	      ++errors;
+	      FREE (vtable);
+	    }
+	  else
+	    {
+	      /* ignore errors due to resident modules */
+	      const char *err;
+	      LT__GETERROR (err);
+	      if (err)
+		++errors;
 	    }
 
-	  LT_DLMEM_REASSIGN (loader, next);
+	  loader = next;
 	}
-      loaders = 0;
+
+      FREE(user_search_path);
     }
 
  done:
-  LT_DLMUTEX_UNLOCK ();
   return errors;
 }
 
+
+/* Try VTABLE or, if VTABLE is NULL, all available loaders for FILENAME.
+   If the library is not successfully loaded, return non-zero.  Otherwise,
+   the dlhandle is stored at the address given in PHANDLE.  */
 static int
-tryall_dlopen (handle, filename)
-     lt_dlhandle *handle;
-     const char *filename;
-{
-  lt_dlhandle	 cur;
-  lt_dlloader   *loader;
-  const char	*saved_error;
-  int		 errors		= 0;
+tryall_dlopen (lt_dlhandle *phandle, const char *filename,
+	       lt_dladvise padvise, const lt_dlvtable *vtable)
+{
+  lt__handle *	handle		= (lt__handle *) handles;
+  const char *	saved_error	= 0;
+  int		errors		= 0;
+  lt__advise *  advise		= (lt__advise *) padvise;
 
-  LT_DLMUTEX_GETERROR (saved_error);
-  LT_DLMUTEX_LOCK ();
+#ifdef LT_DEBUG_LOADERS
+  fprintf (stderr, "tryall_dlopen (%s, %s)\n",
+	   filename ? filename : "(null)",
+	   vtable ? vtable->name : "(ALL)");
+#endif
 
-  cur	 = handles;
-  loader = loaders;
+  LT__GETERROR (saved_error);
 
   /* check whether the module was already opened */
-  while (cur)
+  for (;handle; handle = handle->next)
     {
-      /* try to dlopen the program itself? */
-      if (!cur->info.filename && !filename)
-	{
-	  break;
-	}
-
-      if (cur->info.filename && filename
-	  && strcmp (cur->info.filename, filename) == 0)
+      if ((handle->info.filename == filename) /* dlopen self: 0 == 0 */
+	  || (handle->info.filename && filename
+	      && streq (handle->info.filename, filename)))
 	{
 	  break;
 	}
-
-      cur = cur->next;
     }
 
-  if (cur)
+  if (handle)
     {
-      ++cur->info.ref_count;
-      *handle = cur;
+      ++handle->info.ref_count;
+      *phandle = handle;
       goto done;
     }
 
-  cur = *handle;
+  handle = (lt__handle *) *phandle;
   if (filename)
     {
       /* Comment out the check of file permissions using access.
@@ -2408,13 +394,13 @@
 	 file_not_found() can detect what happened.
       if (access (filename, R_OK) != 0)
 	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+	  LT__SETERROR (FILE_NOT_FOUND);
 	  ++errors;
 	  goto done;
 	} */
 
-      cur->info.filename = lt_estrdup (filename);
-      if (!cur->info.filename)
+      handle->info.filename = lt__strdup (filename);
+      if (!handle->info.filename)
 	{
 	  ++errors;
 	  goto done;
@@ -2422,44 +408,70 @@
     }
   else
     {
-      cur->info.filename = 0;
+      handle->info.filename = 0;
     }
 
-  while (loader)
-    {
-      lt_user_data data = loader->dlloader_data;
+  {
+    lt_dlloader loader = lt_dlloader_next (0);
+    const lt_dlvtable *loader_vtable;
 
-      cur->module = loader->module_open (data, filename);
+    do
+      {
+	if (vtable)
+	  loader_vtable = vtable;
+	else
+	  loader_vtable = lt_dlloader_get (loader);
 
-      if (cur->module != 0)
-	{
-	  break;
-	}
-      loader = loader->next;
-    }
+#ifdef LT_DEBUG_LOADERS
+	fprintf (stderr, "Calling %s->module_open (%s)\n",
+		 (loader_vtable && loader_vtable->name) ? loader_vtable->name : "(null)",
+		 filename ? filename : "(null)");
+#endif
+	handle->module = (*loader_vtable->module_open) (loader_vtable->dlloader_data,
+							filename, advise);
+#ifdef LT_DEBUG_LOADERS
+	fprintf (stderr, "  Result: %s\n",
+		 handle->module ? "Success" : "Failed");
+#endif
 
-  if (!loader)
-    {
-      LT_DLFREE (cur->info.filename);
-      ++errors;
-      goto done;
-    }
+	if (handle->module != 0)
+	  {
+	    if (advise)
+	      {
+		handle->info.is_resident  = advise->is_resident;
+		handle->info.is_symglobal = advise->is_symglobal;
+		handle->info.is_symlocal  = advise->is_symlocal;
+	      }
+	    break;
+	  }
+      }
+    while (!vtable && (loader = lt_dlloader_next (loader)));
 
-  cur->loader	= loader;
-  LT_DLMUTEX_SETERROR (saved_error);
+    /* If VTABLE was given but couldn't open the module, or VTABLE wasn't
+       given but we exhausted all loaders without opening the module, bail
+       out!  */
+    if ((vtable && !handle->module)
+	|| (!vtable && !loader))
+      {
+	FREE (handle->info.filename);
+	++errors;
+	goto done;
+      }
 
- done:
-  LT_DLMUTEX_UNLOCK ();
+    handle->vtable = loader_vtable;
+  }
+
+  LT__SETERRORSTR (saved_error);
 
+ done:
   return errors;
 }
 
+
 static int
-tryall_dlopen_module (handle, prefix, dirname, dlname)
-     lt_dlhandle *handle;
-     const char *prefix;
-     const char *dirname;
-     const char *dlname;
+tryall_dlopen_module (lt_dlhandle *handle, const char *prefix,
+		      const char *dirname, const char *dlname,
+		      lt_dladvise advise)
 {
   int      error	= 0;
   char     *filename	= 0;
@@ -2469,7 +481,7 @@
   assert (handle);
   assert (dirname);
   assert (dlname);
-#ifdef LT_DIRSEP_CHAR
+#if defined(LT_DIRSEP_CHAR)
   /* Only canonicalized names (i.e. with DIRSEP chars already converted)
      should make it into this function:  */
   assert (strchr (dirname, LT_DIRSEP_CHAR) == 0);
@@ -2482,7 +494,7 @@
 
   /* Allocate memory, and combine DIRNAME and MODULENAME into it.
      The PREFIX (if any) is handled below.  */
-  filename  = LT_EMALLOC (char, dirname_len + 1 + filename_len + 1);
+  filename  = MALLOC (char, filename_len + 1);
   if (!filename)
     return 1;
 
@@ -2493,31 +505,27 @@
      shuffled.  Otherwise, attempt to open FILENAME as a module.  */
   if (prefix)
     {
-      error += tryall_dlopen_module (handle,
-				     (const char *) 0, prefix, filename);
+      error += tryall_dlopen_module (handle, (const char *) 0,
+				     prefix, filename, advise);
     }
-  else if (tryall_dlopen (handle, filename) != 0)
+  else if (tryall_dlopen (handle, filename, advise, 0) != 0)
     {
       ++error;
     }
 
-  LT_DLFREE (filename);
+  FREE (filename);
   return error;
 }
 
 static int
-find_module (handle, dir, libdir, dlname, old_name, installed)
-     lt_dlhandle *handle;
-     const char *dir;
-     const char *libdir;
-     const char *dlname;
-     const char *old_name;
-     int installed;
+find_module (lt_dlhandle *handle, const char *dir, const char *libdir,
+	     const char *dlname,  const char *old_name, int installed,
+	     lt_dladvise advise)
 {
   /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available.  */
-  if (old_name && tryall_dlopen (handle, old_name) == 0)
+  if (old_name && tryall_dlopen (handle, old_name, advise, 0) == 0)
     {
       return 0;
     }
@@ -2528,22 +536,23 @@
       /* try to open the installed module */
       if (installed && libdir)
 	{
-	  if (tryall_dlopen_module (handle,
-				    (const char *) 0, libdir, dlname) == 0)
+	  if (tryall_dlopen_module (handle, (const char *) 0,
+				    libdir, dlname, advise) == 0)
 	    return 0;
 	}
 
       /* try to open the not-installed module */
       if (!installed)
 	{
-	  if (tryall_dlopen_module (handle, dir, objdir, dlname) == 0)
+	  if (tryall_dlopen_module (handle, dir, objdir,
+				    dlname, advise) == 0)
 	    return 0;
 	}
 
       /* maybe it was moved to another directory */
       {
-	  if (dir && (tryall_dlopen_module (handle,
-				    (const char *) 0, dir, dlname) == 0))
+	  if (dir && (tryall_dlopen_module (handle, (const char *) 0,
+					    dir, dlname, advise) == 0))
 	    return 0;
       }
     }
@@ -2553,16 +562,14 @@
 
 
 static int
-canonicalize_path (path, pcanonical)
-     const char *path;
-     char **pcanonical;
+canonicalize_path (const char *path, char **pcanonical)
 {
   char *canonical = 0;
 
   assert (path && *path);
   assert (pcanonical);
 
-  canonical = LT_EMALLOC (char, 1+ LT_STRLEN (path));
+  canonical = MALLOC (char, 1+ LT_STRLEN (path));
   if (!canonical)
     return 1;
 
@@ -2584,7 +591,7 @@
 
 	/* Anything other than a directory separator is copied verbatim.  */
 	if ((path[src] != '/')
-#ifdef LT_DIRSEP_CHAR
+#if defined(LT_DIRSEP_CHAR)
 	    && (path[src] != LT_DIRSEP_CHAR)
 #endif
 	    )
@@ -2596,7 +603,7 @@
 	   NULL terminator.  */
 	else if ((path[1+ src] != LT_PATHSEP_CHAR)
 		 && (path[1+ src] != LT_EOS_CHAR)
-#ifdef LT_DIRSEP_CHAR
+#if defined(LT_DIRSEP_CHAR)
 		 && (path[1+ src] != LT_DIRSEP_CHAR)
 #endif
 		 && (path[1+ src] != '/'))
@@ -2616,10 +623,7 @@
 }
 
 static int
-argzize_path (path, pargz, pargz_len)
-     const char *path;
-     char **pargz;
-     size_t *pargz_len;
+argzize_path (const char *path, char **pargz, size_t *pargz_len)
 {
   error_t error;
 
@@ -2632,10 +636,10 @@
       switch (error)
 	{
 	case ENOMEM:
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+	  LT__SETERROR (NO_MEMORY);
 	  break;
 	default:
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (UNKNOWN));
+	  LT__SETERROR (UNKNOWN);
 	  break;
 	}
 
@@ -2650,26 +654,20 @@
    non-zero or all elements are exhausted.  If BASE_NAME is non-NULL,
    it is appended to each SEARCH_PATH element before FUNC is called.  */
 static int
-foreach_dirinpath (search_path, base_name, func, data1, data2)
-     const char *search_path;
-     const char *base_name;
-     foreach_callback_func *func;
-     lt_ptr data1;
-     lt_ptr data2;
+foreach_dirinpath (const char *search_path, const char *base_name,
+		   foreach_callback_func *func, void *data1, void *data2)
 {
   int	 result		= 0;
-  int	 filenamesize	= 0;
+  size_t filenamesize	= 0;
   size_t lenbase	= LT_STRLEN (base_name);
   size_t argz_len	= 0;
   char *argz		= 0;
   char *filename	= 0;
   char *canonical	= 0;
 
-  LT_DLMUTEX_LOCK ();
-
   if (!search_path || !*search_path)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+      LT__SETERROR (FILE_NOT_FOUND);
       goto cleanup;
     }
 
@@ -2685,11 +683,11 @@
       {
 	size_t lendir = LT_STRLEN (dir_name);
 
-	if (lendir +1 +lenbase >= filenamesize)
+	if (1+ lendir + lenbase >= filenamesize)
 	{
-	  LT_DLFREE (filename);
-	  filenamesize	= lendir +1 +lenbase +1; /* "/d" + '/' + "f" + '\0' */
-	  filename	= LT_EMALLOC (char, filenamesize);
+	  FREE (filename);
+	  filenamesize	= 1+ lendir + 1+ lenbase; /* "/d" + '/' + "f" + '\0' */
+	  filename	= MALLOC (char, filenamesize);
 	  if (!filename)
 	    goto cleanup;
 	}
@@ -2712,11 +710,9 @@
   }
 
  cleanup:
-  LT_DLFREE (argz);
-  LT_DLFREE (canonical);
-  LT_DLFREE (filename);
-
-  LT_DLMUTEX_UNLOCK ();
+  FREE (argz);
+  FREE (canonical);
+  FREE (filename);
 
   return result;
 }
@@ -2725,10 +721,7 @@
    in DATA1, and the opened FILE* structure address in DATA2.  Otherwise
    DATA1 is unchanged, but DATA2 is set to a pointer to NULL.  */
 static int
-find_file_callback (filename, data1, data2)
-     char *filename;
-     lt_ptr data1;
-     lt_ptr data2;
+find_file_callback (char *filename, void *data1, void *data2)
 {
   char	     **pdir	= (char **) data1;
   FILE	     **pfile	= (FILE **) data2;
@@ -2745,8 +738,8 @@
       if (dirend > filename)
 	*dirend   = LT_EOS_CHAR;
 
-      LT_DLFREE (*pdir);
-      *pdir   = lt_estrdup (filename);
+      FREE (*pdir);
+      *pdir   = lt__strdup (filename);
       is_done = (*pdir == 0) ? -1 : 1;
     }
 
@@ -2754,10 +747,7 @@
 }
 
 static FILE *
-find_file (search_path, base_name, pdir)
-     const char *search_path;
-     const char *base_name;
-     char **pdir;
+find_file (const char *search_path, const char *base_name, char **pdir)
 {
   FILE *file = 0;
 
@@ -2767,13 +757,11 @@
 }
 
 static int
-find_handle_callback (filename, data, ignored)
-     char *filename;
-     lt_ptr data;
-     lt_ptr ignored;
+find_handle_callback (char *filename, void *data, void *data2)
 {
   lt_dlhandle  *handle		= (lt_dlhandle *) data;
   int		notfound	= access (filename, R_OK);
+  lt_dladvise   advise		= (lt_dladvise) data2;
 
   /* Bail out if file cannot be read...  */
   if (notfound)
@@ -2781,7 +769,7 @@
 
   /* Try to dlopen the file, but do not continue searching in any
      case.  */
-  if (tryall_dlopen (handle, filename) != 0)
+  if (tryall_dlopen (handle, filename, advise, 0) != 0)
     *handle = 0;
 
   return 1;
@@ -2790,47 +778,48 @@
 /* If HANDLE was found return it, otherwise return 0.  If HANDLE was
    found but could not be opened, *HANDLE will be set to 0.  */
 static lt_dlhandle *
-find_handle (search_path, base_name, handle)
-     const char *search_path;
-     const char *base_name;
-     lt_dlhandle *handle;
+find_handle (const char *search_path, const char *base_name,
+	     lt_dlhandle *handle, lt_dladvise advise)
 {
   if (!search_path)
     return 0;
 
   if (!foreach_dirinpath (search_path, base_name, find_handle_callback,
-			  handle, 0))
+			  handle, advise))
     return 0;
 
   return handle;
 }
 
+#if !defined(LTDL_DLOPEN_DEPLIBS)
+static int
+load_deplibs (lt_dlhandle handle, char * LT__UNUSED deplibs)
+{
+  ((lt__handle *) handle)->depcount = 0;
+  return 0;
+}
+
+#else /* defined(LTDL_DLOPEN_DEPLIBS) */
 static int
-load_deplibs (handle, deplibs)
-     lt_dlhandle handle;
-     char *deplibs;
+load_deplibs (lt_dlhandle handle, char *deplibs)
 {
-#if LTDL_DLOPEN_DEPLIBS
   char	*p, *save_search_path = 0;
   int   depcount = 0;
   int	i;
   char	**names = 0;
-#endif
   int	errors = 0;
 
-  handle->depcount = 0;
+  ((lt__handle *) handle)->depcount = 0;
 
-#if LTDL_DLOPEN_DEPLIBS
   if (!deplibs)
     {
       return errors;
     }
   ++errors;
 
-  LT_DLMUTEX_LOCK ();
   if (user_search_path)
     {
-      save_search_path = lt_estrdup (user_search_path);
+      save_search_path = lt__strdup (user_search_path);
       if (!save_search_path)
 	goto cleanup;
     }
@@ -2839,10 +828,10 @@
   p = deplibs;
   while (*p)
     {
-      if (!isspace ((int) *p))
+      if (!isspace ((unsigned char) *p))
 	{
 	  char *end = p+1;
-	  while (*end && !isspace((int) *end))
+	  while (*end && !isspace((unsigned char) *end))
 	    {
 	      ++end;
 	    }
@@ -2870,13 +859,14 @@
 	}
     }
 
+
   if (!depcount)
     {
       errors = 0;
       goto cleanup;
     }
 
-  names = LT_EMALLOC (char *, depcount * sizeof (char*));
+  names = MALLOC (char *, depcount);
   if (!names)
     goto cleanup;
 
@@ -2885,14 +875,14 @@
   p = deplibs;
   while (*p)
     {
-      if (isspace ((int) *p))
+      if (isspace ((unsigned char) *p))
 	{
 	  ++p;
 	}
       else
 	{
 	  char *end = p+1;
-	  while (*end && !isspace ((int) *end))
+	  while (*end && !isspace ((unsigned char) *end))
 	    {
 	      ++end;
 	    }
@@ -2905,12 +895,12 @@
 	      if (strncmp(p, "-l", 2) == 0)
 		{
 		  size_t name_len = 3+ /* "lib" */ LT_STRLEN (p + 2);
-		  name = LT_EMALLOC (char, 1+ name_len);
+		  name = MALLOC (char, 1+ name_len);
 		  if (name)
 		    sprintf (name, "lib%s", p+2);
 		}
 	      else
-		name = lt_estrdup(p);
+		name = lt__strdup(p);
 
 	      if (!name)
 		goto cleanup_names;
@@ -2929,70 +919,67 @@
      later on if the loaded module cannot resolve all of its symbols.  */
   if (depcount)
     {
+      lt__handle *cur = (lt__handle *) handle;
       int	j = 0;
 
-      handle->deplibs = (lt_dlhandle*) LT_EMALLOC (lt_dlhandle *, depcount);
-      if (!handle->deplibs)
-	goto cleanup;
+      cur->deplibs = (lt_dlhandle *) MALLOC (lt__handle, depcount);
+      if (!cur->deplibs)
+	goto cleanup_names;
 
       for (i = 0; i < depcount; ++i)
 	{
-	  handle->deplibs[j] = lt_dlopenext(names[depcount-1-i]);
-	  if (handle->deplibs[j])
+	  cur->deplibs[j] = lt_dlopenext(names[depcount-1-i]);
+	  if (cur->deplibs[j])
 	    {
 	      ++j;
 	    }
 	}
 
-      handle->depcount	= j;	/* Number of successfully loaded deplibs */
+      cur->depcount	= j;	/* Number of successfully loaded deplibs */
       errors		= 0;
     }
 
  cleanup_names:
   for (i = 0; i < depcount; ++i)
     {
-      LT_DLFREE (names[i]);
+      FREE (names[i]);
     }
 
  cleanup:
-  LT_DLFREE (names);
+  FREE (names);
   /* restore the old search path */
-  if (user_search_path) {
-    LT_DLFREE (user_search_path);
-    user_search_path = save_search_path;
+  if (save_search_path) {
+    MEMREASSIGN (user_search_path, save_search_path);
   }
-  LT_DLMUTEX_UNLOCK ();
-
-#endif
 
   return errors;
 }
+#endif /* defined(LTDL_DLOPEN_DEPLIBS) */
 
 static int
-unload_deplibs (handle)
-     lt_dlhandle handle;
+unload_deplibs (lt_dlhandle handle)
 {
   int i;
   int errors = 0;
+  lt__handle *cur = (lt__handle *) handle;
 
-  if (handle->depcount)
+  if (cur->depcount)
     {
-      for (i = 0; i < handle->depcount; ++i)
+      for (i = 0; i < cur->depcount; ++i)
 	{
-	  if (!LT_DLIS_RESIDENT (handle->deplibs[i]))
+	  if (!LT_DLIS_RESIDENT (cur->deplibs[i]))
 	    {
-	      errors += lt_dlclose (handle->deplibs[i]);
+	      errors += lt_dlclose (cur->deplibs[i]);
 	    }
 	}
+      FREE (cur->deplibs);
     }
 
   return errors;
 }
 
 static int
-trim (dest, str)
-     char **dest;
-     const char *str;
+trim (char **dest, const char *str)
 {
   /* remove the leading and trailing "'" from str
      and store the result in dest */
@@ -3000,19 +987,19 @@
   size_t len	    = LT_STRLEN (str);
   char *tmp;
 
-  LT_DLFREE (*dest);
+  FREE (*dest);
 
   if (!end)
     return 1;
 
   if (len > 3 && str[0] == '\'')
     {
-      tmp = LT_EMALLOC (char, end - str);
+      tmp = MALLOC (char, end - str);
       if (!tmp)
 	return 1;
 
-      strncpy(tmp, &str[1], (end - str) - 1);
-      tmp[len-3] = LT_EOS_CHAR;
+      memcpy(tmp, &str[1], (end - str) - 1);
+      tmp[(end - str) - 1] = LT_EOS_CHAR;
       *dest = tmp;
     }
   else
@@ -3023,56 +1010,160 @@
   return 0;
 }
 
+/* Read the .la file FILE. */
 static int
-free_vars (dlname, oldname, libdir, deplibs)
-     char *dlname;
-     char *oldname;
-     char *libdir;
-     char *deplibs;
-{
-  LT_DLFREE (dlname);
-  LT_DLFREE (oldname);
-  LT_DLFREE (libdir);
-  LT_DLFREE (deplibs);
+parse_dotla_file(FILE *file, char **dlname, char **libdir, char **deplibs,
+    char **old_name, int *installed)
+{
+  int		errors = 0;
+  size_t	line_len = LT_FILENAME_MAX;
+  char *	line = MALLOC (char, line_len);
 
-  return 0;
+  if (!line)
+    {
+      LT__SETERROR (FILE_NOT_FOUND);
+      return 1;
+    }
+
+  while (!feof (file))
+    {
+      line[line_len-2] = '\0';
+      if (!fgets (line, (int) line_len, file))
+	{
+	  break;
+	}
+
+      /* Handle the case where we occasionally need to read a line
+	 that is longer than the initial buffer size.
+	 Behave even if the file contains NUL bytes due to corruption. */
+      while (line[line_len-2] != '\0' && line[line_len-2] != '\n' && !feof (file))
+	{
+	  line = REALLOC (char, line, line_len *2);
+	  if (!line)
+	    {
+	      ++errors;
+	      goto cleanup;
+	    }
+	  line[line_len * 2 - 2] = '\0';
+	  if (!fgets (&line[line_len -1], (int) line_len +1, file))
+	    {
+	      break;
+	    }
+	  line_len *= 2;
+	}
+
+      if (line[0] == '\n' || line[0] == '#')
+	{
+	  continue;
+	}
+
+#undef  STR_DLNAME
+#define STR_DLNAME	"dlname="
+      if (strncmp (line, STR_DLNAME, sizeof (STR_DLNAME) - 1) == 0)
+	{
+	  errors += trim (dlname, &line[sizeof (STR_DLNAME) - 1]);
+	}
+
+#undef  STR_OLD_LIBRARY
+#define STR_OLD_LIBRARY	"old_library="
+      else if (strncmp (line, STR_OLD_LIBRARY,
+	    sizeof (STR_OLD_LIBRARY) - 1) == 0)
+	{
+	  errors += trim (old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
+	}
+#undef  STR_LIBDIR
+#define STR_LIBDIR	"libdir="
+      else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
+	{
+	  errors += trim (libdir, &line[sizeof(STR_LIBDIR) - 1]);
+	}
+
+#undef  STR_DL_DEPLIBS
+#define STR_DL_DEPLIBS	"dependency_libs="
+      else if (strncmp (line, STR_DL_DEPLIBS,
+	    sizeof (STR_DL_DEPLIBS) - 1) == 0)
+	{
+	  errors += trim (deplibs, &line[sizeof (STR_DL_DEPLIBS) - 1]);
+	}
+      else if (streq (line, "installed=yes\n"))
+	{
+	  *installed = 1;
+	}
+      else if (streq (line, "installed=no\n"))
+	{
+	  *installed = 0;
+	}
+
+#undef  STR_LIBRARY_NAMES
+#define STR_LIBRARY_NAMES "library_names="
+      else if (!*dlname && strncmp (line, STR_LIBRARY_NAMES,
+	    sizeof (STR_LIBRARY_NAMES) - 1) == 0)
+	{
+	  char *last_libname;
+	  errors += trim (dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
+	  if (!errors
+	      && *dlname
+	      && (last_libname = strrchr (*dlname, ' ')) != 0)
+	    {
+	      last_libname = lt__strdup (last_libname + 1);
+	      if (!last_libname)
+		{
+		  ++errors;
+		  goto cleanup;
+		}
+	      MEMREASSIGN (*dlname, last_libname);
+	    }
+	}
+
+      if (errors)
+	break;
+    }
+cleanup:
+  FREE (line);
+  return errors;
 }
 
+
+/* Try to open FILENAME as a module. */
 static int
-try_dlopen (phandle, filename)
-     lt_dlhandle *phandle;
-     const char *filename;
+try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
+	    lt_dladvise advise)
 {
-  const char *	ext		= 0;
   const char *	saved_error	= 0;
   char *	canonical	= 0;
   char *	base_name	= 0;
   char *	dir		= 0;
   char *	name		= 0;
+  char *        attempt		= 0;
   int		errors		= 0;
   lt_dlhandle	newhandle;
 
   assert (phandle);
   assert (*phandle == 0);
 
-  LT_DLMUTEX_GETERROR (saved_error);
+#ifdef LT_DEBUG_LOADERS
+  fprintf (stderr, "try_dlopen (%s, %s)\n",
+	   filename ? filename : "(null)",
+	   ext ? ext : "(null)");
+#endif
+
+  LT__GETERROR (saved_error);
 
   /* dlopen self? */
   if (!filename)
     {
-      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
       if (*phandle == 0)
 	return 1;
 
-      memset (*phandle, 0, sizeof(struct lt_dlhandle_struct));
       newhandle	= *phandle;
 
       /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
-      LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);
+      ((lt__handle *) newhandle)->info.is_resident = 1;
 
-      if (tryall_dlopen (&newhandle, 0) != 0)
+      if (tryall_dlopen (&newhandle, 0, advise, 0) != 0)
 	{
-	  LT_DLFREE (*phandle);
+	  FREE (*phandle);
 	  return 1;
 	}
 
@@ -3081,9 +1172,24 @@
 
   assert (filename && *filename);
 
+  if (ext)
+    {
+      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);
+      if (!attempt)
+	return 1;
+
+      sprintf(attempt, "%s%s", filename, ext);
+    }
+  else
+    {
+      attempt = lt__strdup (filename);
+      if (!attempt)
+	return 1;
+    }
+
   /* Doing this immediately allows internal functions to safely
      assume only canonicalized paths are passed.  */
-  if (canonicalize_path (filename, &canonical) != 0)
+  if (canonicalize_path (attempt, &canonical) != 0)
     {
       ++errors;
       goto cleanup;
@@ -3096,7 +1202,7 @@
     {
       size_t dirlen = (1+ base_name) - canonical;
 
-      dir = LT_EMALLOC (char, 1+ dirlen);
+      dir = MALLOC (char, 1+ dirlen);
       if (!dir)
 	{
 	  ++errors;
@@ -3109,13 +1215,72 @@
       ++base_name;
     }
   else
-    base_name = canonical;
+    MEMREASSIGN (base_name, canonical);
 
   assert (base_name && *base_name);
 
-  /* Check whether we are opening a libtool module (.la extension).  */
   ext = strrchr (base_name, '.');
-  if (ext && strcmp (ext, archive_ext) == 0)
+  if (!ext)
+    {
+      ext = base_name + LT_STRLEN (base_name);
+    }
+
+  /* extract the module name from the file name */
+  name = MALLOC (char, ext - base_name + 1);
+  if (!name)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  /* canonicalize the module name */
+  {
+    int i;
+    for (i = 0; i < ext - base_name; ++i)
+      {
+	if (isalnum ((unsigned char)(base_name[i])))
+	  {
+	    name[i] = base_name[i];
+	  }
+	else
+	  {
+	    name[i] = '_';
+	  }
+      }
+    name[ext - base_name] = LT_EOS_CHAR;
+  }
+
+  /* Before trawling through the filesystem in search of a module,
+     check whether we are opening a preloaded module.  */
+  if (!dir)
+    {
+      const lt_dlvtable *vtable	= lt_dlloader_find ("lt_preopen");
+
+      if (vtable)
+	{
+	  *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
+
+	  if (*phandle == NULL)
+	    {
+	      ++errors;
+	      goto cleanup;
+	    }
+	  newhandle = *phandle;
+
+	  if (tryall_dlopen (&newhandle, attempt, advise, vtable) == 0)
+	    {
+	      goto register_handle;
+	    }
+
+	  /* If we're still here, there was no matching preloaded module,
+	     so put things back as we found them, and continue searching.  */
+	  FREE (*phandle);
+	  newhandle = NULL;
+	}
+    }
+
+  /* Check whether we are opening a libtool module (.la extension).  */
+  if (ext && streq (ext, archive_ext))
     {
       /* this seems to be a libtool module */
       FILE *	file	 = 0;
@@ -3123,52 +1288,22 @@
       char *	old_name = 0;
       char *	libdir	 = 0;
       char *	deplibs	 = 0;
-      char *    line	 = 0;
-      size_t	line_len;
 
       /* if we can't find the installed flag, it is probably an
 	 installed libtool archive, produced with an old version
 	 of libtool */
       int	installed = 1;
 
-      /* extract the module name from the file name */
-      name = LT_EMALLOC (char, ext - base_name + 1);
-      if (!name)
-	{
-	  ++errors;
-	  goto cleanup;
-	}
-
-      /* canonicalize the module name */
-      {
-        size_t i;
-        for (i = 0; i < ext - base_name; ++i)
-	  {
-	    if (isalnum ((int)(base_name[i])))
-	      {
-	        name[i] = base_name[i];
-	      }
-	    else
-	      {
-	        name[i] = '_';
-	      }
-	  }
-        name[ext - base_name] = LT_EOS_CHAR;
-      }
-
       /* Now try to open the .la file.  If there is no directory name
-         component, try to find it first in user_search_path and then other
-         prescribed paths.  Otherwise (or in any case if the module was not
-         yet found) try opening just the module name as passed.  */
+	 component, try to find it first in user_search_path and then other
+	 prescribed paths.  Otherwise (or in any case if the module was not
+	 yet found) try opening just the module name as passed.  */
       if (!dir)
 	{
-	  const char *search_path;
+	  const char *search_path = user_search_path;
 
-	  LT_DLMUTEX_LOCK ();
-	  search_path = user_search_path;
 	  if (search_path)
 	    file = find_file (user_search_path, base_name, &dir);
-	  LT_DLMUTEX_UNLOCK ();
 
 	  if (!file)
 	    {
@@ -3177,154 +1312,65 @@
 		file = find_file (search_path, base_name, &dir);
 	    }
 
-#ifdef LTDL_SHLIBPATH_VAR
+#if defined(LT_MODULE_PATH_VAR)
 	  if (!file)
 	    {
-	      search_path = getenv (LTDL_SHLIBPATH_VAR);
+	      search_path = getenv (LT_MODULE_PATH_VAR);
 	      if (search_path)
 		file = find_file (search_path, base_name, &dir);
 	    }
 #endif
-#ifdef LTDL_SYSSEARCHPATH
-	  if (!file && sys_search_path)
+#if defined(LT_DLSEARCH_PATH)
+	  if (!file && *sys_dlsearch_path)
 	    {
-	      file = find_file (sys_search_path, base_name, &dir);
+	      file = find_file (sys_dlsearch_path, base_name, &dir);
 	    }
 #endif
 	}
       if (!file)
 	{
-	  file = fopen (filename, LT_READTEXT_MODE);
-	}
-
-      /* If we didn't find the file by now, it really isn't there.  Set
-	 the status flag, and bail out.  */
-      if (!file)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-	  ++errors;
-	  goto cleanup;
-	}
-
-      line_len = LT_FILENAME_MAX;
-      line = LT_EMALLOC (char, line_len);
-      if (!line)
-	{
-	  fclose (file);
-	  ++errors;
-	  goto cleanup;
-	}
-
-      /* read the .la file */
-      while (!feof (file))
-	{
-	  if (!fgets (line, (int) line_len, file))
-	    {
-	      break;
-	    }
-
-	  /* Handle the case where we occasionally need to read a line
-	     that is longer than the initial buffer size.  */
-	  while ((line[LT_STRLEN(line) -1] != '\n') && (!feof (file)))
-	    {
-	      line = LT_DLREALLOC (char, line, line_len *2);
-	      if (!fgets (&line[line_len -1], (int) line_len +1, file))
-		{
-		  break;
-		}
-	      line_len *= 2;
-	    }
-
-	  if (line[0] == '\n' || line[0] == '#')
-	    {
-	      continue;
-	    }
-
-#undef  STR_DLNAME
-#define STR_DLNAME	"dlname="
-	  if (strncmp (line, STR_DLNAME, sizeof (STR_DLNAME) - 1) == 0)
-	    {
-	      errors += trim (&dlname, &line[sizeof (STR_DLNAME) - 1]);
-	    }
-
-#undef  STR_OLD_LIBRARY
-#define STR_OLD_LIBRARY	"old_library="
-	  else if (strncmp (line, STR_OLD_LIBRARY,
-			    sizeof (STR_OLD_LIBRARY) - 1) == 0)
-	    {
-	      errors += trim (&old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
-	    }
-#undef  STR_LIBDIR
-#define STR_LIBDIR	"libdir="
-	  else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
-	    {
-	      errors += trim (&libdir, &line[sizeof(STR_LIBDIR) - 1]);
-	    }
-
-#undef  STR_DL_DEPLIBS
-#define STR_DL_DEPLIBS	"dependency_libs="
-	  else if (strncmp (line, STR_DL_DEPLIBS,
-			    sizeof (STR_DL_DEPLIBS) - 1) == 0)
-	    {
-	      errors += trim (&deplibs, &line[sizeof (STR_DL_DEPLIBS) - 1]);
-	    }
-	  else if (strcmp (line, "installed=yes\n") == 0)
-	    {
-	      installed = 1;
-	    }
-	  else if (strcmp (line, "installed=no\n") == 0)
-	    {
-	      installed = 0;
-	    }
-
-#undef  STR_LIBRARY_NAMES
-#define STR_LIBRARY_NAMES "library_names="
-	  else if (! dlname && strncmp (line, STR_LIBRARY_NAMES,
-					sizeof (STR_LIBRARY_NAMES) - 1) == 0)
-	    {
-	      char *last_libname;
-	      errors += trim (&dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
-	      if (!errors
-		  && dlname
-		  && (last_libname = strrchr (dlname, ' ')) != 0)
-		{
-		  last_libname = lt_estrdup (last_libname + 1);
-		  if (!last_libname)
-		    {
-		      ++errors;
-		      goto cleanup;
-		    }
-		  LT_DLMEM_REASSIGN (dlname, last_libname);
-		}
-	    }
+	  file = fopen (attempt, LT_READTEXT_MODE);
+	}
 
-	  if (errors)
-	    break;
+      /* If we didn't find the file by now, it really isn't there.  Set
+	 the status flag, and bail out.  */
+      if (!file)
+	{
+	  LT__SETERROR (FILE_NOT_FOUND);
+	  ++errors;
+	  goto cleanup;
 	}
 
+      /* read the .la file */
+      if (parse_dotla_file(file, &dlname, &libdir, &deplibs,
+	    &old_name, &installed) != 0)
+	++errors;
+
       fclose (file);
-      LT_DLFREE (line);
 
       /* allocate the handle */
-      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
       if (*phandle == 0)
 	++errors;
 
       if (errors)
 	{
-	  free_vars (dlname, old_name, libdir, deplibs);
-	  LT_DLFREE (*phandle);
+	  FREE (dlname);
+	  FREE (old_name);
+	  FREE (libdir);
+	  FREE (deplibs);
+	  FREE (*phandle);
 	  goto cleanup;
 	}
 
       assert (*phandle);
 
-      memset (*phandle, 0, sizeof(struct lt_dlhandle_struct));
       if (load_deplibs (*phandle, deplibs) == 0)
 	{
 	  newhandle = *phandle;
 	  /* find_module may replace newhandle */
-	  if (find_module (&newhandle, dir, libdir, dlname, old_name, installed))
+	  if (find_module (&newhandle, dir, libdir, dlname, old_name,
+			   installed, advise))
 	    {
 	      unload_deplibs (*phandle);
 	      ++errors;
@@ -3335,10 +1381,14 @@
 	  ++errors;
 	}
 
-      free_vars (dlname, old_name, libdir, deplibs);
+      FREE (dlname);
+      FREE (old_name);
+      FREE (libdir);
+      FREE (deplibs);
+
       if (errors)
 	{
-	  LT_DLFREE (*phandle);
+	  FREE (*phandle);
 	  goto cleanup;
 	}
 
@@ -3350,195 +1400,250 @@
   else
     {
       /* not a libtool module */
-      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      *phandle = (lt_dlhandle) lt__zalloc (sizeof (lt__handle));
       if (*phandle == 0)
 	{
 	  ++errors;
 	  goto cleanup;
 	}
 
-      memset (*phandle, 0, sizeof (struct lt_dlhandle_struct));
       newhandle = *phandle;
 
       /* If the module has no directory name component, try to find it
 	 first in user_search_path and then other prescribed paths.
 	 Otherwise (or in any case if the module was not yet found) try
 	 opening just the module name as passed.  */
-      if ((dir || (!find_handle (user_search_path, base_name, &newhandle)
+      if ((dir || (!find_handle (user_search_path, base_name,
+				 &newhandle, advise)
 		   && !find_handle (getenv (LTDL_SEARCHPATH_VAR), base_name,
-				    &newhandle)
-#ifdef LTDL_SHLIBPATH_VAR
-		   && !find_handle (getenv (LTDL_SHLIBPATH_VAR), base_name,
-				    &newhandle)
-#endif
-#ifdef LTDL_SYSSEARCHPATH
-		   && !find_handle (sys_search_path, base_name, &newhandle)
+				    &newhandle, advise)
+#if defined(LT_MODULE_PATH_VAR)
+		   && !find_handle (getenv (LT_MODULE_PATH_VAR), base_name,
+				    &newhandle, advise)
+#endif
+#if defined(LT_DLSEARCH_PATH)
+		   && !find_handle (sys_dlsearch_path, base_name,
+				    &newhandle, advise)
 #endif
 		   )))
 	{
-          if (tryall_dlopen (&newhandle, filename) != 0)
-            {
-              newhandle = NULL;
-            }
+	  if (tryall_dlopen (&newhandle, attempt, advise, 0) != 0)
+	    {
+	      newhandle = NULL;
+	    }
 	}
 
       if (!newhandle)
 	{
-	  LT_DLFREE (*phandle);
+	  FREE (*phandle);
 	  ++errors;
 	  goto cleanup;
 	}
     }
 
  register_handle:
-  LT_DLMEM_REASSIGN (*phandle, newhandle);
+  MEMREASSIGN (*phandle, newhandle);
 
-  if ((*phandle)->info.ref_count == 0)
+  if (((lt__handle *) *phandle)->info.ref_count == 0)
     {
-      (*phandle)->info.ref_count	= 1;
-      LT_DLMEM_REASSIGN ((*phandle)->info.name, name);
+      ((lt__handle *) *phandle)->info.ref_count	= 1;
+      MEMREASSIGN (((lt__handle *) *phandle)->info.name, name);
 
-      LT_DLMUTEX_LOCK ();
-      (*phandle)->next		= handles;
-      handles			= *phandle;
-      LT_DLMUTEX_UNLOCK ();
+      ((lt__handle *) *phandle)->next	= (lt__handle *) handles;
+      handles				= *phandle;
     }
 
-  LT_DLMUTEX_SETERROR (saved_error);
+  LT__SETERRORSTR (saved_error);
 
  cleanup:
-  LT_DLFREE (dir);
-  LT_DLFREE (name);
-  LT_DLFREE (canonical);
+  FREE (dir);
+  FREE (attempt);
+  FREE (name);
+  if (!canonical)		/* was MEMREASSIGNed */
+    FREE (base_name);
+  FREE (canonical);
 
   return errors;
 }
 
-lt_dlhandle
-lt_dlopen (filename)
-     const char *filename;
-{
-  lt_dlhandle handle = 0;
-
-  /* Just incase we missed a code path in try_dlopen() that reports
-     an error, but forgets to reset handle... */
-  if (try_dlopen (&handle, filename) != 0)
-    return 0;
-
-  return handle;
-}
 
 /* If the last error messge store was `FILE_NOT_FOUND', then return
    non-zero.  */
 static int
-file_not_found ()
+file_not_found (void)
 {
   const char *error = 0;
 
-  LT_DLMUTEX_GETERROR (error);
-  if (error == LT_DLSTRERROR (FILE_NOT_FOUND))
+  LT__GETERROR (error);
+  if (error == LT__STRERROR (FILE_NOT_FOUND))
     return 1;
 
   return 0;
 }
 
-/* If FILENAME has an ARCHIVE_EXT or SHLIB_EXT extension, try to
-   open the FILENAME as passed.  Otherwise try appending ARCHIVE_EXT,
-   and if a file is still not found try again with SHLIB_EXT appended
-   instead.  */
-lt_dlhandle
-lt_dlopenext (filename)
-     const char *filename;
-{
-  lt_dlhandle	handle		= 0;
-  char *	tmp		= 0;
-  char *	ext		= 0;
-  size_t	len;
-  int		errors		= 0;
 
-  if (!filename)
-    {
-      return lt_dlopen (filename);
-    }
+/* Unless FILENAME already bears a suitable library extension, then
+   return 0.  */
+static int
+has_library_ext (const char *filename)
+{
+  char *	ext     = 0;
 
   assert (filename);
 
-  len = LT_STRLEN (filename);
   ext = strrchr (filename, '.');
 
-  /* If FILENAME already bears a suitable extension, there is no need
-     to try appending additional extensions.  */
-  if (ext && ((strcmp (ext, archive_ext) == 0)
-#ifdef LTDL_SHLIB_EXT
-	      || (strcmp (ext, shlib_ext) == 0)
+  if (ext && ((streq (ext, archive_ext))
+#if defined(LT_MODULE_EXT)
+	     || (streq (ext, shlib_ext))
 #endif
-      ))
+    ))
     {
-      return lt_dlopen (filename);
+      return 1;
     }
 
-  /* First try appending ARCHIVE_EXT.  */
-  tmp = LT_EMALLOC (char, len + LT_STRLEN (archive_ext) + 1);
-  if (!tmp)
-    return 0;
+  return 0;
+}
+
+
+/* Initialise and configure a user lt_dladvise opaque object.  */
+
+int
+lt_dladvise_init (lt_dladvise *padvise)
+{
+  lt__advise *advise = (lt__advise *) lt__zalloc (sizeof (lt__advise));
+  *padvise = advise;
+  return (advise ? 0 : 1);
+}
+
+int
+lt_dladvise_destroy (lt_dladvise *padvise)
+{
+  if (padvise)
+    FREE(*padvise);
+  return 0;
+}
+
+int
+lt_dladvise_ext (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->try_ext = 1;
+  return 0;
+}
+
+int
+lt_dladvise_resident (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_resident = 1;
+  return 0;
+}
+
+int
+lt_dladvise_local (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_symlocal = 1;
+  return 0;
+}
+
+int
+lt_dladvise_global (lt_dladvise *padvise)
+{
+  assert (padvise && *padvise);
+  ((lt__advise *) *padvise)->is_symglobal = 1;
+  return 0;
+}
+
+/* Libtool-1.5.x interface for loading a new module named FILENAME.  */
+lt_dlhandle
+lt_dlopen (const char *filename)
+{
+  return lt_dlopenadvise (filename, NULL);
+}
+
+
+/* If FILENAME has an ARCHIVE_EXT or MODULE_EXT extension, try to
+   open the FILENAME as passed.  Otherwise try appending ARCHIVE_EXT,
+   and if a file is still not found try again with MODULE_EXT appended
+   instead.  */
+lt_dlhandle
+lt_dlopenext (const char *filename)
+{
+  lt_dlhandle	handle	= 0;
+  lt_dladvise	advise;
+
+  if (!lt_dladvise_init (&advise) && !lt_dladvise_ext (&advise))
+    handle = lt_dlopenadvise (filename, advise);
+
+  lt_dladvise_destroy (&advise);
+  return handle;
+}
+
+
+lt_dlhandle
+lt_dlopenadvise (const char *filename, lt_dladvise advise)
+{
+  lt_dlhandle	handle	= 0;
+  int		errors	= 0;
 
-  strcpy (tmp, filename);
-  strcat (tmp, archive_ext);
-  errors = try_dlopen (&handle, tmp);
-
-  /* If we found FILENAME, stop searching -- whether we were able to
-     load the file as a module or not.  If the file exists but loading
-     failed, it is better to return an error message here than to
-     report FILE_NOT_FOUND when the alternatives (foo.so etc) are not
-     in the module search path.  */
-  if (handle || ((errors > 0) && !file_not_found ()))
+  /* Can't have symbols hidden and visible at the same time!  */
+  if (advise
+      && ((lt__advise *) advise)->is_symlocal
+      && ((lt__advise *) advise)->is_symglobal)
     {
-      LT_DLFREE (tmp);
-      return handle;
+      LT__SETERROR (CONFLICTING_FLAGS);
+      return 0;
     }
 
-#ifdef LTDL_SHLIB_EXT
-  /* Try appending SHLIB_EXT.   */
-  if (LT_STRLEN (shlib_ext) > LT_STRLEN (archive_ext))
-    {
-      LT_DLFREE (tmp);
-      tmp = LT_EMALLOC (char, len + LT_STRLEN (shlib_ext) + 1);
-      if (!tmp)
+  if (!filename
+      || !advise
+      || !((lt__advise *) advise)->try_ext
+      || has_library_ext (filename))
+    {
+      /* Just incase we missed a code path in try_dlopen() that reports
+	 an error, but forgot to reset handle... */
+      if (try_dlopen (&handle, filename, NULL, advise) != 0)
 	return 0;
 
-      strcpy (tmp, filename);
+      return handle;
     }
-  else
+  else if (filename && *filename)
     {
-      tmp[len] = LT_EOS_CHAR;
-    }
 
-  strcat(tmp, shlib_ext);
-  errors = try_dlopen (&handle, tmp);
+      /* First try appending ARCHIVE_EXT.  */
+      errors += try_dlopen (&handle, filename, archive_ext, advise);
 
-  /* As before, if the file was found but loading failed, return now
-     with the current error message.  */
-  if (handle || ((errors > 0) && !file_not_found ()))
-    {
-      LT_DLFREE (tmp);
-      return handle;
-    }
+      /* If we found FILENAME, stop searching -- whether we were able to
+	 load the file as a module or not.  If the file exists but loading
+	 failed, it is better to return an error message here than to
+	 report FILE_NOT_FOUND when the alternatives (foo.so etc) are not
+	 in the module search path.  */
+      if (handle || ((errors > 0) && !file_not_found ()))
+	return handle;
+
+#if defined(LT_MODULE_EXT)
+      /* Try appending SHLIB_EXT.   */
+      errors = try_dlopen (&handle, filename, shlib_ext, advise);
+
+      /* As before, if the file was found but loading failed, return now
+	 with the current error message.  */
+      if (handle || ((errors > 0) && !file_not_found ()))
+	return handle;
 #endif
+    }
 
   /* Still here?  Then we really did fail to locate any of the file
      names we tried.  */
-  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-  LT_DLFREE (tmp);
+  LT__SETERROR (FILE_NOT_FOUND);
   return 0;
 }
 
 
 static int
-lt_argz_insert (pargz, pargz_len, before, entry)
-     char **pargz;
-     size_t *pargz_len;
-     char *before;
-     const char *entry;
+lt_argz_insert (char **pargz, size_t *pargz_len, char *before,
+		const char *entry)
 {
   error_t error;
 
@@ -3547,17 +1652,17 @@
   if (before)
     error = argz_insert (pargz, pargz_len, before, entry);
   else
-    error = argz_append (pargz, pargz_len, entry, 1 + LT_STRLEN (entry));
+    error = argz_append (pargz, pargz_len, entry, 1 + strlen (entry));
 
   if (error)
     {
       switch (error)
 	{
 	case ENOMEM:
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+	  LT__SETERROR (NO_MEMORY);
 	  break;
 	default:
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (UNKNOWN));
+	  LT__SETERROR (UNKNOWN);
 	  break;
 	}
       return 1;
@@ -3567,10 +1672,7 @@
 }
 
 static int
-lt_argz_insertinorder (pargz, pargz_len, entry)
-     char **pargz;
-     size_t *pargz_len;
-     const char *entry;
+lt_argz_insertinorder (char **pargz, size_t *pargz_len, const char *entry)
 {
   char *before = 0;
 
@@ -3591,11 +1693,8 @@
 }
 
 static int
-lt_argz_insertdir (pargz, pargz_len, dirnam, dp)
-     char **pargz;
-     size_t *pargz_len;
-     const char *dirnam;
-     struct dirent *dp;
+lt_argz_insertdir (char **pargz, size_t *pargz_len, const char *dirnam,
+		   struct dirent *dp)
 {
   char   *buf	    = 0;
   size_t buf_len    = 0;
@@ -3609,7 +1708,7 @@
   assert (dp);
 
   dir_len = LT_STRLEN (dirnam);
-  end     = dp->d_name + LT_D_NAMLEN(dp);
+  end     = dp->d_name + D_NAMLEN(dp);
 
   /* Ignore version numbers.  */
   {
@@ -3636,7 +1735,7 @@
   /* Prepend the directory name.  */
   end_offset	= end - dp->d_name;
   buf_len	= dir_len + 1+ end_offset;
-  buf		= LT_EMALLOC (char, 1+ buf_len);
+  buf		= MALLOC (char, 1+ buf_len);
   if (!buf)
     return ++errors;
 
@@ -3651,16 +1750,13 @@
   if (lt_argz_insertinorder (pargz, pargz_len, buf) != 0)
     ++errors;
 
-  LT_DLFREE (buf);
+  FREE (buf);
 
   return errors;
 }
 
 static int
-list_files_by_dir (dirnam, pargz, pargz_len)
-     const char *dirnam;
-     char **pargz;
-     size_t *pargz_len;
+list_files_by_dir (const char *dirnam, char **pargz, size_t *pargz_len)
 {
   DIR	*dirp	  = 0;
   int    errors	  = 0;
@@ -3695,13 +1791,9 @@
 /* If there are any files in DIRNAME, call the function passed in
    DATA1 (with the name of each file and DATA2 as arguments).  */
 static int
-foreachfile_callback (dirname, data1, data2)
-     char *dirname;
-     lt_ptr data1;
-     lt_ptr data2;
+foreachfile_callback (char *dirname, void *data1, void *data2)
 {
-  int (*func) LT_PARAMS((const char *filename, lt_ptr data))
-	= (int (*) LT_PARAMS((const char *filename, lt_ptr data))) data1;
+  file_worker_func *func = *(file_worker_func **) data1;
 
   int	  is_done  = 0;
   char   *argz     = 0;
@@ -3720,7 +1812,7 @@
   }
 
  cleanup:
-  LT_DLFREE (argz);
+  FREE (argz);
 
   return is_done;
 }
@@ -3733,43 +1825,43 @@
    libfoo.so, libfoo.so.1, libfoo.so.1.0.0).  If SEARCH_PATH is NULL,
    then the same directories that lt_dlopen would search are examined.  */
 int
-lt_dlforeachfile (search_path, func, data)
-     const char *search_path;
-     int (*func) LT_PARAMS ((const char *filename, lt_ptr data));
-     lt_ptr data;
+lt_dlforeachfile (const char *search_path,
+		  int (*func) (const char *filename, void *data),
+		  void *data)
 {
   int is_done = 0;
+  file_worker_func **fpptr = &func;
 
   if (search_path)
     {
       /* If a specific path was passed, search only the directories
 	 listed in it.  */
       is_done = foreach_dirinpath (search_path, 0,
-				   foreachfile_callback, func, data);
+				   foreachfile_callback, fpptr, data);
     }
   else
     {
       /* Otherwise search the default paths.  */
       is_done = foreach_dirinpath (user_search_path, 0,
-				   foreachfile_callback, func, data);
+				   foreachfile_callback, fpptr, data);
       if (!is_done)
 	{
-	  is_done = foreach_dirinpath (getenv("LTDL_LIBRARY_PATH"), 0,
-				       foreachfile_callback, func, data);
+	  is_done = foreach_dirinpath (getenv(LTDL_SEARCHPATH_VAR), 0,
+				       foreachfile_callback, fpptr, data);
 	}
 
-#ifdef LTDL_SHLIBPATH_VAR
+#if defined(LT_MODULE_PATH_VAR)
       if (!is_done)
 	{
-	  is_done = foreach_dirinpath (getenv(LTDL_SHLIBPATH_VAR), 0,
-				       foreachfile_callback, func, data);
+	  is_done = foreach_dirinpath (getenv(LT_MODULE_PATH_VAR), 0,
+				       foreachfile_callback, fpptr, data);
 	}
 #endif
-#ifdef LTDL_SYSSEARCHPATH
-      if (!is_done)
+#if defined(LT_DLSEARCH_PATH)
+      if (!is_done && *sys_dlsearch_path)
 	{
-	  is_done = foreach_dirinpath (getenv(LTDL_SYSSEARCHPATH), 0,
-				       foreachfile_callback, func, data);
+	  is_done = foreach_dirinpath (sys_dlsearch_path, 0,
+				       foreachfile_callback, fpptr, data);
 	}
 #endif
     }
@@ -3778,16 +1870,13 @@
 }
 
 int
-lt_dlclose (handle)
-     lt_dlhandle handle;
+lt_dlclose (lt_dlhandle handle)
 {
-  lt_dlhandle cur, last;
+  lt__handle *cur, *last;
   int errors = 0;
 
-  LT_DLMUTEX_LOCK ();
-
   /* check whether the handle is valid */
-  last = cur = handles;
+  last = cur = (lt__handle *) handles;
   while (cur && handle != cur)
     {
       last = cur;
@@ -3796,79 +1885,79 @@
 
   if (!cur)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT__SETERROR (INVALID_HANDLE);
       ++errors;
       goto done;
     }
 
-  handle->info.ref_count--;
+  cur = (lt__handle *) handle;
+  cur->info.ref_count--;
 
   /* Note that even with resident modules, we must track the ref_count
      correctly incase the user decides to reset the residency flag
      later (even though the API makes no provision for that at the
      moment).  */
-  if (handle->info.ref_count <= 0 && !LT_DLIS_RESIDENT (handle))
+  if (cur->info.ref_count <= 0 && !LT_DLIS_RESIDENT (cur))
     {
-      lt_user_data data = handle->loader->dlloader_data;
+      lt_user_data data = cur->vtable->dlloader_data;
 
-      if (handle != handles)
+      if (cur != handles)
 	{
-	  last->next = handle->next;
+	  last->next = cur->next;
 	}
       else
 	{
-	  handles = handle->next;
+	  handles = cur->next;
 	}
 
-      errors += handle->loader->module_close (data, handle->module);
-      errors += unload_deplibs(handle);
+      errors += cur->vtable->module_close (data, cur->module);
+      errors += unload_deplibs (handle);
 
       /* It is up to the callers to free the data itself.  */
-      LT_DLFREE (handle->caller_data);
+      FREE (cur->interface_data);
 
-      LT_DLFREE (handle->info.filename);
-      LT_DLFREE (handle->info.name);
-      LT_DLFREE (handle);
+      FREE (cur->info.filename);
+      FREE (cur->info.name);
+      FREE (cur);
 
       goto done;
     }
 
   if (LT_DLIS_RESIDENT (handle))
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CLOSE_RESIDENT_MODULE));
+      LT__SETERROR (CLOSE_RESIDENT_MODULE);
       ++errors;
     }
 
  done:
-  LT_DLMUTEX_UNLOCK ();
-
   return errors;
 }
 
-lt_ptr
-lt_dlsym (handle, symbol)
-     lt_dlhandle handle;
-     const char *symbol;
+void *
+lt_dlsym (lt_dlhandle place, const char *symbol)
 {
   size_t lensym;
   char	lsym[LT_SYMBOL_LENGTH];
   char	*sym;
-  lt_ptr address;
+  void *address;
   lt_user_data data;
+  lt__handle *handle;
 
-  if (!handle)
+  if (!place)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT__SETERROR (INVALID_HANDLE);
       return 0;
     }
 
+  handle = (lt__handle *) place;
+
   if (!symbol)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+      LT__SETERROR (SYMBOL_NOT_FOUND);
       return 0;
     }
 
-  lensym = LT_STRLEN (symbol) + LT_STRLEN (handle->loader->sym_prefix)
+  lensym = LT_STRLEN (symbol) + LT_STRLEN (handle->vtable->sym_prefix)
 					+ LT_STRLEN (handle->info.name);
 
   if (lensym + LT_SYMBOL_OVERHEAD < LT_SYMBOL_LENGTH)
@@ -3877,25 +1966,25 @@
     }
   else
     {
-      sym = LT_EMALLOC (char, lensym + LT_SYMBOL_OVERHEAD + 1);
+      sym = MALLOC (char, lensym + LT_SYMBOL_OVERHEAD + 1);
       if (!sym)
 	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (BUFFER_OVERFLOW));
+	  LT__SETERROR (BUFFER_OVERFLOW);
 	  return 0;
 	}
     }
 
-  data = handle->loader->dlloader_data;
+  data = handle->vtable->dlloader_data;
   if (handle->info.name)
     {
       const char *saved_error;
 
-      LT_DLMUTEX_GETERROR (saved_error);
+      LT__GETERROR (saved_error);
 
       /* this is a libtool module */
-      if (handle->loader->sym_prefix)
+      if (handle->vtable->sym_prefix)
 	{
-	  strcpy(sym, handle->loader->sym_prefix);
+	  strcpy(sym, handle->vtable->sym_prefix);
 	  strcat(sym, handle->info.name);
 	}
       else
@@ -3907,22 +1996,22 @@
       strcat(sym, symbol);
 
       /* try "modulename_LTX_symbol" */
-      address = handle->loader->find_sym (data, handle->module, sym);
+      address = handle->vtable->find_sym (data, handle->module, sym);
       if (address)
 	{
 	  if (sym != lsym)
 	    {
-	      LT_DLFREE (sym);
+	      FREE (sym);
 	    }
 	  return address;
 	}
-      LT_DLMUTEX_SETERROR (saved_error);
+      LT__SETERRORSTR (saved_error);
     }
 
   /* otherwise try "symbol" */
-  if (handle->loader->sym_prefix)
+  if (handle->vtable->sym_prefix)
     {
-      strcpy(sym, handle->loader->sym_prefix);
+      strcpy(sym, handle->vtable->sym_prefix);
       strcat(sym, symbol);
     }
   else
@@ -3930,31 +2019,28 @@
       strcpy(sym, symbol);
     }
 
-  address = handle->loader->find_sym (data, handle->module, sym);
+  address = handle->vtable->find_sym (data, handle->module, sym);
   if (sym != lsym)
     {
-      LT_DLFREE (sym);
+      FREE (sym);
     }
 
   return address;
 }
 
 const char *
-lt_dlerror ()
+lt_dlerror (void)
 {
   const char *error;
 
-  LT_DLMUTEX_GETERROR (error);
-  LT_DLMUTEX_SETERROR (0);
+  LT__GETERROR (error);
+  LT__SETERRORSTR (0);
 
   return error ? error : NULL;
 }
 
 static int
-lt_dlpath_insertdir (ppath, before, dir)
-     char **ppath;
-     char *before;
-     const char *dir;
+lt_dlpath_insertdir (char **ppath, char *before, const char *dir)
 {
   int    errors		= 0;
   char  *canonical	= 0;
@@ -3978,11 +2064,11 @@
       assert (!before);		/* BEFORE cannot be set without PPATH.  */
       assert (dir);		/* Without DIR, don't call this function!  */
 
-      *ppath = lt_estrdup (dir);
+      *ppath = lt__strdup (dir);
       if (*ppath == 0)
 	++errors;
 
-      return errors;
+      goto cleanup;
     }
 
   assert (ppath && *ppath);
@@ -4001,7 +2087,7 @@
   if (before)
     {
       assert (*ppath <= before);
-      assert (before - *ppath <= strlen (*ppath));
+      assert ((int) (before - *ppath) <= (int) strlen (*ppath));
 
       before = before - *ppath + argz;
     }
@@ -4013,127 +2099,108 @@
     }
 
   argz_stringify (argz, argz_len, LT_PATHSEP_CHAR);
-  LT_DLMEM_REASSIGN (*ppath,  argz);
+  MEMREASSIGN(*ppath, argz);
 
  cleanup:
-  LT_DLFREE (canonical);
-  LT_DLFREE (argz);
+  FREE (argz);
+  FREE (canonical);
 
   return errors;
 }
 
 int
-lt_dladdsearchdir (search_dir)
-     const char *search_dir;
+lt_dladdsearchdir (const char *search_dir)
 {
   int errors = 0;
 
   if (search_dir && *search_dir)
     {
-      LT_DLMUTEX_LOCK ();
       if (lt_dlpath_insertdir (&user_search_path, 0, search_dir) != 0)
 	++errors;
-      LT_DLMUTEX_UNLOCK ();
     }
 
   return errors;
 }
 
 int
-lt_dlinsertsearchdir (before, search_dir)
-     const char *before;
-     const char *search_dir;
+lt_dlinsertsearchdir (const char *before, const char *search_dir)
 {
   int errors = 0;
 
   if (before)
     {
-      LT_DLMUTEX_LOCK ();
       if ((before < user_search_path)
 	  || (before >= user_search_path + LT_STRLEN (user_search_path)))
 	{
-	  LT_DLMUTEX_UNLOCK ();
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_POSITION));
+	  LT__SETERROR (INVALID_POSITION);
 	  return 1;
 	}
-      LT_DLMUTEX_UNLOCK ();
     }
 
   if (search_dir && *search_dir)
     {
-      LT_DLMUTEX_LOCK ();
       if (lt_dlpath_insertdir (&user_search_path,
 			       (char *) before, search_dir) != 0)
 	{
 	  ++errors;
 	}
-      LT_DLMUTEX_UNLOCK ();
     }
 
   return errors;
 }
 
 int
-lt_dlsetsearchpath (search_path)
-     const char *search_path;
+lt_dlsetsearchpath (const char *search_path)
 {
   int   errors	    = 0;
 
-  LT_DLMUTEX_LOCK ();
-  LT_DLFREE (user_search_path);
-  LT_DLMUTEX_UNLOCK ();
+  FREE (user_search_path);
 
   if (!search_path || !LT_STRLEN (search_path))
     {
       return errors;
     }
 
-  LT_DLMUTEX_LOCK ();
   if (canonicalize_path (search_path, &user_search_path) != 0)
     ++errors;
-  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
 
 const char *
-lt_dlgetsearchpath ()
+lt_dlgetsearchpath (void)
 {
   const char *saved_path;
 
-  LT_DLMUTEX_LOCK ();
   saved_path = user_search_path;
-  LT_DLMUTEX_UNLOCK ();
 
   return saved_path;
 }
 
 int
-lt_dlmakeresident (handle)
-     lt_dlhandle handle;
+lt_dlmakeresident (lt_dlhandle handle)
 {
   int errors = 0;
 
   if (!handle)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT__SETERROR (INVALID_HANDLE);
       ++errors;
     }
   else
     {
-      LT_DLSET_FLAG (handle, LT_DLRESIDENT_FLAG);
+      ((lt__handle *) handle)->info.is_resident = 1;
     }
 
   return errors;
 }
 
 int
-lt_dlisresident	(handle)
-     lt_dlhandle handle;
+lt_dlisresident	(lt_dlhandle handle)
 {
   if (!handle)
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT__SETERROR (INVALID_HANDLE);
       return -1;
     }
 
@@ -4142,103 +2209,66 @@
 
 
 
-
 /* --- MODULE INFORMATION --- */
 
-const lt_dlinfo *
-lt_dlgetinfo (handle)
-     lt_dlhandle handle;
-{
-  if (!handle)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
-      return 0;
-    }
-
-  return &(handle->info);
-}
-
-lt_dlhandle
-lt_dlhandle_next (place)
-     lt_dlhandle place;
-{
-  return place ? place->next : handles;
-}
-
-int
-lt_dlforeach (func, data)
-     int (*func) LT_PARAMS((lt_dlhandle handle, lt_ptr data));
-     lt_ptr data;
-{
-  int errors = 0;
-  lt_dlhandle cur;
-
-  LT_DLMUTEX_LOCK ();
-
-  cur = handles;
-  while (cur)
-    {
-      lt_dlhandle tmp = cur;
-
-      cur = cur->next;
-      if ((*func) (tmp, data))
-	{
-	  ++errors;
-	  break;
-	}
+typedef struct {
+  const char *id_string;
+  lt_dlhandle_interface *iface;
+} lt__interface_id;
+
+lt_dlinterface_id
+lt_dlinterface_register (const char *id_string, lt_dlhandle_interface *iface)
+{
+  lt__interface_id *interface_id = (lt__interface_id *) lt__malloc (sizeof *interface_id);
+
+  /* If lt__malloc fails, it will LT__SETERROR (NO_MEMORY), which
+     can then be detected with lt_dlerror() if we return 0.  */
+  if (interface_id)
+    {
+      interface_id->id_string = lt__strdup (id_string);
+      if (!interface_id->id_string)
+	FREE (interface_id);
+      else
+	interface_id->iface = iface;
     }
 
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
+  return (lt_dlinterface_id) interface_id;
 }
 
-lt_dlcaller_id
-lt_dlcaller_register ()
+void lt_dlinterface_free (lt_dlinterface_id key)
 {
-  static lt_dlcaller_id last_caller_id = 0;
-  int result;
-
-  LT_DLMUTEX_LOCK ();
-  result = ++last_caller_id;
-  LT_DLMUTEX_UNLOCK ();
-
-  return result;
+  lt__interface_id *interface_id = (lt__interface_id *)key;
+  FREE (interface_id->id_string);
+  FREE (interface_id);
 }
 
-lt_ptr
-lt_dlcaller_set_data (key, handle, data)
-     lt_dlcaller_id key;
-     lt_dlhandle handle;
-     lt_ptr data;
+void *
+lt_dlcaller_set_data (lt_dlinterface_id key, lt_dlhandle handle, void *data)
 {
   int n_elements = 0;
-  lt_ptr stale = (lt_ptr) 0;
+  void *stale = (void *) 0;
+  lt__handle *cur = (lt__handle *) handle;
   int i;
 
-  /* This needs to be locked so that the caller data can be updated
-     simultaneously by different threads.  */
-  LT_DLMUTEX_LOCK ();
-
-  if (handle->caller_data)
-    while (handle->caller_data[n_elements].key)
+  if (cur->interface_data)
+    while (cur->interface_data[n_elements].key)
       ++n_elements;
 
   for (i = 0; i < n_elements; ++i)
     {
-      if (handle->caller_data[i].key == key)
+      if (cur->interface_data[i].key == key)
 	{
-	  stale = handle->caller_data[i].data;
+	  stale = cur->interface_data[i].data;
 	  break;
 	}
     }
 
-  /* Ensure that there is enough room in this handle's caller_data
+  /* Ensure that there is enough room in this handle's interface_data
      array to accept a new element (and an empty end marker).  */
   if (i == n_elements)
     {
-      lt_caller_data *temp
-	= LT_DLREALLOC (lt_caller_data, handle->caller_data, 2+ n_elements);
+      lt_interface_data *temp
+	= REALLOC (lt_interface_data, cur->interface_data, 2+ n_elements);
 
       if (!temp)
 	{
@@ -4246,265 +2276,120 @@
 	  goto done;
 	}
 
-      handle->caller_data = temp;
+      cur->interface_data = temp;
 
-      /* We only need this if we needed to allocate a new caller_data.  */
-      handle->caller_data[i].key  = key;
-      handle->caller_data[1+ i].key = 0;
+      /* We only need this if we needed to allocate a new interface_data.  */
+      cur->interface_data[i].key	= key;
+      cur->interface_data[1+ i].key	= 0;
     }
 
-  handle->caller_data[i].data = data;
+  cur->interface_data[i].data = data;
 
  done:
-  LT_DLMUTEX_UNLOCK ();
-
   return stale;
 }
 
-lt_ptr
-lt_dlcaller_get_data  (key, handle)
-     lt_dlcaller_id key;
-     lt_dlhandle handle;
-{
-  lt_ptr result = (lt_ptr) 0;
-
-  /* This needs to be locked so that the caller data isn't updated by
-     another thread part way through this function.  */
-  LT_DLMUTEX_LOCK ();
-
-  /* Locate the index of the element with a matching KEY.  */
-  {
-    int i;
-    for (i = 0; handle->caller_data[i].key; ++i)
-      {
-	if (handle->caller_data[i].key == key)
-	  {
-	    result = handle->caller_data[i].data;
-	    break;
-	  }
-      }
-  }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return result;
-}
-
-
-
-/* --- USER MODULE LOADER API --- */
-
-
-int
-lt_dlloader_add (place, dlloader, loader_name)
-     lt_dlloader *place;
-     const struct lt_user_dlloader *dlloader;
-     const char *loader_name;
-{
-  int errors = 0;
-  lt_dlloader *node = 0, *ptr = 0;
-
-  if ((dlloader == 0)	/* diagnose null parameters */
-      || (dlloader->module_open == 0)
-      || (dlloader->module_close == 0)
-      || (dlloader->find_sym == 0))
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
-      return 1;
-    }
-
-  /* Create a new dlloader node with copies of the user callbacks.  */
-  node = LT_EMALLOC (lt_dlloader, 1);
-  if (!node)
-    return 1;
-
-  node->next		= 0;
-  node->loader_name	= loader_name;
-  node->sym_prefix	= dlloader->sym_prefix;
-  node->dlloader_exit	= dlloader->dlloader_exit;
-  node->module_open	= dlloader->module_open;
-  node->module_close	= dlloader->module_close;
-  node->find_sym	= dlloader->find_sym;
-  node->dlloader_data	= dlloader->dlloader_data;
-
-  LT_DLMUTEX_LOCK ();
-  if (!loaders)
-    {
-      /* If there are no loaders, NODE becomes the list! */
-      loaders = node;
-    }
-  else if (!place)
-    {
-      /* If PLACE is not set, add NODE to the end of the
-	 LOADERS list. */
-      for (ptr = loaders; ptr->next; ptr = ptr->next)
-	{
-	  /*NOWORK*/;
-	}
-
-      ptr->next = node;
-    }
-  else if (loaders == place)
-    {
-      /* If PLACE is the first loader, NODE goes first. */
-      node->next = place;
-      loaders = node;
-    }
-  else
-    {
-      /* Find the node immediately preceding PLACE. */
-      for (ptr = loaders; ptr->next != place; ptr = ptr->next)
-	{
-	  /*NOWORK*/;
-	}
-
-      if (ptr->next != place)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
-	  ++errors;
-	}
-      else
-	{
-	  /* Insert NODE between PTR and PLACE. */
-	  node->next = place;
-	  ptr->next  = node;
-	}
-    }
-
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
-}
-
-int
-lt_dlloader_remove (loader_name)
-     const char *loader_name;
+void *
+lt_dlcaller_get_data (lt_dlinterface_id key, lt_dlhandle handle)
 {
-  lt_dlloader *place = lt_dlloader_find (loader_name);
-  lt_dlhandle handle;
-  int errors = 0;
-
-  if (!place)
-    {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
-      return 1;
-    }
-
-  LT_DLMUTEX_LOCK ();
-
-  /* Fail if there are any open modules which use this loader. */
-  for  (handle = handles; handle; handle = handle->next)
-    {
-      if (handle->loader == place)
-	{
-	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (REMOVE_LOADER));
-	  ++errors;
-	  goto done;
-	}
-    }
+  void *result = (void *) 0;
+  lt__handle *cur = (lt__handle *) handle;
 
-  if (place == loaders)
-    {
-      /* PLACE is the first loader in the list. */
-      loaders = loaders->next;
-    }
-  else
+  /* Locate the index of the element with a matching KEY.  */
+  if (cur->interface_data)
     {
-      /* Find the loader before the one being removed. */
-      lt_dlloader *prev;
-      for (prev = loaders; prev->next; prev = prev->next)
+      int i;
+      for (i = 0; cur->interface_data[i].key; ++i)
 	{
-	  if (!strcmp (prev->next->loader_name, loader_name))
+	  if (cur->interface_data[i].key == key)
 	    {
+	      result = cur->interface_data[i].data;
 	      break;
 	    }
 	}
-
-      place = prev->next;
-      prev->next = prev->next->next;
-    }
-
-  if (place->dlloader_exit)
-    {
-      errors = place->dlloader_exit (place->dlloader_data);
     }
 
-  LT_DLFREE (place);
-
- done:
-  LT_DLMUTEX_UNLOCK ();
-
-  return errors;
+  return result;
 }
 
-lt_dlloader *
-lt_dlloader_next (place)
-     lt_dlloader *place;
+const lt_dlinfo *
+lt_dlgetinfo (lt_dlhandle handle)
 {
-  lt_dlloader *next;
-
-  LT_DLMUTEX_LOCK ();
-  next = place ? place->next : loaders;
-  LT_DLMUTEX_UNLOCK ();
+  if (!handle)
+    {
+      LT__SETERROR (INVALID_HANDLE);
+      return 0;
+    }
 
-  return next;
+  return &(((lt__handle *) handle)->info);
 }
 
-const char *
-lt_dlloader_name (place)
-     lt_dlloader *place;
+
+lt_dlhandle
+lt_dlhandle_iterate (lt_dlinterface_id iface, lt_dlhandle place)
 {
-  const char *name = 0;
+  lt__handle *handle = (lt__handle *) place;
+  lt__interface_id *iterator = (lt__interface_id *) iface;
 
-  if (place)
-    {
-      LT_DLMUTEX_LOCK ();
-      name = place ? place->loader_name : 0;
-      LT_DLMUTEX_UNLOCK ();
-    }
+  assert (iface); /* iface is a required argument */
+
+  if (!handle)
+    handle = (lt__handle *) handles;
   else
+    handle = handle->next;
+
+  /* advance while the interface check fails */
+  while (handle && iterator->iface
+	 && ((*iterator->iface) (handle, iterator->id_string) != 0))
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      handle = handle->next;
     }
 
-  return name;
+  return (lt_dlhandle) handle;
 }
 
-lt_user_data *
-lt_dlloader_data (place)
-     lt_dlloader *place;
+
+lt_dlhandle
+lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)
 {
-  lt_user_data *data = 0;
+  lt_dlhandle handle = 0;
 
-  if (place)
-    {
-      LT_DLMUTEX_LOCK ();
-      data = place ? &(place->dlloader_data) : 0;
-      LT_DLMUTEX_UNLOCK ();
-    }
-  else
+  assert (iface); /* iface is a required argument */
+
+  while ((handle = lt_dlhandle_iterate (iface, handle)))
     {
-      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      lt__handle *cur = (lt__handle *) handle;
+      if (cur && cur->info.name && streq (cur->info.name, module_name))
+	break;
     }
 
-  return data;
+  return handle;
 }
 
-lt_dlloader *
-lt_dlloader_find (loader_name)
-     const char *loader_name;
+
+int
+lt_dlhandle_map (lt_dlinterface_id iface,
+		 int (*func) (lt_dlhandle handle, void *data), void *data)
 {
-  lt_dlloader *place = 0;
+  lt__interface_id *iterator = (lt__interface_id *) iface;
+  lt__handle *cur = (lt__handle *) handles;
 
-  LT_DLMUTEX_LOCK ();
-  for (place = loaders; place; place = place->next)
+  assert (iface); /* iface is a required argument */
+
+  while (cur)
     {
-      if (strcmp (place->loader_name, loader_name) == 0)
+      int errorcode = 0;
+
+      /* advance while the interface check fails */
+      while (cur && iterator->iface
+	     && ((*iterator->iface) (cur, iterator->id_string) != 0))
 	{
-	  break;
+	  cur = cur->next;
 	}
+
+      if ((errorcode = (*func) (cur, data)) != 0)
+	return errorcode;
     }
-  LT_DLMUTEX_UNLOCK ();
 
-  return place;
+  return 0;
 }
--- origsrc/libtunepimp-0.5.3/libltdl/ltdl.h	2006-06-19 13:36:49.000000000 -0500
+++ src/libtunepimp-0.5.3/libltdl/ltdl.h	2008-06-16 01:20:05.250000000 -0500
@@ -1,218 +1,88 @@
 /* ltdl.h -- generic dlopen functions
-   Copyright (C) 1998-2000 Free Software Foundation, Inc.
-   Originally by Thomas Tanner <tanner@ffii.org>
-   This file is part of GNU Libtool.
 
-This library is free software; you can redistribute it and/or
+   Copyright (C) 1998-2000, 2004, 2005,
+                 2007 Free Software Foundation, Inc.
+   Written by Thomas Tanner, 1998
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2 of the License, or (at your option) any later version.
 
 As a special exception to the GNU Lesser General Public License,
 if you distribute this file as part of a program or library that
-is built using GNU libtool, you may include it under the same
-distribution terms that you use for the rest of that program.
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
 
-This library is distributed in the hope that it will be useful,
+GNU Libltdl is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free
-Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301  USA
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
 
 /* Only include this header file once. */
-#ifndef LTDL_H
+#if !defined(LTDL_H)
 #define LTDL_H 1
 
-#include <sys/types.h>		/* for size_t declaration */
-
-
-/* --- MACROS FOR PORTABILITY --- */
-
-
-/* Saves on those hard to debug '\0' typos....  */
-#define LT_EOS_CHAR	'\0'
-
-/* LTDL_BEGIN_C_DECLS should be used at the beginning of your declarations,
-   so that C++ compilers don't mangle their names.  Use LTDL_END_C_DECLS at
-   the end of C declarations. */
-#ifdef __cplusplus
-# define LT_BEGIN_C_DECLS	extern "C" {
-# define LT_END_C_DECLS		}
-#else
-# define LT_BEGIN_C_DECLS	/* empty */
-# define LT_END_C_DECLS		/* empty */
-#endif
+#include <libltdl/lt_system.h>
+#include <libltdl/lt_error.h>
+#include <libltdl/lt_dlloader.h>
 
 LT_BEGIN_C_DECLS
 
 
-/* LT_PARAMS is a macro used to wrap function prototypes, so that compilers
-   that don't understand ANSI C prototypes still work, and ANSI C
-   compilers can issue warnings about type mismatches.  */
-#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(WIN32) || defined(__cplusplus)
-# define LT_PARAMS(protos)	protos
-# define lt_ptr		void*
-#else
-# define LT_PARAMS(protos)	()
-# define lt_ptr		char*
-#endif
-
-/* LT_STMT_START/END are used to create macros which expand to a
-   a single compound statement in a portable way.  */
-#if defined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)
-#  define LT_STMT_START        (void)(
-#  define LT_STMT_END          )
-#else
-#  if (defined (sun) || defined (__sun__))
-#    define LT_STMT_START      if (1)
-#    define LT_STMT_END        else (void)0
-#  else
-#    define LT_STMT_START      do
-#    define LT_STMT_END        while (0)
-#  endif
-#endif
-
-/* LT_CONC creates a new concatenated symbol for the compiler
-   in a portable way.  */
-#if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)
-#  define LT_CONC(s,t)	s##t
-#else
-#  define LT_CONC(s,t)	s/**/t
-#endif
-
 /* LT_STRLEN can be used safely on NULL pointers.  */
 #define LT_STRLEN(s)	(((s) && (s)[0]) ? strlen (s) : 0)
 
-
-
-/* --- WINDOWS SUPPORT --- */
-
-
-/* Canonicalise Windows and Cygwin recognition macros.  */
-#ifdef __CYGWIN32__
-#  ifndef __CYGWIN__
-#    define __CYGWIN__ __CYGWIN32__
-#  endif
-#endif
-#if defined(_WIN32) || defined(WIN32)
-#  ifndef __WINDOWS__
-#    ifdef _WIN32
-#      define __WINDOWS__ _WIN32
-#    else
-#      ifdef WIN32
-#        define __WINDOWS__ WIN32
-#      endif
-#    endif
-#  endif
-#endif
-
-
-#ifdef __WINDOWS__
-#  ifndef __CYGWIN__
-/* LT_DIRSEP_CHAR is accepted *in addition* to '/' as a directory
-   separator when it is set. */
-#    define LT_DIRSEP_CHAR	'\\'
-#    define LT_PATHSEP_CHAR	';'
-#  endif
-#endif
-#ifndef LT_PATHSEP_CHAR
-#  define LT_PATHSEP_CHAR	':'
-#endif
-
-/* DLL building support on win32 hosts;  mostly to workaround their
-   ridiculous implementation of data symbol exporting. */
-#ifndef LT_SCOPE
-#  ifdef __WINDOWS__
-#    ifdef DLL_EXPORT		/* defined by libtool (if required) */
-#      define LT_SCOPE	__declspec(dllexport)
-#    endif
-#    ifdef LIBLTDL_DLL_IMPORT	/* define if linking with this dll */
-#      define LT_SCOPE	extern __declspec(dllimport)
-#    endif
-#  endif
-#  ifndef LT_SCOPE		/* static linking or !__WINDOWS__ */
-#    define LT_SCOPE	extern
-#  endif
-#endif
-
-
-#if defined(_MSC_VER) /* Visual Studio */
-#  define R_OK 4
-#endif
-
-
 
 /* --- DYNAMIC MODULE LOADING API --- */
 
 
-typedef	struct lt_dlhandle_struct *lt_dlhandle;	/* A loaded module.  */
+typedef	void * lt_dlhandle;	/* A loaded module.  */
 
 /* Initialisation and finalisation functions for libltdl. */
-LT_SCOPE	int	    lt_dlinit		LT_PARAMS((void));
-LT_SCOPE	int	    lt_dlexit		LT_PARAMS((void));
+LT_SCOPE int	    lt_dlinit		(void);
+LT_SCOPE int	    lt_dlexit		(void);
 
 /* Module search path manipulation.  */
-LT_SCOPE	int	    lt_dladdsearchdir	 LT_PARAMS((const char *search_dir));
-LT_SCOPE	int	    lt_dlinsertsearchdir LT_PARAMS((const char *before,
-						    const char *search_dir));
-LT_SCOPE	int 	    lt_dlsetsearchpath	 LT_PARAMS((const char *search_path));
-LT_SCOPE	const char *lt_dlgetsearchpath	 LT_PARAMS((void));
-LT_SCOPE	int	    lt_dlforeachfile	 LT_PARAMS((
+LT_SCOPE int	    lt_dladdsearchdir	 (const char *search_dir);
+LT_SCOPE int	    lt_dlinsertsearchdir (const char *before,
+						  const char *search_dir);
+LT_SCOPE int 	    lt_dlsetsearchpath	 (const char *search_path);
+LT_SCOPE const char *lt_dlgetsearchpath	 (void);
+LT_SCOPE int	    lt_dlforeachfile	 (
 			const char *search_path,
-			int (*func) (const char *filename, lt_ptr data),
-			lt_ptr data));
-
-/* Portable libltdl versions of the system dlopen() API. */
-LT_SCOPE	lt_dlhandle lt_dlopen		LT_PARAMS((const char *filename));
-LT_SCOPE	lt_dlhandle lt_dlopenext	LT_PARAMS((const char *filename));
-LT_SCOPE	lt_ptr	    lt_dlsym		LT_PARAMS((lt_dlhandle handle,
-						     const char *name));
-LT_SCOPE	const char *lt_dlerror		LT_PARAMS((void));
-LT_SCOPE	int	    lt_dlclose		LT_PARAMS((lt_dlhandle handle));
-
-/* Module residency management. */
-LT_SCOPE	int	    lt_dlmakeresident	LT_PARAMS((lt_dlhandle handle));
-LT_SCOPE	int	    lt_dlisresident	LT_PARAMS((lt_dlhandle handle));
-
-
+			int (*func) (const char *filename, void *data),
+			void *data);
 
-
-/* --- MUTEX LOCKING --- */
-
-
-typedef void	lt_dlmutex_lock		LT_PARAMS((void));
-typedef void	lt_dlmutex_unlock	LT_PARAMS((void));
-typedef void	lt_dlmutex_seterror	LT_PARAMS((const char *errmsg));
-typedef const char *lt_dlmutex_geterror	LT_PARAMS((void));
-
-LT_SCOPE	int	lt_dlmutex_register	LT_PARAMS((lt_dlmutex_lock *lock,
-					    lt_dlmutex_unlock *unlock,
-					    lt_dlmutex_seterror *seterror,
-					    lt_dlmutex_geterror *geterror));
+/* User module loading advisors.  */
+LT_SCOPE int	    lt_dladvise_init	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_destroy  (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_ext	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_resident (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_local	 (lt_dladvise *advise);
+LT_SCOPE int	    lt_dladvise_global   (lt_dladvise *advise);
 
-
-
-
-/* --- MEMORY HANDLING --- */
-
-
-/* By default, the realloc function pointer is set to our internal
-   realloc implementation which iself uses lt_dlmalloc and lt_dlfree.
-   libltdl relies on a featureful realloc, but if you are sure yours
-   has the right semantics then you can assign it directly.  Generally,
-   it is safe to assign just a malloc() and a free() function.  */
-LT_SCOPE  lt_ptr   (*lt_dlmalloc)	LT_PARAMS((size_t size));
-LT_SCOPE  lt_ptr   (*lt_dlrealloc)	LT_PARAMS((lt_ptr ptr, size_t size));
-LT_SCOPE  void	   (*lt_dlfree)		LT_PARAMS((lt_ptr ptr));
+/* Portable libltdl versions of the system dlopen() API. */
+LT_SCOPE lt_dlhandle lt_dlopen		(const char *filename);
+LT_SCOPE lt_dlhandle lt_dlopenext	(const char *filename);
+LT_SCOPE lt_dlhandle lt_dlopenadvise	(const char *filename,
+					 lt_dladvise advise);
+LT_SCOPE void *	    lt_dlsym		(lt_dlhandle handle, const char *name);
+LT_SCOPE const char *lt_dlerror		(void);
+LT_SCOPE int	    lt_dlclose		(lt_dlhandle handle);
 
 
 
-
 /* --- PRELOADED MODULE SUPPORT --- */
 
 
@@ -220,17 +90,21 @@
    symbols for a dlpreopened module. */
 typedef struct {
   const char *name;
-  lt_ptr      address;
+  void       *address;
 } lt_dlsymlist;
 
-LT_SCOPE	int	lt_dlpreload	LT_PARAMS((const lt_dlsymlist *preloaded));
-LT_SCOPE	int	lt_dlpreload_default
-				LT_PARAMS((const lt_dlsymlist *preloaded));
+typedef int lt_dlpreload_callback_func (lt_dlhandle handle);
+
+LT_SCOPE int	lt_dlpreload	     (const lt_dlsymlist *preloaded);
+LT_SCOPE int	lt_dlpreload_default (const lt_dlsymlist *preloaded);
+LT_SCOPE int	lt_dlpreload_open    (const char *originator,
+				      lt_dlpreload_callback_func *func);
 
-#define LTDL_SET_PRELOADED_SYMBOLS() 		LT_STMT_START{	\
+#define lt_preloaded_symbols	lt__PROGRAM__LTX_preloaded_symbols
+#define LTDL_SET_PRELOADED_SYMBOLS() 			LT_STMT_START{	\
 	extern const lt_dlsymlist lt_preloaded_symbols[];		\
 	lt_dlpreload_default(lt_preloaded_symbols);			\
-						}LT_STMT_END
+							}LT_STMT_END
 
 
 
@@ -238,129 +112,50 @@
 /* --- MODULE INFORMATION --- */
 
 
-/* Read only information pertaining to a loaded module. */
-typedef	struct {
-  char	*filename;		/* file name */
-  char	*name;			/* module name */
-  int	ref_count;		/* number of times lt_dlopened minus
-				   number of times lt_dlclosed. */
-} lt_dlinfo;
-
-LT_SCOPE	const lt_dlinfo	*lt_dlgetinfo	    LT_PARAMS((lt_dlhandle handle));
-LT_SCOPE	lt_dlhandle	lt_dlhandle_next    LT_PARAMS((lt_dlhandle place));
-LT_SCOPE	int		lt_dlforeach	    LT_PARAMS((
-				int (*func) (lt_dlhandle handle, lt_ptr data),
-				lt_ptr data));
-
 /* Associating user data with loaded modules. */
-typedef unsigned lt_dlcaller_id;
+typedef void * lt_dlinterface_id;
+typedef int lt_dlhandle_interface (lt_dlhandle handle, const char *id_string);
 
-LT_SCOPE	lt_dlcaller_id	lt_dlcaller_register  LT_PARAMS((void));
-LT_SCOPE	lt_ptr		lt_dlcaller_set_data  LT_PARAMS((lt_dlcaller_id key,
-						lt_dlhandle handle,
-						lt_ptr data));
-LT_SCOPE	lt_ptr		lt_dlcaller_get_data  LT_PARAMS((lt_dlcaller_id key,
-						lt_dlhandle handle));
+LT_SCOPE lt_dlinterface_id lt_dlinterface_register (const char *id_string,
+					  lt_dlhandle_interface *iface);
+LT_SCOPE void	lt_dlinterface_free (lt_dlinterface_id key);
+LT_SCOPE void *	lt_dlcaller_set_data  (lt_dlinterface_id key,
+					  lt_dlhandle handle, void *data);
+LT_SCOPE void *	lt_dlcaller_get_data  (lt_dlinterface_id key,
+					  lt_dlhandle handle);
 
 
-
-/* --- USER MODULE LOADER API --- */
-
-
-typedef	struct lt_dlloader	lt_dlloader;
-typedef lt_ptr			lt_user_data;
-typedef lt_ptr			lt_module;
-
-/* Function pointer types for creating user defined module loaders. */
-typedef lt_module   lt_module_open	LT_PARAMS((lt_user_data loader_data,
-					    const char *filename));
-typedef int	    lt_module_close	LT_PARAMS((lt_user_data loader_data,
-					    lt_module handle));
-typedef lt_ptr	    lt_find_sym		LT_PARAMS((lt_user_data loader_data,
-					    lt_module handle,
-					    const char *symbol));
-typedef int	    lt_dlloader_exit	LT_PARAMS((lt_user_data loader_data));
-
-struct lt_user_dlloader {
-  const char	       *sym_prefix;
-  lt_module_open       *module_open;
-  lt_module_close      *module_close;
-  lt_find_sym	       *find_sym;
-  lt_dlloader_exit     *dlloader_exit;
-  lt_user_data		dlloader_data;
-};
-
-LT_SCOPE	lt_dlloader    *lt_dlloader_next    LT_PARAMS((lt_dlloader *place));
-LT_SCOPE	lt_dlloader    *lt_dlloader_find    LT_PARAMS((
-						const char *loader_name));
-LT_SCOPE	const char     *lt_dlloader_name    LT_PARAMS((lt_dlloader *place));
-LT_SCOPE	lt_user_data   *lt_dlloader_data    LT_PARAMS((lt_dlloader *place));
-LT_SCOPE	int		lt_dlloader_add     LT_PARAMS((lt_dlloader *place,
-				const struct lt_user_dlloader *dlloader,
-				const char *loader_name));
-LT_SCOPE	int		lt_dlloader_remove  LT_PARAMS((
-						const char *loader_name));
-
-
-
-/* --- ERROR MESSAGE HANDLING --- */
-
+/* Read only information pertaining to a loaded module. */
+typedef	struct {
+  char *	filename;	/* file name */
+  char *	name;		/* module name */
+  int		ref_count;	/* number of times lt_dlopened minus
+				   number of times lt_dlclosed. */
+  unsigned int	is_resident:1;	/* module can't be unloaded. */
+  unsigned int	is_symglobal:1;	/* module symbols can satisfy
+				   subsequently loaded modules.  */
+  unsigned int	is_symlocal:1;	/* module symbols are only available
+				   locally. */
+} lt_dlinfo;
 
-/* Defining error strings alongside their symbolic names in a macro in
-   this way allows us to expand the macro in different contexts with
-   confidence that the enumeration of symbolic names will map correctly
-   onto the table of error strings.  */
-#define lt_dlerror_table						\
-    LT_ERROR(UNKNOWN,		    "unknown error")			\
-    LT_ERROR(DLOPEN_NOT_SUPPORTED,  "dlopen support not available")	\
-    LT_ERROR(INVALID_LOADER,	    "invalid loader")			\
-    LT_ERROR(INIT_LOADER,	    "loader initialization failed")	\
-    LT_ERROR(REMOVE_LOADER,	    "loader removal failed")		\
-    LT_ERROR(FILE_NOT_FOUND,	    "file not found")			\
-    LT_ERROR(DEPLIB_NOT_FOUND,      "dependency library not found")	\
-    LT_ERROR(NO_SYMBOLS,	    "no symbols defined")		\
-    LT_ERROR(CANNOT_OPEN,	    "can't open the module")		\
-    LT_ERROR(CANNOT_CLOSE,	    "can't close the module")		\
-    LT_ERROR(SYMBOL_NOT_FOUND,      "symbol not found")			\
-    LT_ERROR(NO_MEMORY,		    "not enough memory")		\
-    LT_ERROR(INVALID_HANDLE,	    "invalid module handle")		\
-    LT_ERROR(BUFFER_OVERFLOW,	    "internal buffer overflow")		\
-    LT_ERROR(INVALID_ERRORCODE,     "invalid errorcode")		\
-    LT_ERROR(SHUTDOWN,		    "library already shutdown")		\
-    LT_ERROR(CLOSE_RESIDENT_MODULE, "can't close resident module")	\
-    LT_ERROR(INVALID_MUTEX_ARGS,    "invalid mutex handler registration") \
-    LT_ERROR(INVALID_POSITION,	    "invalid search path insert position")
-
-/* Enumerate the symbolic error names. */
-enum {
-#define LT_ERROR(name, diagnostic)	LT_CONC(LT_ERROR_, name),
-	lt_dlerror_table
-#undef LT_ERROR
-
-	LT_ERROR_MAX
-};
-
-/* These functions are only useful from inside custom module loaders. */
-LT_SCOPE	int	lt_dladderror	LT_PARAMS((const char *diagnostic));
-LT_SCOPE	int	lt_dlseterror	LT_PARAMS((int errorcode));
+LT_SCOPE const lt_dlinfo *lt_dlgetinfo	    (lt_dlhandle handle);
 
+LT_SCOPE lt_dlhandle	lt_dlhandle_iterate (lt_dlinterface_id iface,
+					     lt_dlhandle place);
+LT_SCOPE lt_dlhandle	lt_dlhandle_fetch   (lt_dlinterface_id iface,
+					     const char *module_name);
+LT_SCOPE int		lt_dlhandle_map	    (lt_dlinterface_id iface,
+				int (*func) (lt_dlhandle handle, void *data),
+				void *data);
 
 
-
-/* --- SOURCE COMPATIBILITY WITH OLD LIBLTDL --- */
 
+/* Deprecated module residency management API. */
+LT_SCOPE int	    lt_dlmakeresident	(lt_dlhandle handle);
+LT_SCOPE int	    lt_dlisresident	(lt_dlhandle handle);
 
-#ifdef LT_NON_POSIX_NAMESPACE
-#  define lt_ptr_t		lt_ptr
-#  define lt_module_t		lt_module
-#  define lt_module_open_t	lt_module_open
-#  define lt_module_close_t	lt_module_close
-#  define lt_find_sym_t		lt_find_sym
-#  define lt_dlloader_exit_t	lt_dlloader_exit
-#  define lt_dlloader_t		lt_dlloader
-#  define lt_dlloader_data_t	lt_user_data
-#endif
+#define lt_ptr void *
 
 LT_END_C_DECLS
 
-#endif /* !LTDL_H */
+#endif /*!defined(LTDL_H)*/
--- origsrc/libtunepimp-0.5.3/libltdl/m4/argz.m4	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/m4/argz.m4	2008-06-16 01:19:49.218750000 -0500
@@ -0,0 +1,79 @@
+# Portability macros for glibc argz.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+#   Written by Gary V. Vaughan <gary@gnu.org>
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 5 argz.m4
+
+AC_DEFUN([gl_FUNC_ARGZ],
+[gl_PREREQ_ARGZ
+
+AC_CHECK_HEADERS([argz.h], [], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_TYPES([error_t],
+  [],
+  [AC_DEFINE([error_t], [int],
+   [Define to a type to use for `error_t' if it is not otherwise available.])
+   AC_DEFINE([__error_t_defined], [1], [Define so that glibc/gnulib argp.h
+    does not typedef error_t.])],
+  [#if defined(HAVE_ARGZ_H)
+#  include <argz.h>
+#endif])
+
+ARGZ_H=
+AC_CHECK_FUNCS([argz_add argz_append argz_count argz_create_sep argz_insert \
+	argz_next argz_stringify], [], [ARGZ_H=argz.h; AC_LIBOBJ([argz])])
+
+dnl if have system argz functions, allow forced use of 
+dnl libltdl-supplied implementation (and default to do so
+dnl on "known bad" systems). Could use a runtime check, but
+dnl (a) detecting malloc issues is notoriously unreliable
+dnl (b) only known system that declares argz functions,
+dnl     provides them, yet they are broken, is cygwin
+dnl     releases prior to 16-Mar-2007 (1.5.24 and earlier)
+dnl So, it's more straightforward simply to special case 
+dnl this for known bad systems.
+AS_IF([test -z "$ARGZ_H"],
+    [AC_CACHE_CHECK(
+        [if argz actually works],
+        [lt_cv_sys_argz_works],
+        [[case $host_os in #(
+	 *cygwin*)
+	   lt_cv_sys_argz_works=no
+	   if test "$cross_compiling" != no; then
+	     lt_cv_sys_argz_works="guessing no"
+	   else
+	     lt_sed_extract_leading_digits='s/^\([0-9\.]*\).*/\1/'
+	     save_IFS=$IFS
+	     IFS=-.
+	     set x `uname -r | sed -e "$lt_sed_extract_leading_digits"`
+	     IFS=$save_IFS
+	     lt_os_major=${2-0}
+	     lt_os_minor=${3-0}
+	     lt_os_micro=${4-0}
+	     if test "$lt_os_major" -gt 1 \
+		|| { test "$lt_os_major" -eq 1 \
+		  && { test "$lt_os_minor" -gt 5 \
+		    || { test "$lt_os_minor" -eq 5 \
+		      && test "$lt_os_micro" -gt 24; }; }; }; then
+	       lt_cv_sys_argz_works=yes
+	     fi
+	   fi
+	   ;; #(
+	 *) lt_cv_sys_argz_works=yes ;;
+	 esac]])
+     AS_IF([test $lt_cv_sys_argz_works = yes],
+        [AC_DEFINE([HAVE_WORKING_ARGZ], 1,
+                   [This value is set to 1 to indicate that the system argz facility works])],
+        [ARGZ_H=argz.h
+        AC_LIBOBJ([argz])])])
+
+AC_SUBST([ARGZ_H])
+])
+
+# Prerequisites of lib/argz.c.
+AC_DEFUN([gl_PREREQ_ARGZ], [:])
--- origsrc/libtunepimp-0.5.3/libltdl/m4/ltdl.m4	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/m4/ltdl.m4	2008-06-16 01:19:49.984375000 -0500
@@ -0,0 +1,823 @@
+# ltdl.m4 - Configure ltdl for the target system. -*-Autoconf-*-
+#
+#   Copyright (C) 1999-2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Thomas Tanner, 1999
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 14 LTDL_INIT
+
+# LT_CONFIG_LTDL_DIR(DIRECTORY, [LTDL-MODE])
+# ------------------------------------------
+# DIRECTORY contains the libltdl sources.  It is okay to call this
+# function multiple times, as long as the same DIRECTORY is always given.
+AC_DEFUN([LT_CONFIG_LTDL_DIR],
+[AC_BEFORE([$0], [LTDL_INIT])
+_$0($*)
+])# LT_CONFIG_LTDL_DIR
+
+# We break this out into a separate macro, so that we can call it safely
+# internally without being caught accidentally by the sed scan in libtoolize.
+m4_defun([_LT_CONFIG_LTDL_DIR],
+[dnl remove trailing slashes
+m4_pushdef([_ARG_DIR], m4_bpatsubst([$1], [/*$]))
+m4_case(_LTDL_DIR,
+	[], [dnl only set lt_ltdl_dir if _ARG_DIR is not simply `.'
+	     m4_if(_ARG_DIR, [.],
+	             [],
+		 [m4_define([_LTDL_DIR], _ARG_DIR)
+	          _LT_SHELL_INIT([lt_ltdl_dir=']_ARG_DIR['])])],
+    [m4_if(_ARG_DIR, _LTDL_DIR,
+	    [],
+	[m4_fatal([multiple libltdl directories: `]_LTDL_DIR[', `]_ARG_DIR['])])])
+m4_popdef([_ARG_DIR])
+])# _LT_CONFIG_LTDL_DIR
+
+# Initialise:
+m4_define([_LTDL_DIR], [])
+
+
+# _LT_BUILD_PREFIX
+# ----------------
+# If Autoconf is new enough, expand to `${top_build_prefix}', otherwise
+# to `${top_builddir}/'.
+m4_define([_LT_BUILD_PREFIX],
+[m4_ifdef([AC_AUTOCONF_VERSION],
+   [m4_if(m4_version_compare(m4_defn([AC_AUTOCONF_VERSION]), [2.62]),
+	  [-1], [m4_ifdef([_AC_HAVE_TOP_BUILD_PREFIX],
+	  		  [${top_build_prefix}],
+			  [${top_builddir}/])],
+	  [${top_build_prefix}])],
+   [${top_builddir}/])[]dnl
+])
+
+
+# LTDL_CONVENIENCE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl convenience library and
+# LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-convenience to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called here.  LIBLTDL will be prefixed with
+# '${top_build_prefix}' if available, otherwise with '${top_builddir}/',
+# and LTDLINCL will be prefixed with '${top_srcdir}/' (note the single
+# quotes!).  If your package is not flat and you're not using automake,
+# define top_build_prefix, top_builddir, and top_srcdir appropriately
+# in your Makefiles.
+AC_DEFUN([LTDL_CONVENIENCE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_CONVENIENCE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_CONVENIENCE
+
+# AC_LIBLTDL_CONVENIENCE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_CONVENIENCE],
+[_LT_CONFIG_LTDL_DIR([$1])
+_LTDL_CONVENIENCE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_CONVENIENCE], [])
+
+
+# _LTDL_CONVENIENCE
+# -----------------
+# Code shared by LTDL_CONVENIENCE and LTDL_INIT([convenience]).
+m4_defun([_LTDL_CONVENIENCE],
+[case $enable_ltdl_convenience in
+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;
+  "") enable_ltdl_convenience=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-convenience" ;;
+esac
+LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdlc.la"
+LTDLDEPS=$LIBLTDL
+LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# _LTDL_CONVENIENCE
+
+
+# LTDL_INSTALLABLE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl installable library
+# and LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-install to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called from here.  If an installed libltdl
+# is not found, LIBLTDL will be prefixed with '${top_build_prefix}' if
+# available, otherwise with '${top_builddir}/', and LTDLINCL will be
+# prefixed with '${top_srcdir}/' (note the single quotes!).  If your
+# package is not flat and you're not using automake, define top_build_prefix,
+# top_builddir, and top_srcdir appropriately in your Makefiles.
+# In the future, this macro may have to be called after LT_INIT.
+AC_DEFUN([LTDL_INSTALLABLE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_INSTALLABLE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_INSTALLABLE
+
+# AC_LIBLTDL_INSTALLABLE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_INSTALLABLE],
+[_LT_CONFIG_LTDL_DIR([$1])
+_LTDL_INSTALLABLE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_INSTALLABLE], [])
+
+
+# _LTDL_INSTALLABLE
+# -----------------
+# Code shared by LTDL_INSTALLABLE and LTDL_INIT([installable]).
+m4_defun([_LTDL_INSTALLABLE],
+[if test -f $prefix/lib/libltdl.la; then
+  lt_save_LDFLAGS="$LDFLAGS"
+  LDFLAGS="-L$prefix/lib $LDFLAGS"
+  AC_CHECK_LIB([ltdl], [lt_dlinit], [lt_lib_ltdl=yes])
+  LDFLAGS="$lt_save_LDFLAGS"
+  if test x"${lt_lib_ltdl-no}" = xyes; then
+    if test x"$enable_ltdl_install" != xyes; then
+      # Don't overwrite $prefix/lib/libltdl.la without --enable-ltdl-install
+      AC_MSG_WARN([not overwriting libltdl at $prefix, force with `--enable-ltdl-install'])
+      enable_ltdl_install=no
+    fi
+  elif test x"$enable_ltdl_install" = xno; then
+    AC_MSG_WARN([libltdl not installed, but installation disabled])
+  fi
+fi
+
+# If configure.ac declared an installable ltdl, and the user didn't override
+# with --disable-ltdl-install, we will install the shipped libltdl.
+case $enable_ltdl_install in
+  no) ac_configure_args="$ac_configure_args --enable-ltdl-install=no"
+      LIBLTDL="-lltdl"
+      LTDLDEPS=
+      LTDLINCL=
+      ;;
+  *)  enable_ltdl_install=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-install"
+      LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdl.la"
+      LTDLDEPS=$LIBLTDL
+      LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+      ;;
+esac
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# LTDL_INSTALLABLE
+
+
+# _LTDL_MODE_DISPATCH
+# -------------------
+m4_define([_LTDL_MODE_DISPATCH],
+[dnl If _LTDL_DIR is `.', then we are configuring libltdl itself:
+m4_if(_LTDL_DIR, [],
+	[],
+    dnl if _LTDL_MODE was not set already, the default value is `subproject':
+    [m4_case(m4_default(_LTDL_MODE, [subproject]),
+	  [subproject], [AC_CONFIG_SUBDIRS(_LTDL_DIR)
+			  _LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"])],
+	  [nonrecursive], [_LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"; lt_libobj_prefix="$lt_ltdl_dir/"])],
+	  [recursive], [],
+	[m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])dnl
+dnl Be careful not to expand twice:
+m4_define([$0], [])
+])# _LTDL_MODE_DISPATCH
+
+
+# _LT_LIBOBJ(MODULE_NAME)
+# -----------------------
+# Like AC_LIBOBJ, except that MODULE_NAME goes into _LT_LIBOBJS instead
+# of into LIBOBJS.
+AC_DEFUN([_LT_LIBOBJ], [
+  m4_pattern_allow([^_LT_LIBOBJS$])
+  AS_LITERAL_IF([$1], [_LT_LIBSOURCES([$1.c])])dnl
+  _LT_LIBOBJS="$_LT_LIBOBJS $1.$ac_objext"
+])# _LT_LIBOBJS
+
+
+# _LT_LIBSOURCES(MODULE_NAMES)
+# ----------------------------
+# Like AC_LIBSOURCES, except the directory where the libltdl source files
+# are expected is distinct from the user LIBOBJ directory.
+AC_DEFUN([_LT_LIBSOURCES], [
+  m4_foreach([_LTNAME], [$1], [
+    m4_syscmd([test -r "$lt_libobj_prefix]_LTNAME[" ||
+		test -z "$lt_libobj_prefix" ||
+		test ! -d "$lt_libobj_prefix"])dnl
+    m4_if(m4_sysval, [0], [],
+      [AC_FATAL([missing $lt_libobj_prefix/]_LTNAME)])
+  ])
+])# _LT_LIBSOURCES
+
+
+# LTDL_INIT([OPTIONS])
+# --------------------
+# Clients of libltdl can use this macro to allow the installer to
+# choose between a shipped copy of the ltdl sources or a preinstalled
+# version of the library.  If the shipped ltdl sources are not in a
+# subdirectory named libltdl, the directory name must be given by
+# LT_CONFIG_LTDL_DIR.
+AC_DEFUN([LTDL_INIT],
+[dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+dnl We need to keep our own list of libobjs separate from our parent project,
+dnl and the easiest way to do that is redefine the AC_LIBOBJs macro while
+dnl we look for our own LIBOBJs. Definitions in ltdl-libobj.m4.
+m4_pushdef([AC_LIBOBJ], m4_defn([_LT_LIBOBJ]))
+m4_pushdef([AC_LIBSOURCES], m4_defn([_LT_LIBSOURCES]))
+
+dnl If not otherwise defined, default to the 1.5.x compatible subproject mode:
+m4_if(_LTDL_MODE, [],
+        [m4_define([_LTDL_MODE], m4_default([$2], [subproject]))
+        m4_if([-1], [m4_bregexp(_LTDL_MODE, [\(subproject\|\(non\)?recursive\)])],
+                [m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])
+
+AC_ARG_WITH([included_ltdl],
+    [AS_HELP_STRING([--with-included-ltdl],
+                    [use the GNU ltdl sources included here])])
+
+if test "x$with_included_ltdl" != xyes; then
+  # We are not being forced to use the included libltdl sources, so
+  # decide whether there is a useful installed version we can use.
+  AC_CHECK_HEADER([ltdl.h],
+      [AC_CHECK_DECL([lt_dlinterface_register],
+	   [AC_CHECK_LIB([ltdl], [lt_dlinterface_register],
+	       [with_included_ltdl=no],
+	       [with_included_ltdl=yes])],
+	   [with_included_ltdl=yes],
+	   [AC_INCLUDES_DEFAULT
+	    #include <ltdl.h>])],
+      [with_included_ltdl=yes],
+      [AC_INCLUDES_DEFAULT]
+  )
+fi
+
+dnl If neither LT_CONFIG_LTDL_DIR, LTDL_CONVENIENCE nor LTDL_INSTALLABLE
+dnl was called yet, then for old times' sake, we assume libltdl is in an
+dnl eponymous directory:
+AC_PROVIDE_IFELSE([LT_CONFIG_LTDL_DIR], [], [_LT_CONFIG_LTDL_DIR([libltdl])])
+
+AC_ARG_WITH([ltdl_include],
+    [AS_HELP_STRING([--with-ltdl-include=DIR],
+                    [use the ltdl headers installed in DIR])])
+
+if test -n "$with_ltdl_include"; then
+  if test -f "$with_ltdl_include/ltdl.h"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl include directory: `$with_ltdl_include'])
+  fi
+else
+  with_ltdl_include=no
+fi
+
+AC_ARG_WITH([ltdl_lib],
+    [AS_HELP_STRING([--with-ltdl-lib=DIR],
+                    [use the libltdl.la installed in DIR])])
+
+if test -n "$with_ltdl_lib"; then
+  if test -f "$with_ltdl_lib/libltdl.la"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl library directory: `$with_ltdl_lib'])
+  fi
+else
+  with_ltdl_lib=no
+fi
+
+case ,$with_included_ltdl,$with_ltdl_include,$with_ltdl_lib, in
+  ,yes,no,no,)
+	m4_case(m4_default(_LTDL_TYPE, [convenience]),
+	    [convenience], [_LTDL_CONVENIENCE],
+	    [installable], [_LTDL_INSTALLABLE],
+	  [m4_fatal([unknown libltdl build type: ]_LTDL_TYPE)])
+	;;
+  ,no,no,no,)
+	# If the included ltdl is not to be used, then use the
+	# preinstalled libltdl we found.
+	AC_DEFINE([HAVE_LTDL], [1],
+	  [Define this if a modern libltdl is already installed])
+	LIBLTDL=-lltdl
+	LTDLDEPS=
+	LTDLINCL=
+	;;
+  ,no*,no,*)
+	AC_MSG_ERROR([`--with-ltdl-include' and `--with-ltdl-lib' options must be used together])
+	;;
+  *)	with_included_ltdl=no
+	LIBLTDL="-L$with_ltdl_lib -lltdl"
+	LTDLDEPS=
+	LTDLINCL="-I$with_ltdl_include"
+	;;
+esac
+INCLTDL="$LTDLINCL"
+
+# Report our decision...
+AC_MSG_CHECKING([where to find libltdl headers])
+AC_MSG_RESULT([$LTDLINCL])
+AC_MSG_CHECKING([where to find libltdl library])
+AC_MSG_RESULT([$LIBLTDL])
+
+_LTDL_SETUP
+
+dnl restore autoconf definition.
+m4_popdef([AC_LIBOBJ])
+m4_popdef([AC_LIBSOURCES])
+
+AC_CONFIG_COMMANDS_PRE([
+    _ltdl_libobjs=
+    _ltdl_ltlibobjs=
+    if test -n "$_LT_LIBOBJS"; then
+      # Remove the extension.
+      _lt_sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $_LT_LIBOBJS; do echo "$i"; done | sed "$_lt_sed_drop_objext" | sort -u`; do
+        _ltdl_libobjs="$_ltdl_libobjs $lt_libobj_prefix$i.$ac_objext"
+        _ltdl_ltlibobjs="$_ltdl_ltlibobjs $lt_libobj_prefix$i.lo"
+      done
+    fi
+    AC_SUBST([ltdl_LIBOBJS], [$_ltdl_libobjs])
+    AC_SUBST([ltdl_LTLIBOBJS], [$_ltdl_ltlibobjs])
+])
+
+# Only expand once:
+m4_define([LTDL_INIT])
+])# LTDL_INIT
+
+# Old names:
+AU_DEFUN([AC_LIB_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([AC_WITH_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([LT_WITH_LTDL], [LTDL_INIT($@)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIB_LTDL], [])
+dnl AC_DEFUN([AC_WITH_LTDL], [])
+dnl AC_DEFUN([LT_WITH_LTDL], [])
+
+
+# _LTDL_SETUP
+# -----------
+# Perform all the checks necessary for compilation of the ltdl objects
+#  -- including compiler checks and header checks.  This is a public
+# interface  mainly for the benefit of libltdl's own configure.ac, most
+# other users should call LTDL_INIT instead.
+AC_DEFUN([_LTDL_SETUP],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_SYS_MODULE_EXT])dnl
+AC_REQUIRE([LT_SYS_MODULE_PATH])dnl
+AC_REQUIRE([LT_SYS_DLSEARCH_PATH])dnl
+AC_REQUIRE([LT_LIB_DLLOAD])dnl
+AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+AC_REQUIRE([LT_FUNC_DLSYM_USCORE])dnl
+AC_REQUIRE([LT_SYS_DLOPEN_DEPLIBS])dnl
+AC_REQUIRE([gl_FUNC_ARGZ])dnl
+
+m4_require([_LT_CHECK_OBJDIR])dnl
+m4_require([_LT_HEADER_DLFCN])dnl
+m4_require([_LT_CHECK_DLPREOPEN])dnl
+m4_require([_LT_DECL_SED])dnl
+
+# lt_cv_dlopen_self gets defined by LT_SYS_DLOPEN_SELF, called by LT_INIT
+if test "$lt_cv_dlopen_self" = yes; then
+  AC_DEFINE([LTDL_DLOPEN_SELF_WORKS], [1],
+    [Define if dlopen(NULL) is able to resolve symbols from the main program.])
+fi
+
+dnl Don't require this, or it will be expanded earlier than the code
+dnl that sets the variables it relies on:
+_LT_ENABLE_INSTALL
+
+dnl _LTDL_MODE specific code must be called at least once:
+_LTDL_MODE_DISPATCH
+
+# In order that ltdl.c can compile, find out the first AC_CONFIG_HEADERS
+# the user used.  This is so that ltdl.h can pick up the parent projects
+# config.h file, The first file in AC_CONFIG_HEADERS must contain the
+# definitions required by ltdl.c.
+# FIXME: Remove use of undocumented AC_LIST_HEADERS (2.59 compatibility).
+AC_CONFIG_COMMANDS_PRE([dnl
+m4_pattern_allow([^LT_CONFIG_H$])dnl
+m4_ifset([AH_HEADER],
+    [LT_CONFIG_H=AH_HEADER],
+    [m4_ifset([AC_LIST_HEADERS],
+	    [LT_CONFIG_H=`echo "AC_LIST_HEADERS" | $SED 's,^[[      ]]*,,;s,[[ :]].*$,,'`],
+	[])])])
+AC_SUBST([LT_CONFIG_H])
+
+AC_CHECK_HEADERS([unistd.h dl.h sys/dl.h dld.h mach-o/dyld.h dirent.h],
+	[], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_FUNCS([closedir opendir readdir], [], [AC_LIBOBJ([lt__dirent])])
+AC_CHECK_FUNCS([strlcat strlcpy], [], [AC_LIBOBJ([lt__strl])])
+
+name=ltdl
+LTDLOPEN=`eval "\\$ECHO \"$libname_spec\""`
+AC_SUBST([LTDLOPEN])
+])# _LTDL_SETUP
+
+
+# _LT_ENABLE_INSTALL
+# ------------------
+m4_define([_LT_ENABLE_INSTALL],
+[AC_ARG_ENABLE([ltdl-install],
+    [AS_HELP_STRING([--enable-ltdl-install], [install libltdl])])
+
+case ,${enable_ltdl_install},${enable_ltdl_convenience} in
+  *yes*) ;;
+  *) enable_ltdl_convenience=yes ;;
+esac
+
+m4_ifdef([AM_CONDITIONAL],
+[AM_CONDITIONAL(INSTALL_LTDL, test x"${enable_ltdl_install-no}" != xno)
+ AM_CONDITIONAL(CONVENIENCE_LTDL, test x"${enable_ltdl_convenience-no}" != xno)])
+])# _LT_ENABLE_INSTALL
+
+
+# LT_SYS_DLOPEN_DEPLIBS
+# ---------------------
+AC_DEFUN([LT_SYS_DLOPEN_DEPLIBS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_CACHE_CHECK([whether deplibs are loaded by dlopen],
+  [lt_cv_sys_dlopen_deplibs],
+  [# PORTME does your system automatically load deplibs for dlopen?
+  # or its logical equivalent (e.g. shl_load for HP-UX < 11)
+  # For now, we just catch OSes we know something about -- in the
+  # future, we'll try test this programmatically.
+  lt_cv_sys_dlopen_deplibs=unknown
+  case $host_os in
+  aix3*|aix4.1.*|aix4.2.*)
+    # Unknown whether this is true for these versions of AIX, but
+    # we want this `case' here to explicitly catch those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  aix[[4-9]]*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  amigaos*)
+    case $host_cpu in
+    powerpc)
+      lt_cv_sys_dlopen_deplibs=no
+      ;;
+    esac
+    ;;
+  darwin*)
+    # Assuming the user has installed a libdl from somewhere, this is true
+    # If you are looking for one http://www.opendarwin.org/projects/dlcompat
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  freebsd* | dragonfly*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  gnu* | linux* | k*bsd*-gnu)
+    # GNU and its variants, using gnu ld.so (Glibc)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  hpux10*|hpux11*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  interix*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  irix[[12345]]*|irix6.[[01]]*)
+    # Catch all versions of IRIX before 6.2, and indicate that we don't
+    # know how it worked for any of those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  irix*)
+    # The case above catches anything before 6.2, and it's known that
+    # at 6.2 and later dlopen does load deplibs.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  netbsd*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  openbsd*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  osf[[1234]]*)
+    # dlopen did load deplibs (at least at 4.x), but until the 5.x series,
+    # it did *not* use an RPATH in a shared library to find objects the
+    # library depends on, so we explicitly say `no'.
+    lt_cv_sys_dlopen_deplibs=no
+    ;;
+  osf5.0|osf5.0a|osf5.1)
+    # dlopen *does* load deplibs and with the right loader patch applied
+    # it even uses RPATH in a shared library to search for shared objects
+    # that the library depends on, but there's no easy way to know if that
+    # patch is installed.  Since this is the case, all we can really
+    # say is unknown -- it depends on the patch being installed.  If
+    # it is, this changes to `yes'.  Without it, it would be `no'.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  osf*)
+    # the two cases above should catch all versions of osf <= 5.1.  Read
+    # the comments above for what we know about them.
+    # At > 5.1, deplibs are loaded *and* any RPATH in a shared library
+    # is used to find them so we can finally say `yes'.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  qnx*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  solaris*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  esac
+  ])
+if test "$lt_cv_sys_dlopen_deplibs" != yes; then
+ AC_DEFINE([LTDL_DLOPEN_DEPLIBS], [1],
+    [Define if the OS needs help to load dependent libraries for dlopen().])
+fi
+])# LT_SYS_DLOPEN_DEPLIBS
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYS_DLOPEN_DEPLIBS], [LT_SYS_DLOPEN_DEPLIBS])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYS_DLOPEN_DEPLIBS], [])
+
+
+# LT_SYS_MODULE_EXT
+# -----------------
+AC_DEFUN([LT_SYS_MODULE_EXT],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which extension is used for runtime loadable modules],
+  [libltdl_cv_shlibext],
+[
+module=yes
+eval libltdl_cv_shlibext=$shrext_cmds
+  ])
+if test -n "$libltdl_cv_shlibext"; then
+  m4_pattern_allow([LT_MODULE_EXT])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_EXT], ["$libltdl_cv_shlibext"],
+    [Define to the extension used for runtime loadable modules, say, ".so".])
+fi
+])# LT_SYS_MODULE_EXT
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBEXT], [LT_SYS_MODULE_EXT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBEXT], [])
+
+
+# LT_SYS_MODULE_PATH
+# ------------------
+AC_DEFUN([LT_SYS_MODULE_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which variable specifies run-time module search path],
+  [lt_cv_module_path_var], [lt_cv_module_path_var="$shlibpath_var"])
+if test -n "$lt_cv_module_path_var"; then
+  m4_pattern_allow([LT_MODULE_PATH_VAR])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_PATH_VAR], ["$lt_cv_module_path_var"],
+    [Define to the name of the environment variable that determines the run-time module search path.])
+fi
+])# LT_SYS_MODULE_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBPATH], [LT_SYS_MODULE_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBPATH], [])
+
+
+# LT_SYS_DLSEARCH_PATH
+# --------------------
+AC_DEFUN([LT_SYS_DLSEARCH_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([for the default library search path],
+  [lt_cv_sys_dlsearch_path],
+  [lt_cv_sys_dlsearch_path="$sys_lib_dlsearch_path_spec"])
+if test -n "$lt_cv_sys_dlsearch_path"; then
+  sys_dlsearch_path=
+  for dir in $lt_cv_sys_dlsearch_path; do
+    if test -z "$sys_dlsearch_path"; then
+      sys_dlsearch_path="$dir"
+    else
+      sys_dlsearch_path="$sys_dlsearch_path$PATH_SEPARATOR$dir"
+    fi
+  done
+  m4_pattern_allow([LT_DLSEARCH_PATH])dnl
+  AC_DEFINE_UNQUOTED([LT_DLSEARCH_PATH], ["$sys_dlsearch_path"],
+    [Define to the system default library search path.])
+fi
+])# LT_SYS_DLSEARCH_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYSSEARCHPATH], [LT_SYS_DLSEARCH_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYSSEARCHPATH], [])
+
+
+# _LT_CHECK_DLPREOPEN
+# -------------------
+m4_defun([_LT_CHECK_DLPREOPEN],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([whether libtool supports -dlopen/-dlpreopen],
+  [libltdl_cv_preloaded_symbols],
+  [if test -n "$lt_cv_sys_global_symbol_pipe"; then
+    libltdl_cv_preloaded_symbols=yes
+  else
+    libltdl_cv_preloaded_symbols=no
+  fi
+  ])
+if test x"$libltdl_cv_preloaded_symbols" = xyes; then
+  AC_DEFINE([HAVE_PRELOADED_SYMBOLS], [1],
+    [Define if libtool can extract symbol lists from object files.])
+fi
+])# _LT_CHECK_DLPREOPEN
+
+
+# LT_LIB_DLLOAD
+# -------------
+AC_DEFUN([LT_LIB_DLLOAD],
+[m4_pattern_allow([^LT_DLLOADERS$])
+LT_DLLOADERS=
+AC_SUBST([LT_DLLOADERS])
+
+AC_LANG_PUSH([C])
+
+LIBADD_DLOPEN=
+AC_SEARCH_LIBS([dlopen], [dl],
+	[AC_DEFINE([HAVE_LIBDL], [1],
+		   [Define if you have the libdl library or equivalent.])
+	if test "$ac_cv_search_dlopen" != "none required" ; then
+	  LIBADD_DLOPEN="-ldl"
+	fi
+	libltdl_cv_lib_dl_dlopen="yes"
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#if HAVE_DLFCN_H
+#  include <dlfcn.h>
+#endif
+    ]], [[dlopen(0, 0);]])],
+	    [AC_DEFINE([HAVE_LIBDL], [1],
+		       [Define if you have the libdl library or equivalent.])
+	    libltdl_cv_func_dlopen="yes"
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+	[AC_CHECK_LIB([svld], [dlopen],
+		[AC_DEFINE([HAVE_LIBDL], [1],
+			 [Define if you have the libdl library or equivalent.])
+	        LIBADD_DLOPEN="-lsvld" libltdl_cv_func_dlopen="yes"
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"])])])
+if test x"$libltdl_cv_func_dlopen" = xyes || test x"$libltdl_cv_lib_dl_dlopen" = xyes
+then
+  lt_save_LIBS="$LIBS"
+  LIBS="$LIBS $LIBADD_DLOPEN"
+  AC_CHECK_FUNCS([dlerror])
+  LIBS="$lt_save_LIBS"
+fi
+AC_SUBST([LIBADD_DLOPEN])
+
+LIBADD_SHL_LOAD=
+AC_CHECK_FUNC([shl_load],
+	[AC_DEFINE([HAVE_SHL_LOAD], [1],
+		   [Define if you have the shl_load function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"],
+    [AC_CHECK_LIB([dld], [shl_load],
+	    [AC_DEFINE([HAVE_SHL_LOAD], [1],
+		       [Define if you have the shl_load function.])
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"
+	    LIBADD_SHL_LOAD="-ldld"])])
+AC_SUBST([LIBADD_SHL_LOAD])
+
+case $host_os in
+darwin[[1567]].*)
+# We only want this for pre-Mac OS X 10.4.
+  AC_CHECK_FUNC([_dyld_func_lookup],
+	[AC_DEFINE([HAVE_DYLD], [1],
+		   [Define if you have the _dyld_func_lookup function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dyld.la"])
+  ;;
+beos*)
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}load_add_on.la"
+  ;;
+cygwin* | mingw* | os2* | pw32*)
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}loadlibrary.la"
+  ;;
+esac
+
+AC_CHECK_LIB([dld], [dld_link],
+	[AC_DEFINE([HAVE_DLD], [1],
+		   [Define if you have the GNU dld library.])
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dld_link.la"])
+AC_SUBST([LIBADD_DLD_LINK])
+
+m4_pattern_allow([^LT_DLPREOPEN$])
+LT_DLPREOPEN=
+if test -n "$LT_DLLOADERS"
+then
+  for lt_loader in $LT_DLLOADERS; do
+    LT_DLPREOPEN="$LT_DLPREOPEN-dlpreopen $lt_loader "
+  done
+  AC_DEFINE([HAVE_LIBDLLOADER], [1],
+            [Define if libdlloader will be built on this platform])
+fi
+AC_SUBST([LT_DLPREOPEN])
+
+dnl This isn't used anymore, but set it for backwards compatibility
+LIBADD_DL="$LIBADD_DLOPEN $LIBADD_SHL_LOAD"
+AC_SUBST([LIBADD_DL])
+
+AC_LANG_POP
+])# LT_LIB_DLLOAD
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLLIB], [LT_LIB_DLLOAD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLLIB], [])
+
+
+# LT_SYS_SYMBOL_USCORE
+# --------------------
+# does the compiler prefix global symbols with an underscore?
+AC_DEFUN([LT_SYS_SYMBOL_USCORE],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([for _ prefix in compiled symbols],
+  [lt_cv_sys_symbol_underscore],
+  [lt_cv_sys_symbol_underscore=no
+  cat > conftest.$ac_ext <<_LT_EOF
+void nm_test_func(){}
+int main(){nm_test_func;return 0;}
+_LT_EOF
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    ac_nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
+      # See whether the symbols have a leading underscore.
+      if grep '^. _nm_test_func' "$ac_nlist" >/dev/null; then
+        lt_cv_sys_symbol_underscore=yes
+      else
+        if grep '^. nm_test_func ' "$ac_nlist" >/dev/null; then
+	  :
+        else
+	  echo "configure: cannot find nm_test_func in $ac_nlist" >&AS_MESSAGE_LOG_FD
+        fi
+      fi
+    else
+      echo "configure: cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "configure: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.c >&AS_MESSAGE_LOG_FD
+  fi
+  rm -rf conftest*
+  ])
+  sys_symbol_underscore=$lt_cv_sys_symbol_underscore
+  AC_SUBST([sys_symbol_underscore])
+])# LT_SYS_SYMBOL_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYMBOL_USCORE], [LT_SYS_SYMBOL_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYMBOL_USCORE], [])
+
+
+# LT_FUNC_DLSYM_USCORE
+# --------------------
+AC_DEFUN([LT_FUNC_DLSYM_USCORE],
+[AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+if test x"$lt_cv_sys_symbol_underscore" = xyes; then
+  if test x"$libltdl_cv_func_dlopen" = xyes ||
+     test x"$libltdl_cv_lib_dl_dlopen" = xyes ; then
+	AC_CACHE_CHECK([whether we have to add an underscore for dlsym],
+	  [libltdl_cv_need_uscore],
+	  [libltdl_cv_need_uscore=unknown
+          save_LIBS="$LIBS"
+          LIBS="$LIBS $LIBADD_DLOPEN"
+	  _LT_TRY_DLOPEN_SELF(
+	    [libltdl_cv_need_uscore=no], [libltdl_cv_need_uscore=yes],
+	    [],				 [libltdl_cv_need_uscore=cross])
+	  LIBS="$save_LIBS"
+	])
+  fi
+fi
+
+if test x"$libltdl_cv_need_uscore" = xyes; then
+  AC_DEFINE([NEED_USCORE], [1],
+    [Define if dlsym() requires a leading underscore in symbol names.])
+fi
+])# LT_FUNC_DLSYM_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLSYM_USCORE], [LT_FUNC_DLSYM_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLSYM_USCORE], [])
--- origsrc/libtunepimp-0.5.3/libltdl/slist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libtunepimp-0.5.3/libltdl/slist.c	2008-06-16 01:20:05.781250000 -0500
@@ -0,0 +1,375 @@
+/* slist.c -- generalised singly linked lists
+
+   Copyright (C) 2000, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Written by Gary V. Vaughan, 2000
+
+   NOTE: The canonical source of this file is maintained with the
+   GNU Libtool package.  Report bugs to bug-libtool@gnu.org.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*/
+
+#include <assert.h>
+
+#include "slist.h"
+#include <stddef.h>
+
+static SList *	slist_sort_merge    (SList *left, SList *right,
+				     SListCompare *compare, void *userdata);
+
+
+/* Call DELETE repeatedly on each element of HEAD.
+
+   CAVEAT: If you call this when HEAD is the start of a list of boxed
+           items, you must remember that each item passed back to your
+	   DELETE function will be a boxed item that must be slist_unbox()ed
+	   before operating on its contents.
+
+   e.g. void boxed_delete (void *item) { item_free (slist_unbox (item)); }
+        ...
+	  slist = slist_delete (slist, boxed_delete);
+	...
+*/
+SList *
+slist_delete (SList *head, void (*delete_fct) (void *item))
+{
+  assert (delete_fct);
+
+  while (head)
+    {
+      SList *next = head->next;
+      (*delete_fct) (head);
+      head = next;
+    }
+
+  return 0;
+}
+
+/* Call FIND repeatedly with MATCHDATA and each item of *PHEAD, until
+   FIND returns non-NULL, or the list is exhausted.  If a match is found
+   the matching item is destructively removed from *PHEAD, and the value
+   returned by the matching call to FIND is returned.
+
+   CAVEAT: To avoid memory leaks, unless you already have the address of
+           the stale item, you should probably return that from FIND if
+	   it makes a successful match.  Don't forget to slist_unbox()
+	   every item in a boxed list before operating on its contents.   */
+void *
+slist_remove (SList **phead, SListCallback *find, void *matchdata)
+{
+  SList *stale = 0;
+  void *result = 0;
+
+  assert (find);
+
+  if (!phead || !*phead)
+    return 0;
+
+  /* Does the head of the passed list match? */
+  result = (*find) (*phead, matchdata);
+  if (result)
+    {
+      stale = *phead;
+      *phead = stale->next;
+    }
+  /* what about the rest of the elements? */
+  else
+    {
+      SList *head;
+      for (head = *phead; head->next; head = head->next)
+	{
+	  result = (*find) (head->next, matchdata);
+	  if (result)
+	    {
+	      stale		= head->next;
+	      head->next	= stale->next;
+	      break;
+	    }
+	}
+    }
+
+  return result;
+}
+
+/* Call FIND repeatedly with each element of SLIST and MATCHDATA, until
+   FIND returns non-NULL, or the list is exhausted.  If a match is found
+   the value returned by the matching call to FIND is returned. */
+void *
+slist_find (SList *slist, SListCallback *find, void *matchdata)
+{
+  void *result = 0;
+
+  assert (find);
+
+  for (; slist; slist = slist->next)
+    {
+      result = (*find) (slist, matchdata);
+      if (result)
+	break;
+    }
+
+  return result;
+}
+
+/* Return a single list, composed by destructively concatenating the
+   items in HEAD and TAIL.  The values of HEAD and TAIL are undefined
+   after calling this function.
+
+   CAVEAT: Don't mix boxed and unboxed items in a single list.
+
+   e.g.  slist1 = slist_concat (slist1, slist2);  */
+SList *
+slist_concat (SList *head, SList *tail)
+{
+  SList *last;
+
+  if (!head)
+    {
+      return tail;
+    }
+
+  last = head;
+  while (last->next)
+    last = last->next;
+
+  last->next = tail;
+
+  return head;
+}
+
+/* Return a single list, composed by destructively appending all of
+   the items in SLIST to ITEM.  The values of ITEM and SLIST are undefined
+   after calling this function.
+
+   CAVEAT:  Don't mix boxed and unboxed items in a single list.
+
+   e.g.  slist1 = slist_cons (slist_box (data), slist1);  */
+SList *
+slist_cons (SList *item, SList *slist)
+{
+  if (!item)
+    {
+      return slist;
+    }
+
+  assert (!item->next);
+
+  item->next = slist;
+  return item;
+}
+
+/* Return a list starting at the second item of SLIST.  */
+SList *
+slist_tail (SList *slist)
+{
+  return slist ? slist->next : NULL;
+}
+
+/* Return a list starting at the Nth item of SLIST.  If SLIST is less
+   than N items long, NULL is returned.  Just to be confusing, list items
+   are counted from 1, to get the 2nd element of slist:
+
+   e.g. shared_list = slist_nth (slist, 2);  */
+SList *
+slist_nth (SList *slist, size_t n)
+{
+  for (;n > 1 && slist; n--)
+    slist = slist->next;
+
+  return slist;
+}
+
+/* Return the number of items in SLIST.  We start counting from 1, so
+   the length of a list with no items is 0, and so on.  */
+size_t
+slist_length (SList *slist)
+{
+  size_t n;
+
+  for (n = 0; slist; ++n)
+    slist = slist->next;
+
+  return n;
+}
+
+/* Destructively reverse the order of items in SLIST.  The value of SLIST
+   is undefined after calling this function.
+
+  CAVEAT: You must store the result of this function, or you might not
+          be able to get all the items except the first one back again.
+
+  e.g.    slist = slist_reverse (slist);  */
+SList *
+slist_reverse (SList *slist)
+{
+  SList *result = 0;
+  SList *next;
+
+  while (slist)
+    {
+      next		= slist->next;
+      slist->next	= result;
+      result		= slist;
+      slist 		= next;
+    }
+
+  return result;
+}
+
+/* Call FOREACH once for each item in SLIST, passing both the item and
+   USERDATA on each call. */
+void *
+slist_foreach (SList *slist, SListCallback *foreach, void *userdata)
+{
+  void *result = 0;
+
+  assert (foreach);
+
+  while (slist)
+    {
+      SList *next = slist->next;
+      result = (*foreach) (slist, userdata);
+
+      if (result)
+	break;
+
+      slist = next;
+    }
+
+  return result;
+}
+
+/* Destructively merge the items of two ordered lists LEFT and RIGHT,
+   returning a single sorted list containing the items of both --  Part of
+   the quicksort algorithm.  The values of LEFT and RIGHT are undefined
+   after calling this function.
+
+   At each iteration, add another item to the merged list by taking the
+   lowest valued item from the head of either LEFT or RIGHT, determined
+   by passing those items and USERDATA to COMPARE.  COMPARE should return
+   less than 0 if the head of LEFT has the lower value, greater than 0 if
+   the head of RIGHT has the lower value, otherwise 0.  */
+static SList *
+slist_sort_merge (SList *left, SList *right, SListCompare *compare,
+		  void *userdata)
+{
+  SList merged, *insert;
+
+  insert = &merged;
+
+  while (left && right)
+    {
+      if ((*compare) (left, right, userdata) <= 0)
+	{
+	  insert = insert->next = left;
+	  left = left->next;
+	}
+      else
+	{
+	  insert = insert->next = right;
+	  right = right->next;
+	}
+    }
+
+  insert->next = left ? left : right;
+
+  return merged.next;
+}
+
+/* Perform a destructive quicksort on the items in SLIST, by repeatedly
+   calling COMPARE with a pair of items from SLIST along with USERDATA
+   at every iteration.  COMPARE is a function as defined above for
+   slist_sort_merge().  The value of SLIST is undefined after calling
+   this function.
+
+   e.g.  slist = slist_sort (slist, compare, 0);  */
+SList *
+slist_sort (SList *slist, SListCompare *compare, void *userdata)
+{
+  SList *left, *right;
+
+  if (!slist)
+    return slist;
+
+  /* Be sure that LEFT and RIGHT never contain the same item.  */
+  left = slist;
+  right = slist->next;
+
+  /* Skip two items with RIGHT and one with SLIST, until RIGHT falls off
+     the end.  SLIST must be about half way along.  */
+  while (right && (right = right->next))
+    {
+      if (!right || !(right = right->next))
+	break;
+      slist = slist->next;
+    }
+  right = slist->next;
+  slist->next = 0;
+
+  /* Sort LEFT and RIGHT, then merge the two.  */
+  return slist_sort_merge (slist_sort (left, compare, userdata),
+			   slist_sort (right, compare, userdata),
+			   compare, userdata);
+}
+
+
+/* Aside from using the functions above to manage chained structures of
+   any type that has a NEXT pointer as its first field, SLISTs can
+   be comprised of boxed items.  The boxes are chained together in
+   that case, so there is no need for a NEXT field in the item proper.
+   Some care must be taken to slist_box and slist_unbox each item in
+   a boxed list at the appropriate points to avoid leaking the memory
+   used for the boxes.  It us usually a very bad idea to mix boxed and
+   non-boxed items in a single list.  */
+
+/* Return a `boxed' freshly mallocated 1 element list containing
+   USERDATA.  */
+SList *
+slist_box (const void *userdata)
+{
+  SList *item = (SList *) malloc (sizeof *item);
+
+  if (item)
+    {
+      item->next     = 0;
+      item->userdata = userdata;
+    }
+
+  return item;
+}
+
+/* Return the contents of a `boxed' ITEM, recycling the box itself.  */
+void *
+slist_unbox (SList *item)
+{
+  void *userdata = 0;
+
+  if (item)
+    {
+      /* Strip the const, because responsibility for this memory
+	 passes to the caller on return.  */
+      userdata = (void *) item->userdata;
+      free (item);
+    }
+
+  return userdata;
+}
--- origsrc/libtunepimp-0.5.3/plugins/flac/Makefile.am	2006-11-18 04:51:35.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/flac/Makefile.am	2008-06-16 01:08:07.328125000 -0500
@@ -26,15 +26,15 @@
 
 lib_LTLIBRARIES = flac.la
 flac_la_SOURCES = flac.cpp flacdecode.cpp flacdecode.h flac_meta.cpp flac_meta.h
-flac_la_LDFLAGS = -module -avoid-version
-flac_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la -lFLAC -lmusicbrainz
+flac_la_LDFLAGS = -module -avoid-version -no-undefined
+flac_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la -lFLAC -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/flac.tpp
-	ln -s ../../plugins/flac/.libs/flac.so $(top_srcdir)/examples/plugins/flac.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/flac.tpp
+	ln -s ../../plugins/flac/.libs/flac$(SOEXT) $(top_builddir)/examples/plugins/flac.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/flac.tpp
+	rm -f $(top_builddir)/examples/plugins/flac.tpp
--- origsrc/libtunepimp-0.5.3/plugins/mp3/Makefile.am	2006-11-18 04:51:07.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/mp3/Makefile.am	2008-06-16 01:08:07.328125000 -0500
@@ -28,17 +28,17 @@
 
 lib_LTLIBRARIES = mp3.la
 mp3_la_SOURCES = mp3.cpp mp3decode.cpp mp3decode.h id3_meta.cpp id3_2_3_meta.cpp mp3info.cpp
-mp3_la_LDFLAGS = -module -avoid-version
-mp3_la_LIBADD = ../../lib/utf8/libutf8.la id3tag/libid3tag.la id3tag-2.3/libid3tag23.la ../../lib/libpluginsupport.la -lmad -lmusicbrainz
+mp3_la_LDFLAGS = -module -avoid-version -no-undefined
+mp3_la_LIBADD = id3tag/libid3tag.la id3tag-2.3/libid3tag23.la ../../lib/libpluginsupport.la ../../lib/libtunepimp.la -lmad -lmusicbrainz -lz
 
 noinst_HEADERS = mp3decode.h id3_meta.h mp3info.h id3_2_3_meta.h mp3.h
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/mp3.tpp
-	ln -s ../../plugins/mp3/.libs/mp3.so $(top_srcdir)/examples/plugins/mp3.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/mp3.tpp
+	ln -s ../../plugins/mp3/.libs/mp3$(SOEXT) $(top_builddir)/examples/plugins/mp3.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/mp3.tpp
+	rm -f $(top_builddir)/examples/plugins/mp3.tpp
--- origsrc/libtunepimp-0.5.3/plugins/mp4/Makefile.am	2006-11-18 04:51:08.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/mp4/Makefile.am	2008-06-16 01:08:07.718750000 -0500
@@ -26,15 +26,15 @@
 
 lib_LTLIBRARIES = mp4.la
 mp4_la_SOURCES = mp4.cpp
-mp4_la_LDFLAGS = -module -avoid-version
-mp4_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la -lmp4v2 -lmusicbrainz
+mp4_la_LDFLAGS = -module -avoid-version -no-undefined
+mp4_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la -lmp4v2 -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/mp4.tpp
-	ln -s ../../plugins/mp4/.libs/mp4.so $(top_srcdir)/examples/plugins/mp4.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/mp4.tpp
+	ln -s ../../plugins/mp4/.libs/mp4$(SOEXT) $(top_builddir)/examples/plugins/mp4.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/mp4.tpp
+	rm -f $(top_builddir)/examples/plugins/mp4.tpp
--- origsrc/libtunepimp-0.5.3/plugins/mp4/mp4.cpp	2008-06-16 01:07:53.406250000 -0500
+++ src/libtunepimp-0.5.3/plugins/mp4/mp4.cpp	2008-06-16 01:08:07.796875000 -0500
@@ -232,9 +232,7 @@
   
   strcpy(mdata->fileFormat, fileName + strlen(fileName) - 3); 
   
-  if (!MP4Close(mp4file))
-    return 0;
-  
+  MP4Close(mp4file);
   return 1;
 }
 
@@ -316,8 +314,7 @@
   sprintf(temp, "%d", mdata->nonAlbum);  
   MP4SetMetadataFreeForm(mp4file, "MusicBrainz Non-Album", (u_int8_t *)temp, strlen(temp) + 1);
   
-  if (!MP4Close(mp4file))
-    return 0;
+  MP4Close(mp4file);
 
 #ifndef WIN32
   if (!MP4Optimize(utf8ToEncoding(fileName, encoding).c_str()))
--- origsrc/libtunepimp-0.5.3/plugins/mpc/Makefile.am	2006-11-18 04:51:08.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/mpc/Makefile.am	2008-06-16 01:08:07.812500000 -0500
@@ -25,25 +25,25 @@
 INCLUDES = -I$(top_srcdir)/include/tunepimp-0.5 $(INCLTDL) 
 
 lib_LTLIBRARIES = mpc.la
-mpc_la_LDFLAGS = -module -avoid-version
+mpc_la_LDFLAGS = -module -avoid-version -no-undefined
 mpc_la_DISTSOURCES = mpc.cpp mpcdecode.cpp
 
 if HAVE_MPCDEC
 mpc_la_CXXFLAGS = $(TAGLIB_CFLAGS) -DHAVE_MPCDEC
 mpc_la_SOURCES = mpc.cpp mpcdecode.cpp
-mpc_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmpcdec -lmusicbrainz
+mpc_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmpcdec -lmusicbrainz
 else
 mpc_la_CXXFLAGS = $(TAGLIB_CFLAGS)
 mpc_la_SOURCES = mpc.cpp
-mpc_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmusicbrainz
+mpc_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmusicbrainz
 endif
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/mpc.tpp
-	ln -s ../../plugins/mpc/.libs/mpc.so $(top_srcdir)/examples/plugins/mpc.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/mpc.tpp
+	ln -s ../../plugins/mpc/.libs/mpc$(SOEXT) $(top_builddir)/examples/plugins/mpc.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/mpc.tpp
+	rm -f $(top_builddir)/examples/plugins/mpc.tpp
--- origsrc/libtunepimp-0.5.3/plugins/speex/Makefile.am	2006-11-18 04:51:10.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/speex/Makefile.am	2008-06-16 01:08:07.812500000 -0500
@@ -27,15 +27,15 @@
 lib_LTLIBRARIES = speex.la
 speex_la_SOURCES = speex.cpp speexfile.cpp speexfile.h speexproperties.cpp speexproperties.h
 speex_la_CXXFLAGS = $(TAGLIB_CFLAGS)
-speex_la_LDFLAGS = -module -avoid-version
-speex_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmusicbrainz
+speex_la_LDFLAGS = -module -avoid-version -no-undefined
+speex_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/speex.tpp
-	ln -s ../../plugins/speex/.libs/speex.so $(top_srcdir)/examples/plugins/speex.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/speex.tpp
+	ln -s ../../plugins/speex/.libs/speex$(SOEXT) $(top_builddir)/examples/plugins/speex.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/speex.tpp
+	rm -f $(top_builddir)/examples/plugins/speex.tpp
--- origsrc/libtunepimp-0.5.3/plugins/tta/Makefile.am	2006-11-18 04:51:38.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/tta/Makefile.am	2008-06-16 01:08:07.828125000 -0500
@@ -27,15 +27,15 @@
 lib_LTLIBRARIES = tta.la
 tta_la_SOURCES = tta.cpp ttafile.cpp ttafile.h ttaproperties.cpp ttaproperties.h
 tta_la_CXXFLAGS = $(TAGLIB_CFLAGS)
-tta_la_LDFLAGS = -module -avoid-version
-tta_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmusicbrainz
+tta_la_LDFLAGS = -module -avoid-version -no-undefined
+tta_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/tta.tpp
-	ln -s ../../plugins/tta/.libs/tta.so $(top_srcdir)/examples/plugins/tta.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/tta.tpp
+	ln -s ../../plugins/tta/.libs/tta$(SOEXT) $(top_builddir)/examples/plugins/tta.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/tta.tpp
+	rm -f $(top_builddir)/examples/plugins/tta.tpp
--- origsrc/libtunepimp-0.5.3/plugins/vorbis/Makefile.am	2006-11-18 04:51:20.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/vorbis/Makefile.am	2008-06-16 01:08:07.890625000 -0500
@@ -27,17 +27,17 @@
 
 lib_LTLIBRARIES = vorbis.la
 vorbis_la_SOURCES = vorbis.cpp vorbisdecode.cpp vorbisdecode.h vcedit.c vorbis_meta.cpp i18n.h
-vorbis_la_LDFLAGS = -module -avoid-version
-vorbis_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la -logg -lvorbis -lvorbisfile -lmusicbrainz
+vorbis_la_LDFLAGS = -module -avoid-version -no-undefined
+vorbis_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la -logg -lvorbis -lvorbisfile -lmusicbrainz
 
 noinst_HEADERS = vcedit.h vorbis_meta.h
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/vorbis.tpp
-	ln -s ../../plugins/vorbis/.libs/vorbis.so $(top_srcdir)/examples/plugins/vorbis.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/vorbis.tpp
+	ln -s ../../plugins/vorbis/.libs/vorbis$(SOEXT) $(top_builddir)/examples/plugins/vorbis.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/vorbis.tpp
+	rm -f $(top_builddir)/examples/plugins/vorbis.tpp
--- origsrc/libtunepimp-0.5.3/plugins/wav/Makefile.am	2006-11-28 14:24:03.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/wav/Makefile.am	2008-06-16 01:08:07.906250000 -0500
@@ -26,15 +26,15 @@
 
 lib_LTLIBRARIES = wav.la
 wav_la_SOURCES = wav.cpp wavdecode.cpp wavdecode.h
-wav_la_LDFLAGS = -module -avoid-version
-wav_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la -lmusicbrainz
+wav_la_LDFLAGS = -module -avoid-version -no-undefined
+wav_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/wav.tpp
-	ln -s ../../plugins/wav/.libs/wav.so $(top_srcdir)/examples/plugins/wav.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/wav.tpp
+	ln -s ../../plugins/wav/.libs/wav$(SOEXT) $(top_builddir)/examples/plugins/wav.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/wav.tpp
+	rm -f $(top_builddir)/examples/plugins/wav.tpp
--- origsrc/libtunepimp-0.5.3/plugins/wma/Makefile.am	2006-11-18 04:51:28.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/wma/Makefile.am	2008-06-16 01:08:07.921875000 -0500
@@ -28,15 +28,15 @@
 wma_la_SOURCES = wma.cpp wmaattribute.cpp wmaattribute.h wmafile.cpp wmafile.h \
 	wmaproperties.cpp wmaproperties.h wmatag.cpp wmatag.h
 wma_la_CXXFLAGS = $(TAGLIB_CFLAGS)
-wma_la_LDFLAGS = -module -avoid-version
-wma_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmusicbrainz
+wma_la_LDFLAGS = -module -avoid-version -no-undefined
+wma_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/wma.tpp
-	ln -s ../../plugins/wma/.libs/wma.so $(top_srcdir)/examples/plugins/wma.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/wma.tpp
+	ln -s ../../plugins/wma/.libs/wma$(SOEXT) $(top_builddir)/examples/plugins/wma.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/wma.tpp
+	rm -f $(top_builddir)/examples/plugins/wma.tpp
--- origsrc/libtunepimp-0.5.3/plugins/wv/Makefile.am	2006-11-18 04:51:41.000000000 -0600
+++ src/libtunepimp-0.5.3/plugins/wv/Makefile.am	2008-06-16 01:08:07.921875000 -0500
@@ -27,15 +27,15 @@
 lib_LTLIBRARIES = wv.la
 wv_la_SOURCES = wv.cpp wvfile.cpp wvfile.h wvproperties.cpp wvproperties.h
 wv_la_CXXFLAGS = $(TAGLIB_CFLAGS)
-wv_la_LDFLAGS = -module -avoid-version
-wv_la_LIBADD = ../../lib/utf8/libutf8.la ../../lib/libpluginsupport.la $(TAGLIB_LIBS) -lmusicbrainz
+wv_la_LDFLAGS = -module -avoid-version -no-undefined
+wv_la_LIBADD = ../../lib/libpluginsupport.la ../../lib/libtunepimp.la $(TAGLIB_LIBS) -lmusicbrainz
 
 all:
-	mkdir -p $(top_srcdir)/examples/plugins
-	rm -f $(top_srcdir)/examples/plugins/wv.tpp
-	ln -s ../../plugins/wv/.libs/wv.so $(top_srcdir)/examples/plugins/wv.tpp
+	mkdir -p $(top_builddir)/examples/plugins
+	rm -f $(top_builddir)/examples/plugins/wv.tpp
+	ln -s ../../plugins/wv/.libs/wv$(SOEXT) $(top_builddir)/examples/plugins/wv.tpp
 
 install-exec-am:
 
 clean distclean:
-	rm -f $(top_srcdir)/examples/plugins/wv.tpp
+	rm -f $(top_builddir)/examples/plugins/wv.tpp
